
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -Wall -q -c -o lean.prg -L lean.lst main.asm
; Fri Nov  1 14:02:28 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm

=$0801					ProgramStart = $0801 						; where source code starts.
=$b8bf					UserDictionary = EndCode 					; user dictionary
=$bc00					CodeMemory = $BC00 							; where object code goes.
=$063f					AssemblerStack = $063F 						; compiler stack space.
=$0700					VariableMemory = $0700 						; data memory allocaed from here

;******  Processing file: data.asm

=64					LINEBUFFSIZE = 64
=128					VALBUFFSIZE = 128
=$0640					lineBuffer = $0640	 						; current line, match encoded.
=$0680					valueBuffer = $0680 						; buffer for associated values.
>0000					scanPtr:	.word ?							; BASIC scan position.
>0002					aStackPtr:	.word ? 						; compiler stack.
>0004					dictPtr:	.word ? 						; dictionary pointer
>0006					genPtr:		.word ? 						; code generation pointer
>0008					varPtr: 	.word ?							; next free variable pointer.
>000a					zTemp0:		.word ? 						; temps.
>000c					zTemp1:		.word ?
>000e					zTemp2:		.word ?
>0010					zTemp3:		.word ?
>0012					lastCreate:	.word ? 						; last created dictionary word
>0014					codePtr:	.word ? 						; code pointer
>0016					codeBank:	.byte ?							; code bank
>0017					originalSP:			.byte ? 				; 6502 stack on entry.
>0018					lastDefine:			.word ? 				; last defined word.
>001a					lineNumber:			.word ? 				; current line number
>001c					identStart:			.byte ? 				; start offset of current identifier
>001d					dirLowByte:			.byte ?					; values returned from search
>001e					dirHighByte:		.byte ?
>001f					dirBank:			.byte ?
>0020					dirLength:			.byte ?
>0021					valueBufferPos:		.byte ? 				; position in value buffer.
>0022					genPos: 			.byte ? 				; position in line buffer, generation.
>0023					generateVar:		.word ? 				; variables used in set value
>0025					elementData:		.fill 3 				; data from matched constant/identifier
>0028					codeBackup:			.fill 3 				; backup code pointer.
>002b					varSize:			.byte ? 				; size of current variable.
>002c					matchCount:			.byte ? 				; successful line matches (for errors)
=$8f					REM_TOKEN = $8F 							; C64 REM Token
="*"					SCM_TOP = '*'								; top of stack marker.
="P"					SCM_PROC = 'P'								; procedure marker
="R"					SCM_REPEAT = 'R'							; repeat marker
="F"					SCM_FOR = 'F' 								; for marker (8 bit)
="G"					SCM_INTFOR = 'G'							; for marker (16 bit)
="I"					SCM_IF = 'I'								; if/else/endif marker.
=$60					CPU_RETURN = $60 							; RTS opcode.
=$48					CPU_PHA = $48 								; PHA
=$68					CPU_PLA = $68 								; PLA
=$3a					CPU_DECA = $3A 								; DEC A
=$d0					CPU_BNE = $D0								; BNE
=$80					CPU_BRA = $80								; BRA
=$20					CPU_JSR = $20 								; JSR
=$da					CPU_PHX = $DA 								; PHX
=$fa					CPU_PLX = $FA 								; PLX
=$c9					CPU_CMPIM = $C9 							; CMP#
=$e0					CPU_CPXIM = $E0 							; CPX#
=$ca					CPU_DEX = $CA 								; DEX

;******  Return to file: main.asm


;******  Processing file: generated/cgconst.inc

=$53					CGEN_C_ISZERO = $53
=$63					CGEN_C_LOW = $63
=$73					CGEN_C_HIGH = $73
=$83					CGEN_C_LOWPLUS1 = $83
=$93					CGEN_C_SETDATA = $93
=$a3					CGEN_C_EXEC = $a3

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.a000	ba		tsx				tsx 									; save SP
.a001	86 17		stx $17				stx 	originalSP
.a003	20 ec b1	jsr $b1ec			jsr 	LoadBasicCode
.a006	20 78 a8	jsr $a878			jsr 	StackReset 						; reset convert stack.
.a009	20 bc a6	jsr $a6bc			jsr 	VariableReset 					; reset variable memory.
.a00c	20 98 a3	jsr $a398			jsr 	DictionaryReset 				; reset user dictionary
.a00f	20 0c a4	jsr $a40c			jsr 	CodeReset 						; reset code output.
.a012	20 3c a0	jsr $a03c			jsr 	ScannerReset 					; reset scanner
.a015					AsmLoop:
.a015	20 3f a0	jsr $a03f			jsr 	ScannerFind 					; next thing in code
.a018	90 08		bcc $a022			bcc 	AsmEnd 							; nothing more
.a01a	20 81 a0	jsr $a081			jsr 	ProcessLineToBuffer 			; convert it.
.a01d	20 cd a1	jsr $a1cd			jsr 	GeneratorSearch 				; check it for generators
.a020	80 f3		bra $a015			bra 	AsmLoop 						; and keep going.
.a022					AsmEnd:
.a022	a9 2a		lda #$2a			lda 	#SCM_TOP 						; check structures are done
.a024	20 b1 a8	jsr $a8b1			jsr 	StackCheckStructureMarker
.a027	20 2e a0	jsr $a02e			jsr 	CallCodeMemory
.a02a					ReturnCaller:
.a02a	a6 17		ldx $17				ldx		originalSP 						; restore XP and exit.
.a02c	9a		txs				txs
.a02d	60		rts				rts
.a02e					CallCodeMemory:
.a02e	a5 18		lda $18				lda 	lastDefine
.a030	05 19		ora $19				ora 	lastDefine+1
.a032	f0 07		beq $a03b			beq 	_NoExecute
.a034	a5 14		lda $14				lda 	codePtr							; pass in byte after code.
.a036	a6 15		ldx $15				ldx 	codePtr+1
.a038	6c 18 00	jmp ($0018)			jmp 	(lastDefine)					; call last definition.
.a03b					_NoExecute:
.a03b	60		rts				rts

;******  Processing file: lean/scanner.asm

.a03c					ScannerReset:
.a03c	64 01		stz $01				stz 	scanPtr+1 					; zero MSB means the start
.a03e	60		rts				rts
.a03f					ScannerFind:
.a03f	48		pha				pha 								; save registers
.a040	da		phx				phx
.a041	5a		phy				phy
.a042	a5 01		lda $01				lda 	scanPtr+1 					; reset the scanner pointer ?
.a044	d0 0a		bne $a050			bne 	_SFScanForward 				; no, scan forward from current.
.a046	a9 01		lda #$01			lda 	#(ProgramStart) & $FF
.a048	85 00		sta $00				sta 	scanPtr
.a04a	a9 08		lda #$08			lda 	#(ProgramStart) >> 8
.a04c	85 01		sta $01				sta 	scanPtr+1
.a04e	80 12		bra $a062			bra 	_SFCheck 					; check if this one is a REM.
.a050					_SFScanForward:
.a050	a0 01		ldy #$01			ldy 	#1 							; check if the offset is zero
.a052	b2 00		lda ($00)			lda 	(scanPtr)
.a054	11 00		ora ($00),y			ora 	(scanPtr),y
.a056	18		clc				clc 								; if so exit with CC.
.a057	f0 24		beq $a07d			beq 	_SFExit
.a059	b2 00		lda ($00)			lda 	(scanPtr) 					; forward to next.
.a05b	aa		tax				tax
.a05c	b1 00		lda ($00),y			lda 	(scanPtr),y
.a05e	86 00		stx $00				stx 	scanPtr
.a060	85 01		sta $01				sta 	scanPtr+1
.a062					_SFCheck:
.a062	a0 02		ldy #$02			ldy 	#2 								; copy line number.
.a064	b1 00		lda ($00),y			lda 	(scanPtr),y
.a066	85 1a		sta $1a				sta 	lineNumber
.a068	c8		iny				iny
.a069	b1 00		lda ($00),y			lda 	(scanPtr),y
.a06b	85 1b		sta $1b				sta 	lineNumber+1
.a06d	c8		iny				iny
.a06e	b1 00		lda ($00),y			lda 	(scanPtr),y 				; is it a "REM." line ?
.a070	c9 8f		cmp #$8f			cmp 	#REM_TOKEN
.a072	d0 dc		bne $a050			bne 	_SFScanForward
.a074	c8		iny				iny
.a075	b1 00		lda ($00),y			lda 	(scanPtr),y 				; is it followed by a '.'
.a077	c8		iny				iny
.a078	c9 2e		cmp #$2e			cmp 	#"."
.a07a	d0 d4		bne $a050			bne 	_SFScanForward
.a07c	38		sec				sec 								; found something, exit with CS.
.a07d					_SFExit:
.a07d	7a		ply				ply 								; load registers and exit.
.a07e	fa		plx				plx
.a07f	68		pla				pla
.a080	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: lean/process.asm

.a081					ProcessLineToBuffer:
.a081	a0 06		ldy #$06			ldy 	#6 							; position in line
.a083	a2 00		ldx #$00			ldx 	#0 							; position in buffer
.a085	64 21		stz $21				stz 	valueBufferPos 				; reset value buffer pos
.a087	a9 ff		lda #$ff			lda 	#$FF
.a089	8d 80 06	sta $0680			sta 	valueBuffer 				; erase value buffer (end marker $FF)
.a08c					_PLTConvert:
.a08c	b1 00		lda ($00),y			lda 	(scanPtr),y 				; next character
.a08e	f0 7a		beq $a10a			beq 	_PLTExit
.a090	c8		iny				iny
.a091	c9 20		cmp #$20			cmp 	#' ' 						; skip over spaces.
.a093	f0 f7		beq $a08c			beq 	_PLTConvert
.a095	20 6e a1	jsr $a16e			jsr 	PLTCheckCharacter 			; identifier character.
.a098	b0 08		bcs $a0a2			bcs 	_PLTIsIdentifier 			; it's an identifier.
.a09a	09 80		ora #$80			ora 	#$80 						; set bit 7
.a09c	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write out
.a09f	e8		inx				inx
.a0a0	80 ea		bra $a08c			bra 	_PLTConvert
.a0a2					_PLTIsIdentifier:
.a0a2	86 1c		stx $1c				stx 	identStart 					; save as start of identifier.
.a0a4					_PLTGetIdentifier:
.a0a4	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out.
.a0a7	e8		inx				inx
.a0a8	b1 00		lda ($00),y			lda 	(scanPtr),y	 				; get next character
.a0aa	c8		iny				iny
.a0ab	20 6e a1	jsr $a16e			jsr 	PLTCheckCharacter 			; still identifier
.a0ae	b0 f4		bcs $a0a4			bcs 	_PLTGetIdentifier
.a0b0	88		dey				dey 								; undo last bump.
.a0b1					_PLTGotIdentifier:
.a0b1	bd 3f 06	lda $063f,x			lda 	lineBuffer-1,x 				; set bit 7 of last
.a0b4	09 80		ora #$80			ora 	#$80
.a0b6	9d 3f 06	sta $063f,x			sta 	lineBuffer-1,x
.a0b9	5a		phy				phy
.a0ba	da		phx				phx
.a0bb	20 62 a1	jsr $a162			jsr 	PLTGetAddress 				; XY <= address of identifier.
.a0be	20 a7 a3	jsr $a3a7			jsr 	DictionarySearch 			; is it in the dictionaries ?
.a0c1	90 0c		bcc $a0cf			bcc 	_PLTTryConstant
.a0c3	c9 50		cmp #$50			cmp 	#"P" 						; procedure, short or var ?
.a0c5	f0 4b		beq $a112			beq 	_PLTFoundIdentifier
.a0c7	c9 53		cmp #$53			cmp 	#"S"
.a0c9	f0 47		beq $a112			beq 	_PLTFoundIdentifier
.a0cb	c9 49		cmp #$49			cmp 	#"I"
.a0cd	f0 43		beq $a112			beq 	_PLTFoundIdentifier
.a0cf					_PLTTryConstant:
.a0cf	20 62 a1	jsr $a162			jsr 	PLTGetAddress 				; try as a constant
.a0d2	20 e8 a7	jsr $a7e8			jsr 	StringToInt
.a0d5	b0 04		bcs $a0db			bcs 	_PLTAttachIdentifier
.a0d7	fa		plx				plx 								; leave as it is - unknown identifier
.a0d8	7a		ply				ply
.a0d9	80 b1		bra $a08c			bra 	_PLTConvert
.a0db					_PLTAttachIdentifier:
.a0db	86 0a		stx $0a				stx 	zTemp0 						; save XY
.a0dd	84 0b		sty $0b				sty 	zTemp0+1
.a0df	fa		plx				plx 								; restore current position
.a0e0	7a		ply				ply
.a0e1	b1 00		lda ($00),y			lda 	(scanPtr),y 				; next character
.a0e3	c9 2d		cmp #$2d			cmp 	#"-"
.a0e5	d0 04		bne $a0eb			bne 	_PLTNotMinus
.a0e7	20 54 a1	jsr $a154			jsr 	_PLTNegateZTemp0 			; negate zTemp0
.a0ea	c8		iny				iny 								; skip it if '-'
.a0eb					_PLTNotMinus:
.a0eb	5a		phy				phy 								; save current positions
.a0ec	da		phx				phx
.a0ed	a6 0a		ldx $0a				ldx 	zTemp0 						; restore XY number
.a0ef	a4 0b		ldy $0b				ldy 	zTemp0+1
.a0f1	a9 00		lda #$00			lda 	#0
.a0f3	20 92 a1	jsr $a192			jsr 	ProcessRecordData 			; record associated data
.a0f6	a9 62		lda #$62			lda 	#"b"
.a0f8	c0 00		cpy #$00			cpy 	#0
.a0fa	f0 02		beq $a0fe			beq 	_PLTRecord
.a0fc	a9 77		lda #$77			lda 	#"w"
.a0fe					_PLTRecord:
.a0fe	fa		plx				plx 								; restore XY position
.a0ff	7a		ply				ply
.a100	a6 1c		ldx $1c				ldx 	identStart 					; overwrite the position with ident start
.a102	09 80		ora #$80			ora 	#$80 						; bit 7, it's an element in its own right
.a104	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out
.a107	e8		inx				inx 								; bump the position
.a108	80 82		bra $a08c			bra		_PLTConvert 				; do the next one.
.a10a					_PLTExit:
.a10a	9e 40 06	stz $0640,x			stz 	lineBuffer,x 				; make it ASCIIZ
.a10d	e0 40		cpx #$40			cpx		#LINEBUFFSIZE 				; line too long.
.a10f	b0 31		bcs $a142			bcs 	_PLTBuffer
.a111	60		rts				rts
.a112					_PLTFoundIdentifier:
.a112	48		pha				pha 								; save type.
.a113	a6 1d		ldx $1d				ldx 	dirLowByte 					; get the dictionary AXY values
.a115	a4 1e		ldy $1e				ldy 	dirHighByte
.a117	a5 1f		lda $1f				lda 	dirBank
.a119	20 92 a1	jsr $a192			jsr 	ProcessRecordData 			; attached to identstart
.a11c	68		pla				pla 								; get type back, which is I or S or P
.a11d	09 20		ora #$20			ora 	#$20 						; make it lower case.
.a11f	c9 70		cmp #$70			cmp 	#"p"						; P goes untrammelled
.a121	f0 db		beq $a0fe			beq 	_PLTRecord
.a123	c0 00		cpy #$00			cpy 	#0 							; if Y = 0, e.g. zero page, use that.
.a125	f0 d7		beq $a0fe			beq 	_PLTRecord
.a127	49 05		eor #$05			eor 	#"i"^"l" 					; convert it to L
.a129	c9 6c		cmp #$6c			cmp 	#"l"
.a12b	f0 d1		beq $a0fe			beq 	_PLTRecord
.a12d	a9 63		lda #$63			lda 	#"c" 						; otherwise C
.a12f	80 cd		bra $a0fe			bra 	_PLTRecord
.a131					_PLTError:
.a131	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a134	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX ?",$00
>a13c	54 41 58 20 3f 00
.a142					_PLTBuffer:
.a142	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a145	4c 45 41 4e 3a 4c 49 4e				.text 	"LEAN:","LINE SIZE",$00
>a14d	45 20 53 49 5a 45 00
.a154					_PLTNegateZTemp0:
.a154	38		sec				sec 								; negate zTemp0
.a155	a9 00		lda #$00			lda 	#0
.a157	e5 0a		sbc $0a				sbc 	zTemp0
.a159	85 0a		sta $0a				sta 	zTemp0
.a15b	a9 00		lda #$00			lda 	#0
.a15d	e5 0b		sbc $0b				sbc 	zTemp0+1
.a15f	85 0b		sta $0b				sta 	zTemp0+1
.a161	60		rts				rts
.a162					PLTGetAddress:
.a162	18		clc				clc
.a163	a5 1c		lda $1c				lda 	identStart
.a165	69 40		adc #$40			adc 	#lineBuffer & $FF
.a167	aa		tax				tax
.a168	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a16a	90 01		bcc $a16d			bcc 	_PLGANoCarry
.a16c	c8		iny				iny
.a16d					_PLGANoCarry:
.a16d	60		rts				rts
.a16e					PLTCheckCharacter:
.a16e	c9 25		cmp #$25			cmp 	#'%'
.a170	f0 1c		beq $a18e			beq 	_PLCCYes
.a172	c9 5f		cmp #$5f			cmp 	#'_'
.a174	f0 18		beq $a18e			beq 	_PLCCYes
.a176	c9 24		cmp #$24			cmp 	#'$'
.a178	f0 14		beq $a18e			beq 	_PLCCYes
.a17a	c9 2e		cmp #$2e			cmp 	#'.'
.a17c	f0 10		beq $a18e			beq 	_PLCCYes
.a17e	c9 30		cmp #$30			cmp 	#'0'
.a180	90 0e		bcc $a190			bcc 	_PLCCNo
.a182	c9 3a		cmp #$3a			cmp 	#'9'+1
.a184	90 08		bcc $a18e			bcc 	_PLCCYes
.a186	c9 41		cmp #$41			cmp 	#'A'
.a188	90 06		bcc $a190			bcc 	_PLCCNo
.a18a	c9 5b		cmp #$5b			cmp 	#'Z'+1
.a18c	b0 02		bcs $a190			bcs 	_PLCCNo
.a18e					_PLCCYes:
.a18e	38		sec				sec
.a18f	60		rts				rts
.a190					_PLCCNo:
.a190	18		clc				clc
.a191	60		rts				rts
.a192					ProcessRecordData:
.a192	48		pha				pha
.a193	da		phx				phx
.a194	5a		phy				phy
.a195	da		phx				phx
.a196	a6 21		ldx $21				ldx 	valueBufferPos 				; get current position
.a198	9d 83 06	sta $0683,x			sta 	valueBuffer+3,x 			; copy data to it
.a19b	98		tya				tya
.a19c	9d 82 06	sta $0682,x			sta 	valueBuffer+2,x
.a19f	68		pla				pla
.a1a0	9d 81 06	sta $0681,x			sta 	valueBuffer+1,x
.a1a3	a5 1c		lda $1c				lda 	identStart
.a1a5	9d 80 06	sta $0680,x			sta 	valueBuffer+0,x
.a1a8	e8		inx				inx 								; next position
.a1a9	e8		inx				inx
.a1aa	e8		inx				inx
.a1ab	e8		inx				inx
.a1ac	86 21		stx $21				stx 	valueBufferPos 				; save
.a1ae	a9 ff		lda #$ff			lda 	#$FF 						; write end marker.
.a1b0	9d 80 06	sta $0680,x			sta 	valueBuffer,x
.a1b3	e0 80		cpx #$80			cpx 	#VALBUFFSIZE
.a1b5	b0 04		bcs $a1bb			bcs 	_PRDError
.a1b7	7a		ply				ply
.a1b8	fa		plx				plx
.a1b9	68		pla				pla
.a1ba	60		rts				rts
.a1bb					_PRDError:
.a1bb	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a1be	4c 45 41 4e 3a 43 4f 4d				.text 	"LEAN:","COMPLEX ?",$00
>a1c6	50 4c 45 58 20 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/generate.asm

.a1cd					GeneratorSearch:
.a1cd	64 22		stz $22				stz 	genPos 						; reset the generator pointer
.a1cf	64 2c		stz $2c				stz 	matchCount 					; reset the match count.
.a1d1					_GSNextItem:
.a1d1	a6 22		ldx $22				ldx 	genPos 						; check end ?
.a1d3	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a1d6	f0 07		beq $a1df			beq 	_GSExit
.a1d8	20 e0 a1	jsr $a1e0			jsr 	GenerateOne 				; do one match
.a1db	e6 2c		inc $2c				inc 	matchCount 					; bump the count.
.a1dd	80 f2		bra $a1d1			bra 	_GSNextItem
.a1df					_GSExit:
.a1df	60		rts				rts
.a1e0					GenerateOne:
.a1e0	a5 22		lda $22				lda 	genPos 						; point XY to the next thing
.a1e2	18		clc				clc 								; the actual address in the line buffer.
.a1e3	69 40		adc #$40			adc 	#lineBuffer & $FF
.a1e5	aa		tax				tax
.a1e6	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a1e8	90 01		bcc $a1eb			bcc 	_GSNoCarry
.a1ea	c8		iny				iny
.a1eb					_GSNoCarry:
.a1eb	20 a4 a3	jsr $a3a4			jsr 	DictionarySearchSystemOnly 	; dictionary search
.a1ee	b0 10		bcs $a200			bcs 	_GSFound
.a1f0					_GSError:
.a1f0	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a1f3	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX?",$00
>a1fb	54 41 58 3f 00
.a200					_GSFound:
.a200	c9 4d		cmp #$4d			cmp 	#"M"						; check it's a match.
.a202	d0 ec		bne $a1f0			bne 	_GSError
.a204	a4 20		ldy $20				ldy 	dirLength 					; advance to next
.a206	a6 22		ldx $22				ldx 	genPos 						; checking for a-z.
.a208					_GSCheckData:
.a208	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a20b	29 7f		and #$7f			and 	#$7F
.a20d	c9 61		cmp #$61			cmp 	#'a'
.a20f	90 08		bcc $a219			bcc 	_GSNotLC
.a211	c9 7b		cmp #$7b			cmp 	#'z'+1
.a213	b0 04		bcs $a219			bcs 	_GSNotLC
.a215	8a		txa				txa
.a216	20 9c a2	jsr $a29c			jsr 	GenCopyData
.a219					_GSNotLC:
.a219	e8		inx				inx
.a21a	88		dey				dey
.a21b	d0 eb		bne $a208			bne 	_GSCheckData
.a21d	86 22		stx $22				stx 	genPos
.a21f	a5 1d		lda $1d				lda 	dirLowByte					; copy address to genPtr
.a221	85 06		sta $06				sta 	genPtr
.a223	a5 1e		lda $1e				lda 	dirHighByte
.a225	85 07		sta $07				sta 	genPtr+1
.a227	b2 06		lda ($06)			lda 	(genPtr)					; count in A
.a229	f0 25		beq $a250			beq 	_GSNext 					; nothing !
.a22b	aa		tax				tax 								; X is count
.a22c	a0 01		ldy #$01			ldy 	#1
.a22e					_GSGenerate:
.a22e	b1 06		lda ($06),y			lda 	(genPtr),y 					; execute something
.a230	c9 a3		cmp #$a3			cmp 	#CGEN_C_EXEC
.a232	f0 1d		beq $a251			beq 	_GSExecute
.a234	c9 93		cmp #$93			cmp 	#CGEN_C_SETDATA 			; set data ?
.a236	d0 0e		bne $a246			bne 	_GSCopy
.a238	c8		iny				iny									; copy next two bytes out.
.a239	b1 06		lda ($06),y			lda 	(genPtr),y
.a23b	85 23		sta $23				sta 	generateVar
.a23d	c8		iny				iny
.a23e	b1 06		lda ($06),y			lda 	(genPtr),y
.a240	85 24		sta $24				sta 	generateVar+1
.a242	ca		dex				dex
.a243	ca		dex				dex
.a244	80 06		bra $a24c			bra 	_GSContinue
.a246					_GSCopy:
.a246	20 6d a2	jsr $a26d			jsr 	GenConvertByte 				; replace bytes
.a249	20 36 a4	jsr $a436			jsr 	CodeWriteByte				; write out.
.a24c					_GSContinue:
.a24c	c8		iny				iny
.a24d	ca		dex				dex
.a24e	d0 de		bne $a22e			bne 	_GSGenerate
.a250					_GSNext:
.a250	60		rts				rts
.a251					_GSExecute:
.a251	c8		iny				iny 								; grab one.
.a252	ca		dex				dex
.a253	da		phx				phx 								; save XY
.a254	5a		phy				phy
.a255	b1 06		lda ($06),y			lda 	(genPtr),y 					; read the execution ID
.a257	0a		asl a				asl 	a 							; index into table.
.a258	aa		tax				tax
.a259	bd 0e ac	lda $ac0e,x			lda 	ExecutableVectorTable,x 	; read jump vector
.a25c	85 0a		sta $0a				sta 	zTemp0
.a25e	bd 0f ac	lda $ac0f,x			lda 	ExecutableVectorTable+1,x
.a261	85 0b		sta $0b				sta 	zTemp0+1
.a263	20 6a a2	jsr $a26a			jsr 	_GSCallzTemp0 				; call routine
.a266	7a		ply				ply 								; restore XY
.a267	fa		plx				plx
.a268	80 e2		bra $a24c			bra 	_GSContinue
.a26a					_GSCallzTemp0:
.a26a	6c 0a 00	jmp ($000a)			jmp 	(zTemp0)
.a26d					GenConvertByte:
.a26d	c9 63		cmp #$63			cmp 	#CGEN_C_LOW
.a26f	f0 09		beq $a27a			beq 	_GCBLowByte
.a271	c9 83		cmp #$83			cmp 	#CGEN_C_LOWPLUS1
.a273	f0 08		beq $a27d			beq 	_GCBLowBytePlus1
.a275	c9 73		cmp #$73			cmp 	#CGEN_C_HIGH
.a277	f0 0a		beq $a283			beq 	_GCBHighByte
.a279	60		rts				rts
.a27a					_GCBLowByte:
.a27a	a5 25		lda $25				lda 	elementData
.a27c	60		rts				rts
.a27d					_GCBLowBytePlus1:
.a27d	a5 25		lda $25				lda 	elementData
.a27f	1a		inc a				inc 	a
.a280	f0 04		beq $a286			beq 	_GCBSystem
.a282	60		rts				rts
.a283					_GCBHighByte:
.a283	a5 26		lda $26				lda 	elementData+1
.a285	60		rts				rts
.a286					_GCBSystem:
.a286	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a289	4c 45 41 4e 3a 57 4f 52				.text 	"LEAN:","WORD OFF PAGE",$00
>a291	44 20 4f 46 46 20 50 41 47 45 00
.a29c					GenCopyData:
.a29c	48		pha				pha
.a29d	da		phx				phx
.a29e	5a		phy				phy
.a29f	85 0a		sta $0a				sta 	zTemp0
.a2a1	a2 fc		ldx #$fc			ldx 	#256-4
.a2a3					_GCDLoop:
.a2a3	e8		inx				inx 								; next slot
.a2a4	e8		inx				inx
.a2a5	e8		inx				inx
.a2a6	e8		inx				inx
.a2a7	bd 80 06	lda $0680,x			lda 	valueBuffer,x 				; next in value buffer
.a2aa	c9 ff		cmp #$ff			cmp 	#$FF
.a2ac	f0 16		beq $a2c4			beq 	_GCDError 					; system ?
.a2ae	c5 0a		cmp $0a				cmp 	zTemp0 						; match.
.a2b0	d0 f1		bne $a2a3			bne 	_GCDLoop
.a2b2	a0 00		ldy #$00			ldy 	#0 							; copy assoc data back
.a2b4					_GCDCopy:
.a2b4	bd 81 06	lda $0681,x			lda 	valueBuffer+1,x
.a2b7	99 25 00	sta $0025,y			sta 	elementData,y
.a2ba	e8		inx				inx
.a2bb	c8		iny				iny
.a2bc	c0 03		cpy #$03			cpy 	#3
.a2be	d0 f4		bne $a2b4			bne 	_GCDCopy
.a2c0	7a		ply				ply
.a2c1	fa		plx				plx
.a2c2	68		pla				pla
.a2c3	60		rts				rts
.a2c4					_GCDError:
.a2c4	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a2c7	4c 45 41 4e 3a 53 59 53				.text 	"LEAN:","SYS0?",$00
>a2cf	30 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/extract.asm

.a2d2					EGetUnknownIdentifier:
.a2d2	a6 22		ldx $22				ldx 	genPos 						; get next character
.a2d4	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2d7	29 7f		and #$7f			and 	#$7F
.a2d9	20 6e a1	jsr $a16e			jsr 	PLTCheckCharacter 			; is it an identifier ?
.a2dc	90 15		bcc $a2f3			bcc 	_EUIError 					; no
.a2de	da		phx				phx 								; save start position on stack.
.a2df					_EGetFindEnd:
.a2df	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2e2	e8		inx				inx
.a2e3	0a		asl a				asl 	a
.a2e4	90 f9		bcc $a2df			bcc 	_EGetFindEnd
.a2e6	86 22		stx $22				stx 	genPos 						; points to the next thing.
.a2e8	68		pla				pla 								; offset
.a2e9	a0 06		ldy #$06			ldy 	#lineBuffer >> 8 			; make address in YX
.a2eb	18		clc				clc
.a2ec	69 40		adc #$40			adc 	#lineBuffer & $FF
.a2ee	aa		tax				tax
.a2ef	90 01		bcc $a2f2			bcc 	_EGetNoCarry
.a2f1	c8		iny				iny
.a2f2					_EGetNoCarry:
.a2f2	60		rts				rts
.a2f3					_EUIError:
.a2f3	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a2f6	4c 45 41 4e 3a 49 44 45				.text 	"LEAN:","IDENTIFIER ?",$00
>a2fe	4e 54 49 46 49 45 52 20 3f 00
.a308					EGetSyntaxCheck:
.a308	48		pha				pha
.a309	da		phx				phx
.a30a	a6 22		ldx $22				ldx 	genPos 						; position of next
.a30c	5d 40 06	eor $0640,x			eor 	lineBuffer,x 				; bits 0-6 will be zero if match
.a30f	29 7f		and #$7f			and 	#$7F
.a311	d0 05		bne $a318			bne 	_EGSFail 					; different
.a313	e6 22		inc $22				inc 	genPos 						; skip it and exit
.a315	fa		plx				plx
.a316	68		pla				pla
.a317	60		rts				rts
.a318					_EGSFail:
.a318	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a31b	4c 45 41 4e 3a 4d 49 53				.text 	"LEAN:","MISSING ?",$00
>a323	53 49 4e 47 20 3f 00
.a32a					EGLookNext:
.a32a	da		phx				phx
.a32b	a6 22		ldx $22				ldx 	genPos 						; position of next
.a32d	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a330	fa		plx				plx
.a331	60		rts				rts
.a332					EGSkipNext:
.a332	e6 22		inc $22				inc 	genPos
.a334	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/create.asm

.a335					DictionaryCreate:
.a335	86 0a		stx $0a				stx 	zTemp0 						; save identifier position
.a337	84 0b		sty $0b				sty 	zTemp0+1
.a339	a0 01		ldy #$01			ldy 	#1 							; write the type byte out.
.a33b	91 04		sta ($04),y			sta 	(dictPtr),y
.a33d	a0 00		ldy #$00			ldy 	#0 							; work out length.
.a33f					_DCGetLength:
.a33f	b1 0a		lda ($0a),y			lda 	(zTemp0),y
.a341	c8		iny				iny
.a342	0a		asl a				asl 	a
.a343	90 fa		bcc $a33f			bcc 	_DCGetLength
.a345	5a		phy				phy 								; save Y on stack.
.a346	98		tya				tya 								; save length +6 as offset
.a347	18		clc				clc
.a348	69 06		adc #$06			adc 	#6
.a34a	92 04		sta ($04)			sta 	(dictPtr)
.a34c	a0 02		ldy #$02			ldy 	#2 							; fill 2 to 4 with $FF
.a34e	a9 ff		lda #$ff	_DCFill:lda 	#$FF
.a350	91 04		sta ($04),y			sta 	(dictPtr),y
.a352	c8		iny				iny
.a353	c0 05		cpy #$05			cpy 	#5
.a355	d0 f7		bne $a34e			bne 	_DCFill
.a357	68		pla				pla 								; get length, store in X
.a358	aa		tax				tax
.a359	91 04		sta ($04),y			sta 	(dictPtr),y 				; write length out.
.a35b	a0 00		ldy #$00			ldy 	#0
.a35d					_DCCopy:
.a35d	b1 0a		lda ($0a),y			lda 	(zTemp0),y 					; next identifier character
.a35f	c8		iny				iny 								; save +1 on stack
.a360	5a		phy				phy
.a361	c8		iny				iny 								; advance by 6 total
.a362	c8		iny				iny
.a363	c8		iny				iny
.a364	c8		iny				iny
.a365	c8		iny				iny
.a366	91 04		sta ($04),y			sta 	(dictPtr),y 				; write out
.a368	7a		ply				ply 								; restore +1
.a369	ca		dex				dex
.a36a	d0 f1		bne $a35d			bne 	_DCCopy 					; do that the required# times.
.a36c	a5 04		lda $04				lda 	dictPtr 					; copy last created
.a36e	85 12		sta $12				sta 	lastCreate
.a370	a5 05		lda $05				lda 	dictPtr+1
.a372	85 13		sta $13				sta 	lastCreate+1
.a374	18		clc				clc 								; advance dictionary pointer
.a375	b2 04		lda ($04)			lda 	(dictPtr)
.a377	65 04		adc $04				adc 	dictPtr
.a379	85 04		sta $04				sta 	dictPtr
.a37b	90 02		bcc $a37f			bcc 	_DCNoCarry
.a37d	e6 05		inc $05				inc 	dictPtr+1
.a37f					_DCNoCarry:
.a37f	a9 00		lda #$00			lda 	#$00 						; write end of dictionary marker
.a381	92 04		sta ($04)			sta 	(dictPtr)
.a383	60		rts				rts
.a384					DictionarySet:
.a384	48		pha				pha
.a385	da		phx				phx
.a386	5a		phy				phy
.a387	5a		phy				phy 								; copy data out to
.a388	a0 04		ldy #$04			ldy 	#4 							; offset 2,3,4 => A X Y
.a38a	91 12		sta ($12),y			sta 	(lastCreate),y
.a38c	88		dey				dey
.a38d	68		pla				pla
.a38e	91 12		sta ($12),y			sta 	(lastCreate),y
.a390	88		dey				dey
.a391	8a		txa				txa
.a392	91 12		sta ($12),y			sta 	(lastCreate),y
.a394	7a		ply				ply
.a395	fa		plx				plx
.a396	68		pla				pla
.a397	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/search.asm

.a398					DictionaryReset:
.a398	a9 bf		lda #$bf			lda 	#(UserDictionary) & $FF
.a39a	85 04		sta $04				sta 	dictPtr
.a39c	a9 b8		lda #$b8			lda 	#(UserDictionary) >> 8
.a39e	85 05		sta $05				sta 	dictPtr+1
.a3a0	9c bf b8	stz $b8bf			stz 	UserDictionary
.a3a3	60		rts				rts
.a3a4					DictionarySearchSystemOnly:
.a3a4	38		sec				sec
.a3a5	80 01		bra $a3a8			bra 	DictionarySearchContinue
.a3a7					DictionarySearch:
.a3a7	18		clc				clc
.a3a8					DictionarySearchContinue:
.a3a8	da		phx				phx
.a3a9	5a		phy				phy
.a3aa	08		php				php 								; CS if user only
.a3ab	8a		txa				txa 								; subtract 6 so can use offset Y
.a3ac	38		sec				sec
.a3ad	e9 06		sbc #$06			sbc 	#6
.a3af	85 0a		sta $0a				sta 	zTemp0
.a3b1	98		tya				tya
.a3b2	e9 00		sbc #$00			sbc 	#0
.a3b4	85 0b		sta $0b				sta 	zTemp0+1 					; in zTemp0
.a3b6	28		plp				plp
.a3b7	b0 09		bcs $a3c2			bcs 	_DSCOnly
.a3b9	a2 bf		ldx #$bf			ldx 	#UserDictionary & $FF
.a3bb	a0 b8		ldy #$b8			ldy 	#UserDictionary >> 8
.a3bd	20 cc a3	jsr $a3cc			jsr 	DSSearch
.a3c0	b0 07		bcs $a3c9			bcs 	_DSCExit
.a3c2					_DSCOnly:
.a3c2	a2 2a		ldx #$2a			ldx 	#SystemDictionary & $FF
.a3c4	a0 ac		ldy #$ac			ldy 	#SystemDictionary >> 8
.a3c6	20 cc a3	jsr $a3cc			jsr 	DSSearch
.a3c9					_DSCExit:
.a3c9	7a		ply				ply 								; restore YX
.a3ca	fa		plx				plx
.a3cb	60		rts				rts
.a3cc					DSSearch:
.a3cc	86 0c		stx $0c				stx 	zTemp1 						; save dictionary in zTemp1
.a3ce	84 0d		sty $0d				sty 	zTemp1+1
.a3d0					_DSLoop:
.a3d0	b2 0c		lda ($0c)			lda 	(zTemp1) 					; offset 0 ?
.a3d2	f0 36		beq $a40a			beq 	_DSExit
.a3d4	a0 05		ldy #$05			ldy 	#5 							; get length in X
.a3d6	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3d8	aa		tax				tax
.a3d9					_DSCompare:
.a3d9	c8		iny				iny 								; match next ?
.a3da	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3dc	d1 0a		cmp ($0a),y			cmp 	(zTemp0),y
.a3de	d0 1d		bne $a3fd			bne 	_DSNext
.a3e0	ca		dex				dex 								; done all
.a3e1	d0 f6		bne $a3d9			bne 	_DSCompare
.a3e3	a0 05		ldy #$05			ldy 	#5 							; copy bank/address
.a3e5	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3e7	85 20		sta $20				sta 	dirLength
.a3e9	88		dey				dey
.a3ea	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3ec	85 1f		sta $1f				sta 	dirBank
.a3ee	88		dey				dey
.a3ef	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3f1	85 1e		sta $1e				sta 	dirHighByte
.a3f3	88		dey				dey
.a3f4	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3f6	85 1d		sta $1d				sta 	dirLowByte
.a3f8	88		dey				dey
.a3f9	b1 0c		lda ($0c),y			lda 	(zTemp1),y 					; return type
.a3fb	38		sec				sec
.a3fc	60		rts				rts
.a3fd					_DSNext:
.a3fd	18		clc				clc 								; advance to next.
.a3fe	b2 0c		lda ($0c)			lda 	(zTemp1)
.a400	65 0c		adc $0c				adc 	zTemp1
.a402	85 0c		sta $0c				sta 	zTemp1
.a404	90 ca		bcc $a3d0			bcc 	_DSLoop
.a406	e6 0d		inc $0d				inc 	zTemp1+1
.a408	80 c6		bra $a3d0			bra 	_DSLoop
.a40a					_DSExit:
.a40a	18		clc				clc
.a40b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/code.asm

.a40c					CodeReset:
.a40c	a2 00		ldx #$00			ldx 	#CodeMemory & 255
.a40e	a0 bc		ldy #$bc			ldy 	#CodeMemory >> 8
.a410	a9 00		lda #$00			lda 	#0
.a412	80 00		bra $a414			bra 	CodeSetPointer
.a414					CodeSetPointer:
.a414	48		pha				pha 								; copy old to backup
.a415	a5 14		lda $14				lda 	codePtr
.a417	85 28		sta $28				sta 	codeBackup
.a419	a5 15		lda $15				lda 	codePtr+1
.a41b	85 29		sta $29				sta 	codeBackup+1
.a41d	a5 16		lda $16				lda 	codeBank
.a41f	85 2a		sta $2a				sta 	codeBackup+2
.a421	68		pla				pla
.a422	85 16		sta $16				sta 	codeBank 					; update
.a424	86 14		stx $14				stx 	codePtr
.a426	84 15		sty $15				sty 	codePtr+1
.a428	60		rts				rts
.a429					CodeRestorePointer:
.a429	a5 28		lda $28				lda 	codeBackup
.a42b	85 14		sta $14				sta 	codePtr
.a42d	a5 29		lda $29				lda 	codeBackup+1
.a42f	85 15		sta $15				sta 	codePtr+1
.a431	a5 2a		lda $2a				lda 	codeBackup+2
.a433	85 16		sta $16				sta 	codeBank
.a435	60		rts				rts
.a436					CodeWriteByte:
.a436	92 14		sta ($14)			sta 	(codePtr)
.a438	e6 14		inc $14				inc 	codePtr
.a43a	d0 02		bne $a43e			bne 	_CWBNoCarry
.a43c	e6 15		inc $15				inc 	codePtr+1
.a43e					_CWBNoCarry:
.a43e	60		rts				rts
.a43f					CodeWriteBranch:
.a43f	18		clc				clc 								; borrow 1 as branch is from one on
.a440	8a		txa				txa
.a441	e5 14		sbc $14				sbc 	codePtr
.a443	20 36 a4	jsr $a436			jsr 	CodeWriteByte 				; compile anyway.
.a446	aa		tax				tax 								; actual result in X.
.a447	98		tya				tya
.a448	e5 15		sbc $15				sbc 	codePtr+1
.a44a	f0 14		beq $a460			beq 	_CWBCheckPositive 			; 00xx
.a44c	c9 ff		cmp #$ff			cmp 	#$FF
.a44e	f0 14		beq $a464			beq 	_CWBCheckNegative 			; FFxx
.a450					_CWBError:
.a450	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a453	4c 45 41 4e 3a 42 52 41				.text 	"LEAN:","BRANCH?",$00
>a45b	4e 43 48 3f 00
.a460					_CWBCheckPositive:
.a460	8a		txa				txa
.a461	30 ed		bmi $a450			bmi 	_CWBError
.a463	60		rts				rts
.a464					_CWBCheckNegative:
.a464	8a		txa				txa
.a465	10 e9		bpl $a450			bpl 	_CWBError
.a467	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/error.asm

.a468					SyntaxError:
.a468	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a46b	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX",$00
>a473	54 41 58 00
.a477					ErrorHandler:
.a477	fa		plx				plx 								; pull address off.
.a478	7a		ply				ply
.a479	e8		inx				inx 								; point to message
.a47a	d0 01		bne $a47d			bne 	_EHNoCarry
.a47c	c8		iny				iny
.a47d					_EHNoCarry:
.a47d	20 d6 a4	jsr $a4d6			jsr 	PrintStringXY 				; print string at XY
.a480	a2 b6		ldx #$b6			ldx 	#_EHMessage & $FF 			; print " AT "
.a482	a0 a4		ldy #$a4			ldy 	#_EHMessage >> 8
.a484	20 d6 a4	jsr $a4d6			jsr 	PrintStringXY
.a487	a6 1a		ldx $1a				ldx 	lineNumber 					; convert line number
.a489	a4 1b		ldy $1b				ldy 	lineNumber+1
.a48b	20 9d a7	jsr $a79d			jsr 	IntToString
.a48e	a2 40		ldx #$40			ldx 	#lineBuffer & $FF 			; print number
.a490	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a492	20 d6 a4	jsr $a4d6			jsr 	PrintStringXY
.a495	a9 3a		lda #$3a			lda 	#":"						; print match count
.a497	20 e7 a4	jsr $a4e7			jsr 	PrintCharacter
.a49a	a6 2c		ldx $2c				ldx 	matchCount
.a49c	a0 00		ldy #$00			ldy 	#0
.a49e	20 9d a7	jsr $a79d			jsr 	IntToString
.a4a1	a2 40		ldx #$40			ldx 	#lineBuffer & $FF 			; print number
.a4a3	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a4a5	20 d6 a4	jsr $a4d6			jsr 	PrintStringXY
.a4a8	64 18		stz $18				stz 	lastDefine 					; disable running by zeroing last defined
.a4aa	64 19		stz $19				stz 	lastDefine+1
.a4ac	a2 bb		ldx #$bb			ldx 	#_EHMessage2 & $FF 			; print LEAN info
.a4ae	a0 a4		ldy #$a4			ldy 	#_EHMessage2 >> 8
.a4b0	20 d6 a4	jsr $a4d6			jsr 	PrintStringXY
.a4b3	4c 2a a0	jmp $a02a			jmp 	ReturnCaller 				; exit the compiler.
.a4b6					_EHMessage:
>a4b6	20 41 54 20 00					.text	" AT ",0
.a4bb					_EHMessage2:
>a4bb	0d 20 20 20 20 4c 45 41				.text 	13,"    LEAN V0.2 (01-NOV-19)",0
>a4c3	4e 20 56 30 2e 32 20 28 30 31 2d 4e 4f 56 2d 31
>a4d3	39 29 00
.a4d6					PrintStringXY:
.a4d6	86 0a		stx $0a				stx 	zTemp0
.a4d8	84 0b		sty $0b				sty 	zTemp0+1
.a4da	a0 00		ldy #$00			ldy 	#0
.a4dc	b1 0a		lda ($0a),y	_PSLoop:lda 	(zTemp0),y
.a4de	f0 06		beq $a4e6			beq 	_PSExit
.a4e0	20 e7 a4	jsr $a4e7			jsr 	PrintCharacter
.a4e3	c8		iny				iny
.a4e4	80 f6		bra $a4dc			bra 	_PSLoop
.a4e6	60		rts		_PSExit:rts
.a4e7					PrintCharacter:
.a4e7	48		pha				pha
.a4e8	da		phx				phx
.a4e9	5a		phy				phy
.a4ea	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a4ed	7a		ply				ply
.a4ee	fa		plx				plx
.a4ef	68		pla				pla
.a4f0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/procedure.asm

.a4f1					Action_Procedure_Def:
.a4f1	20 d2 a2	jsr $a2d2			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a4f4	a9 50		lda #$50			lda 	#"P"
.a4f6	20 35 a3	jsr $a335			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a4f9	a5 16		lda $16				lda 	codeBank 					; and assign it the current PC value.
.a4fb	a6 14		ldx $14				ldx 	codePtr
.a4fd	a4 15		ldy $15				ldy 	codePtr+1
.a4ff	86 18		stx $18				stx 	lastDefine 					; update last defined
.a501	84 19		sty $19				sty 	lastDefine+1
.a503	20 84 a3	jsr $a384			jsr 	DictionarySet 				; set the dictionary values.
.a506	a9 28		lda #$28			lda 	#"("
.a508	20 08 a3	jsr $a308			jsr 	EGetSyntaxCheck
.a50b	a9 29		lda #$29			lda 	#")"
.a50d	20 08 a3	jsr $a308			jsr 	EGetSyntaxCheck
.a510	a9 50		lda #$50			lda 	#SCM_PROC 					; put a procedure marker on the stack.
.a512	20 95 a8	jsr $a895			jsr 	StackPush
.a515	60		rts				rts
.a516					_APError:
.a516	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a519	4c 45 41 4e 3a 50 52 4f				.text 	"LEAN:","PROCDEF",$00
>a521	43 44 45 46 00
.a526					Action_EndProc:
.a526	a9 50		lda #$50			lda 	#SCM_PROC 					; check corresponding PROC
.a528	20 b1 a8	jsr $a8b1			jsr 	StackCheckStructureMarker
.a52b	a9 60		lda #$60			lda 	#CPU_RETURN					; write out RTS
.a52d	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a530	a9 01		lda #$01			lda 	#1 							; remove from stack.
.a532	20 de a8	jsr $a8de			jsr 	StackPopStack
.a535	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/call.asm

.a536					Action_Call:
.a536	a5 22		lda $22				lda 	genPos 						; get position
.a538	3a		dec a				dec 	a 							; point to the <proc>
.a539	48		pha				pha 								; save it
.a53a	a9 28		lda #$28			lda 	#'('						; check (
.a53c	20 08 a3	jsr $a308			jsr 	EGetSyntaxCheck
.a53f	20 2a a3	jsr $a32a			jsr 	EGLookNext 					; ) next ?
.a542	c9 a9		cmp #$a9			cmp 	#')'+$80
.a544	f0 1a		beq $a560			beq 	_ACNoParameters
.a546	a9 52		lda #$52			lda 	#"R" 	 					; do R=<something>
.a548	20 79 a5	jsr $a579			jsr 	ACDoParameter 				; do the parameter.
.a54b	20 32 a3	jsr $a332			jsr 	EGSkipNext 					; skip the parameter
.a54e	20 2a a3	jsr $a32a			jsr 	EGLookNext 					; what follows
.a551	c9 ac		cmp #$ac			cmp 	#","+$80 					; if not comma
.a553	d0 0b		bne $a560			bne 	_ACNoParameters 			; should be end of parameters
.a555	20 32 a3	jsr $a332			jsr 	EGSkipNext 					; skip ,
.a558	a9 59		lda #$59			lda 	#"Y"						; do Y=<something>
.a55a	20 79 a5	jsr $a579			jsr 	ACDoParameter 				; do the parameter.
.a55d	20 32 a3	jsr $a332			jsr 	EGSkipNext 					; skip parameter.
.a560					_ACNoParameters:
.a560	a9 29		lda #$29			lda 	#')' 						; check closing bracket.
.a562	20 08 a3	jsr $a308			jsr 	EGetSyntaxCheck
.a565	68		pla				pla 								; restore procedure posiion.
.a566	20 9c a2	jsr $a29c			jsr 	GenCopyData					; get the data
.a569	a9 20		lda #$20			lda 	#CPU_JSR					; output a call to it.
.a56b	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a56e	a5 25		lda $25				lda 	elementData
.a570	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a573	a5 26		lda $26				lda 	elementData+1
.a575	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a578	60		rts				rts
.a579					ACDoParameter:
.a579	a6 22		ldx $22				ldx 	genPos 						; save position
.a57b	da		phx				phx
.a57c	48		pha				pha 								; save the target register
.a57d	bd 40 06	lda $0640,x			lda 	lineBuffer,x 				; what is there ?
.a580	c9 e1		cmp #$e1			cmp 	#"a"+$80 					; check a-z
.a582	90 1a		bcc $a59e			bcc 	_ADPError
.a584	c9 fb		cmp #$fb			cmp 	#"z"+$81
.a586	b0 16		bcs $a59e			bcs 	_ADPError
.a588	ca		dex				dex 								; write = before it
.a589	a9 bd		lda #$bd			lda 	#"="+$80
.a58b	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a58e	ca		dex				dex
.a58f	68		pla				pla 								; write Y/R before that
.a590	09 80		ora #$80			ora 	#$80
.a592	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a595	86 22		stx $22				stx 	genPos 						; make genPos point to that.
.a597	20 e0 a1	jsr $a1e0			jsr 	GenerateOne 				; generate that.
.a59a	68		pla				pla 								; restore position
.a59b	85 22		sta $22				sta 	genPos
.a59d	60		rts				rts
.a59e					_ADPError:
.a59e	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a5a1	4c 45 41 4e 3a 50 41 52				.text 	"LEAN:","PARAMETER?",$00
>a5a9	41 4d 45 54 45 52 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/if.asm

.a5b1					Action_If:
.a5b1	a5 23		lda $23				lda 	generateVar 				; branch to use.
.a5b3	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a5b5	20 36 a4	jsr $a436			jsr 	CodeWriteByte 				; output it
.a5b8	20 85 a8	jsr $a885			jsr 	StackPushPC 				; push branch position on stack
.a5bb	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a5bd	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a5c0	a9 49		lda #$49			lda 	#SCM_IF 					; put if marker on the stack.
.a5c2	20 95 a8	jsr $a895			jsr 	StackPush
.a5c5	60		rts				rts
.a5c6					Action_Else:
.a5c6	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a5c8	20 b1 a8	jsr $a8b1			jsr 	StackCheckStructureMarker
.a5cb	a9 80		lda #$80			lda 	#CPU_BRA 					; compile branch
.a5cd	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a5d0	a5 14		lda $14				lda 	codePtr 					; push current position on the stack
.a5d2	48		pha				pha
.a5d3	a5 15		lda $15				lda 	codePtr+1
.a5d5	48		pha				pha
.a5d6	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a5d8	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a5db	20 f6 a5	jsr $a5f6			jsr 	BackPatchIf 				; do the backpatch.
.a5de	68		pla				pla 								; overwrite backpatch address
.a5df	a0 01		ldy #$01			ldy 	#1 							; with stacked position.
.a5e1	91 02		sta ($02),y			sta 	(aStackPtr),y
.a5e3	68		pla				pla
.a5e4	c8		iny				iny
.a5e5	91 02		sta ($02),y			sta 	(aStackPtr),y
.a5e7	60		rts				rts
.a5e8					Action_Endif:
.a5e8	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a5ea	20 b1 a8	jsr $a8b1			jsr 	StackCheckStructureMarker
.a5ed	20 f6 a5	jsr $a5f6			jsr 	BackPatchIf 				; do the backpatch.
.a5f0	a9 04		lda #$04			lda 	#3+1 						; throw the stack.
.a5f2	20 de a8	jsr $a8de			jsr 	StackPopStack
.a5f5	60		rts				rts
.a5f6					BackPatchIf:
.a5f6	a5 14		lda $14					lda 	codePtr 					; save code pointer
.a5f8	48		pha				pha
.a5f9	a5 15		lda $15				lda 	codePtr+1
.a5fb	48		pha				pha
.a5fc	a0 03		ldy #$03			ldy 	#3 							; AYX = address.
.a5fe	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a600	48		pha				pha
.a601	88		dey				dey
.a602	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a604	aa		tax				tax
.a605	88		dey				dey
.a606	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a608	a8		tay				tay
.a609	68		pla				pla
.a60a	20 14 a4	jsr $a414			jsr 	CodeSetPointer 				; set write position to that
.a60d	7a		ply				ply 								; target address in YX
.a60e	fa		plx				plx
.a60f	20 3f a4	jsr $a43f			jsr 	CodeWriteBranch 			; write the actual branch there
.a612	20 29 a4	jsr $a429			jsr 	CodeRestorePointer 			; undo the set pointer.
.a615	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/repeat.asm

.a616					Action_Repeat:
.a616	20 85 a8	jsr $a885			jsr 	StackPushPC 					; push loop position on stack
.a619	a9 52		lda #$52			lda 	#SCM_REPEAT 					; put a repeat marker on the stack.
.a61b	20 95 a8	jsr $a895			jsr 	StackPush
.a61e	60		rts				rts
.a61f					Action_Until:
.a61f	a9 52		lda #$52			lda 	#SCM_REPEAT 				; check corresponding repeat
.a621	20 b1 a8	jsr $a8b1			jsr 	StackCheckStructureMarker
.a624	a5 23		lda $23				lda 	generateVar 				; branch to use.
.a626	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a628	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a62a	20 c9 a8	jsr $a8c9			jsr 	StackCompileBranch 			; compile a branch.
.a62d	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a62f	20 de a8	jsr $a8de			jsr 	StackPopStack
.a632	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/for.asm

.a633					Action_AFor:
.a633	20 85 a8	jsr $a885			jsr 	StackPushPC 					; push loop position on stack
.a636	a9 3a		lda #$3a			lda 	#CPU_DECA 						; counts backwards from n-1 to 0.
.a638	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a63b	a9 48		lda #$48			lda 	#CPU_PHA 						; push index on stack
.a63d	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a640	a9 46		lda #$46			lda 	#SCM_FOR 						; put a for marker on the stack.
.a642	20 95 a8	jsr $a895			jsr 	StackPush
.a645	60		rts				rts
.a646					Action_RFor:
.a646	20 85 a8	jsr $a885			jsr 	StackPushPC 					; push loop position on stack
.a649	a9 c9		lda #$c9			lda 	#CPU_CMPIM 						; dec XA code cmp #0
.a64b	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a64e	a9 00		lda #$00			lda 	#0
.a650	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a653	a9 d0		lda #$d0			lda 	#CPU_BNE 						; bne +1
.a655	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a658	a9 01		lda #$01			lda 	#1
.a65a	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a65d	a9 ca		lda #$ca			lda 	#CPU_DEX 						; dex
.a65f	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a662	a9 3a		lda #$3a			lda 	#CPU_DECA 						; dec a
.a664	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a667	a9 48		lda #$48			lda 	#CPU_PHA 						; push index on stack
.a669	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a66c	a9 da		lda #$da			lda 	#CPU_PHX
.a66e	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a671	a9 47		lda #$47			lda 	#SCM_INTFOR 					; put a for marker on the stack.
.a673	20 95 a8	jsr $a895			jsr 	StackPush
.a676	60		rts				rts
.a677					Action_Next:
.a677	b2 02		lda ($02)			lda 	(aStackPtr) 				; check for R-Next
.a679	c9 47		cmp #$47			cmp 	#SCM_INTFOR
.a67b	f0 17		beq $a694			beq 	_AN16Bit
.a67d	a9 46		lda #$46			lda 	#SCM_FOR 					; check corresponding for
.a67f	20 b1 a8	jsr $a8b1			jsr 	StackCheckStructureMarker
.a682	a9 68		lda #$68			lda 	#CPU_PLA 					; pop index off stack.
.a684	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a687	a9 d0		lda #$d0			lda 	#CPU_BNE 					; branch back if #0
.a689	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a68b	20 c9 a8	jsr $a8c9			jsr 	StackCompileBranch 			; compile a branch.
.a68e	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a690	20 de a8	jsr $a8de			jsr 	StackPopStack
.a693	60		rts				rts
.a694					_AN16Bit:
.a694	a9 fa		lda #$fa			lda 	#CPU_PLX 					; pop index on stack
.a696	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a699	a9 68		lda #$68			lda 	#CPU_PLA
.a69b	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a69e	a9 d0		lda #$d0			lda 	#CPU_BNE
.a6a0	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a6a2	20 c9 a8	jsr $a8c9			jsr 	StackCompileBranch 			; compile a branch (check LSB)
.a6a5	a9 e0		lda #$e0			lda 	#CPU_CPXIM  				; check MSB of index
.a6a7	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a6aa	a9 00		lda #$00			lda 	#0
.a6ac	20 36 a4	jsr $a436			jsr 	CodeWriteByte
.a6af	a9 d0		lda #$d0			lda 	#CPU_BNE
.a6b1	a0 01		ldy #$01			ldy 	#1
.a6b3	20 c9 a8	jsr $a8c9			jsr 	StackCompileBranch
.a6b6	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a6b8	20 de a8	jsr $a8de			jsr 	StackPopStack
.a6bb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/variables.asm

.a6bc					VariableReset:
.a6bc	a9 00		lda #$00			lda 	#(VariableMemory) & $FF
.a6be	85 08		sta $08				sta 	varPtr
.a6c0	a9 07		lda #$07			lda 	#(VariableMemory) >> 8
.a6c2	85 09		sta $09				sta 	varPtr+1
.a6c4	60		rts				rts
.a6c5					Action_ByteVar:
.a6c5	a9 01		lda #$01			lda 	#1
.a6c7	80 02		bra $a6cb			bra 	VariableDeclare
.a6c9					Action_WordVar:
.a6c9	a9 02		lda #$02			lda 	#2
.a6cb					VariableDeclare:
.a6cb	85 2b		sta $2b				sta 	varSize 					; save variable size.
.a6cd					_VDLoop:
.a6cd	a9 53		lda #$53			lda 	#"S"						; get I or S
.a6cf	a6 2b		ldx $2b				ldx 	varSize
.a6d1	ca		dex				dex
.a6d2	f0 02		beq $a6d6			beq 	_VDNotWord
.a6d4	a9 49		lda #$49			lda 	#"I"
.a6d6					_VDNotWord:
.a6d6	48		pha				pha
.a6d7	20 d2 a2	jsr $a2d2			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a6da	68		pla				pla
.a6db	20 35 a3	jsr $a335			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a6de	20 2a a3	jsr $a32a			jsr 	EGLookNext 					; what's next ?
.a6e1	c9 c0		cmp #$c0			cmp 	#'@'|$80 					; if not @, use default
.a6e3	d0 21		bne $a706			bne 	_VDDefault
.a6e5	20 32 a3	jsr $a332			jsr 	EGSkipNext 					; skip @
.a6e8	20 2a a3	jsr $a32a			jsr 	EGLookNext 					; get next
.a6eb	c9 e2		cmp #$e2			cmp 	#'b'|$80 					; must be b/w constant
.a6ed	f0 04		beq $a6f3			beq 	_VDLegit
.a6ef	c9 f7		cmp #$f7			cmp 	#'w'|$80
.a6f1	d0 34		bne $a727			bne 	_VDError
.a6f3					_VDLegit:
.a6f3	a5 22		lda $22				lda 	genPos 						; position
.a6f5	20 9c a2	jsr $a29c			jsr 	GenCopyData					; access data
.a6f8	a9 00		lda #$00			lda 	#0 		 					; set the address
.a6fa	a6 25		ldx $25				ldx 	elementData
.a6fc	a4 26		ldy $26				ldy 	elementData+1
.a6fe	20 84 a3	jsr $a384			jsr 	DictionarySet
.a701	20 32 a3	jsr $a332			jsr 	EGSkipNext 					; consume the constant
.a704	80 14		bra $a71a			bra 	_VDTryNext
.a706					_VDDefault:
.a706	a6 08		ldx $08				ldx 	varPtr 						; place at default position
.a708	a4 09		ldy $09				ldy 	varPtr+1
.a70a	a9 00		lda #$00			lda 	#0
.a70c	20 84 a3	jsr $a384			jsr 	DictionarySet
.a70f	a5 2b		lda $2b				lda 	varSize 					; get count of bytes back
.a711	18		clc				clc
.a712	65 08		adc $08				adc 	varPtr
.a714	85 08		sta $08				sta 	varPtr
.a716	90 02		bcc $a71a			bcc 	_VDNoCarry
.a718	e6 09		inc $09				inc 	varPtr+1
.a71a					_VDNoCarry:
.a71a					_VDTryNext:
.a71a	20 2a a3	jsr $a32a			jsr 	EGLookNext 					; what's next ?
.a71d	c9 ac		cmp #$ac			cmp 	#","|$80 					; is it a comma
.a71f	d0 05		bne $a726			bne 	_VDExit 					; no, exit.
.a721	20 32 a3	jsr $a332			jsr 	EGSkipNext
.a724	80 a7		bra $a6cd			bra 	_VDLoop
.a726					_VDExit:
.a726	60		rts				rts
.a727					_VDError:
.a727	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a72a	4c 45 41 4e 3a 41 44 44				.text 	"LEAN:","ADDRESS?",$00
>a732	52 45 53 53 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/crunch.asm

.a738					Action_DictionaryCrunch:
.a738	a9 bf		lda #$bf			lda 	#(UserDictionary) & $FF
.a73a	85 0a		sta $0a				sta 	zTemp0
.a73c	a9 b8		lda #$b8			lda 	#(UserDictionary) >> 8
.a73e	85 0b		sta $0b				sta 	zTemp0+1
.a740					_ADCLoop:
.a740	b2 0a		lda ($0a)			lda 	(zTemp0) 					; reached end of dictionary
.a742	f0 58		beq $a79c			beq 	_ADCExit
.a744	a0 06		ldy #$06			ldy 	#6							; read first character
.a746	b1 0a		lda ($0a),y			lda 	(zTemp0),y
.a748	29 7f		and #$7f			and 	#$7F 						; is it a '.' ?
.a74a	c9 2e		cmp #$2e			cmp 	#'.'
.a74c	d0 41		bne $a78f			bne 	_ADCNext 					; if not, it's a global, skip to next.
.a74e	a5 0a		lda $0a				lda 	zTemp0 						; work out copy from, into zTemp1
.a750	48		pha				pha
.a751	18		clc				clc
.a752	72 0a		adc ($0a)			adc 	(zTemp0)
.a754	85 0c		sta $0c				sta 	zTemp1
.a756	a5 0b		lda $0b				lda 	zTemp0+1
.a758	48		pha				pha
.a759	69 00		adc #$00			adc 	#0
.a75b	85 0d		sta $0d				sta 	zTemp1+1
.a75d					_ADCopyOverwrite:
.a75d	b2 0c		lda ($0c)			lda 	(zTemp1) 					; byte copy
.a75f	92 0a		sta ($0a)			sta 	(zTemp0)
.a761	a5 0c		lda $0c				lda 	zTemp1 						; until the upper address = dictionary top
.a763	c5 04		cmp $04				cmp 	dictPtr
.a765	d0 06		bne $a76d			bne 	_ADCNextCopy
.a767	a5 0d		lda $0d				lda 	zTemp1+1
.a769	c5 05		cmp $05				cmp 	dictPtr+1
.a76b	f0 0e		beq $a77b			beq 	_ADCRemoved
.a76d					_ADCNextCopy:
.a76d	e6 0a		inc $0a				inc 	zTemp0
.a76f	d0 02		bne $a773			bne 	_NoCarry
.a771	e6 0b		inc $0b				inc 	zTemp0+1
.a773					_NoCarry:
.a773	e6 0c		inc $0c				inc 	zTemp1
.a775	d0 02		bne $a779			bne 	_NoCarry
.a777	e6 0d		inc $0d				inc 	zTemp1+1
.a779					_NoCarry:
.a779	80 e2		bra $a75d			bra 	_ADCopyOverwrite
.a77b					_ADCRemoved:
.a77b	a5 0a		lda $0a				lda 	zTemp0 						; copy from position is new top.
.a77d	85 04		sta $04				sta 	dictPtr
.a77f	a5 0b		lda $0b				lda 	zTemp0+1
.a781	85 05		sta $05				sta 	dictPtr+1
.a783	a9 00		lda #$00			lda 	#0							; mark end as not copied in loop
.a785	92 04		sta ($04)			sta 	(dictPtr)
.a787	68		pla				pla 								; restore original position.
.a788	85 0b		sta $0b				sta 	zTemp0+1
.a78a	68		pla				pla
.a78b	85 0a		sta $0a				sta 	zTemp0
.a78d	80 b1		bra $a740			bra 	_ADCLoop 					; and continue from same position.
.a78f					_ADCNext:
.a78f	18		clc				clc 								; advance to next.
.a790	a5 0a		lda $0a				lda 	zTemp0
.a792	72 0a		adc ($0a)			adc 	(zTemp0)
.a794	85 0a		sta $0a				sta 	zTemp0
.a796	90 a8		bcc $a740			bcc 	_ADCLoop
.a798	e6 0b		inc $0b				inc 	zTemp0+1
.a79a	80 a4		bra $a740			bra 	_ADCLoop
.a79c					_ADCExit:
.a79c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/tostring.asm

.a79d					IntToString:
.a79d	86 0a		stx $0a				stx 	zTemp0 						; count is in zTemp0
.a79f	84 0b		sty $0b				sty 	zTemp0+1
.a7a1	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a7a3	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a7a5					_ITSLoop:
.a7a5	64 0c		stz $0c				stz 	zTemp1 						; this is the count of subtracts.
.a7a7					_ITSSubtractLoop:
.a7a7	38		sec				sec
.a7a8	a5 0a		lda $0a				lda 	zTemp0 						; try to calculate
.a7aa	fd e0 a7	sbc $a7e0,x			sbc 	_ITSWords,x
.a7ad	48		pha				pha
.a7ae	a5 0b		lda $0b				lda 	zTemp0+1
.a7b0	fd e1 a7	sbc $a7e1,x			sbc 	_ITSWords+1,x
.a7b3	90 09		bcc $a7be			bcc 	_ITSEndSub 					; can't subtract any more.
.a7b5	85 0b		sta $0b				sta 	zTemp0+1 					; update zTemp
.a7b7	68		pla				pla
.a7b8	85 0a		sta $0a				sta 	zTemp0
.a7ba	e6 0c		inc $0c				inc 	zTemp1 						; bump subtract count.
.a7bc	80 e9		bra $a7a7			bra 	_ITSSubtractLoop
.a7be					_ITSEndSub:
.a7be	68		pla				pla 								; throw away the interim result
.a7bf	a5 0c		lda $0c				lda 	zTemp1 						; if the subtract count is non zero
.a7c1	d0 04		bne $a7c7			bne 	_ITSWriteOut 				; always write it out
.a7c3	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a7c5	f0 06		beq $a7cd			beq 	_ITSNext 					; suppressing leading zeros.
.a7c7					_ITSWriteOut:
.a7c7	09 30		ora #$30			ora 	#48 						; output digit.
.a7c9	99 40 06	sta $0640,y			sta 	lineBuffer,y
.a7cc	c8		iny				iny
.a7cd					_ITSNext:
.a7cd	e8		inx				inx
.a7ce	e8		inx				inx
.a7cf	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a7d1	d0 d2		bne $a7a5			bne 	_ITSLoop 					; do the new digits
.a7d3	a5 0a		lda $0a				lda 	zTemp0 						; output the last digit
.a7d5	09 30		ora #$30			ora 	#48
.a7d7	99 40 06	sta $0640,y			sta 	lineBuffer,y 				; make it ASCIIZ.
.a7da	a9 00		lda #$00			lda 	#0
.a7dc	99 41 06	sta $0641,y			sta 	lineBuffer+1,y
.a7df	60		rts				rts
.a7e0					_ITSWords:
>a7e0	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a7e8					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: utility/tointeger.asm

.a7e8					StringToInt:
.a7e8	86 10		stx $10				stx 	zTemp3 						; save string
.a7ea	84 11		sty $11				sty 	zTemp3+1
.a7ec	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a7ee	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a7f0	b2 10		lda ($10)			lda 	(zTemp3) 					; first character
.a7f2	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a7f4	f0 1b		beq $a811			beq 	_STIConvert 				; convert from character 1, base 16.
.a7f6	88		dey				dey 								; from character 0
.a7f7	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a7f9	c9 2d		cmp #$2d			cmp 	#"-"						; first char is unary minus ?
.a7fb	d0 14		bne $a811			bne 	_STIConvert 				; no, convert as +ve decimal
.a7fd	c8		iny				iny 								; skip the minus
.a7fe	20 11 a8	jsr $a811			jsr 	_STIConvert 				; convert the unsigned part.
.a801	90 0d		bcc $a810			bcc 	_STIExit 					; failed
.a803	8a		txa				txa 								; 1's complement YX
.a804	49 ff		eor #$ff			eor 	#$FF
.a806	aa		tax				tax
.a807	98		tya				tya
.a808	49 ff		eor #$ff			eor 	#$FF
.a80a	a8		tay				tay
.a80b	e8		inx				inx 								; +1 to make it negative
.a80c	38		sec				sec
.a80d	d0 01		bne $a810			bne 	_STIExit
.a80f	c8		iny				iny
.a810					_STIExit:
.a810	60		rts				rts
.a811					_STIConvert:
.a811	86 0c		stx $0c				stx 	zTemp1 						; save base in zTemp1
.a813	b1 10		lda ($10),y			lda 	(zTemp3),y 					; get first character
.a815	f0 5f		beq $a876			beq 	_STIFail 					; if zero, then it has failed anyway.
.a817	64 0a		stz $0a				stz 	zTemp0 						; clear the result.
.a819	64 0b		stz $0b				stz 	zTemp0+1
.a81b					_STILoop:
.a81b	a5 0a		lda $0a				lda 	zTemp0 						; copy current to zTemp2
.a81d	85 0e		sta $0e				sta 	zTemp2
.a81f	a5 0b		lda $0b				lda 	zTemp0+1
.a821	85 0f		sta $0f				sta 	zTemp2+1
.a823	64 0a		stz $0a				stz 	zTemp0 						; clear result
.a825	64 0b		stz $0b				stz 	zTemp0+1
.a827	a6 0c		ldx $0c				ldx 	zTemp1 						; X contains the base.
.a829					_STIMultiply:
.a829	8a		txa				txa 								; shift Y right into carry.
.a82a	4a		lsr a				lsr 	a
.a82b	aa		tax				tax
.a82c	90 0d		bcc $a83b			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a82e	18		clc				clc
.a82f	a5 0e		lda $0e				lda 	zTemp2 						; add zTemp2 into zTemp0
.a831	65 0a		adc $0a				adc 	zTemp0
.a833	85 0a		sta $0a				sta 	zTemp0
.a835	a5 0f		lda $0f				lda 	zTemp2+1
.a837	65 0b		adc $0b				adc 	zTemp0+1
.a839	85 0b		sta $0b				sta 	zTemp0+1
.a83b					_STINoAdd:
.a83b	06 0e		asl $0e				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a83d	26 0f		rol $0f				rol 	zTemp2+1
.a83f	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a841	d0 e6		bne $a829			bne 	_STIMultiply
.a843	b1 10		lda ($10),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a845	29 7f		and #$7f			and 	#$7F 						; remove End of Token bit if set
.a847	c9 30		cmp #$30			cmp 	#"0"
.a849	90 2b		bcc $a876			bcc 	_STIFail
.a84b	c9 3a		cmp #$3a			cmp 	#"9"+1
.a84d	90 0b		bcc $a85a			bcc 	_STIOkay
.a84f	c9 41		cmp #$41			cmp 	#"A"
.a851	90 23		bcc $a876			bcc 	_STIFail
.a853	c9 47		cmp #$47			cmp 	#"F"+1
.a855	b0 1f		bcs $a876			bcs 	_STIFail
.a857	38		sec				sec 								; hex adjust
.a858	e9 07		sbc #$07			sbc 	#7
.a85a					_STIOkay:
.a85a	38		sec				sec
.a85b	e9 30		sbc #$30			sbc 	#48
.a85d	c5 0c		cmp $0c				cmp 	zTemp1  					; if >= base then fail.
.a85f	b0 15		bcs $a876			bcs 	_STIFail
.a861	d8		cld				cld
.a862	65 0a		adc $0a				adc 	zTemp0 						; add into the current value
.a864	85 0a		sta $0a				sta 	zTemp0
.a866	90 02		bcc $a86a			bcc 	_STINoCarry
.a868	e6 0b		inc $0b				inc 	zTemp0+1
.a86a					_STINoCarry:
.a86a	b1 10		lda ($10),y			lda 	(zTemp3),y					; get character just done.
.a86c	c8		iny				iny 								; point to next
.a86d	0a		asl a				asl 	a 							; shift bit 7 into carry
.a86e	90 ab		bcc $a81b			bcc 	_STILoop 					; not reached the end.
.a870	a6 0a		ldx $0a				ldx 	zTemp0 						; return result
.a872	a4 0b		ldy $0b				ldy 	zTemp0+1
.a874	38		sec				sec
.a875	60		rts				rts
.a876					_STIFail:
.a876	18		clc				clc
.a877	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/astack.asm

.a878					StackReset:
.a878	a9 3f		lda #$3f			lda 	#(assemblerStack) & $FF
.a87a	85 02		sta $02				sta 	aStackPtr
.a87c	a9 06		lda #$06			lda 	#(assemblerStack) >> 8
.a87e	85 03		sta $03				sta 	aStackPtr+1
.a880	a9 2a		lda #$2a			lda 	#SCM_TOP
.a882	92 02		sta ($02)			sta 	(aStackPtr)
.a884	60		rts				rts
.a885					StackPushPC:
.a885	a5 16		lda $16				lda 	codeBank
.a887	20 95 a8	jsr $a895			jsr 	StackPush
.a88a	a5 14		lda $14				lda 	codePtr
.a88c	20 95 a8	jsr $a895			jsr 	StackPush
.a88f	a5 15		lda $15				lda 	codePtr+1
.a891	20 95 a8	jsr $a895			jsr 	StackPush
.a894	60		rts				rts
.a895					StackPush:
.a895	c6 02		dec $02				dec 	aStackPtr 					; decrement TOS pointer.
.a897	f0 03		beq $a89c			beq 	_SPStack
.a899	92 02		sta ($02)			sta 	(aStackPtr)					; write to new TOS
.a89b	60		rts				rts
.a89c					_SPStack:
.a89c	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a89f	4c 45 41 4e 3a 52 45 54				.text 	"LEAN:","RETURN STACK",$00
>a8a7	55 52 4e 20 53 54 41 43 4b 00
.a8b1					StackCheckStructureMarker:
.a8b1	d2 02		cmp ($02)			cmp 	(aStackPtr)					; check if tos matches
.a8b3	d0 01		bne $a8b6			bne 	_SCSError
.a8b5	60		rts				rts
.a8b6					_SCSError:
.a8b6	20 77 a4	jsr $a477			jsr 	ErrorHandler
>a8b9	4c 45 41 4e 3a 53 54 52				.text 	"LEAN:","STRUCTURES",$00
>a8c1	55 43 54 55 52 45 53 00
.a8c9					StackCompileBranch:
.a8c9	48		pha				pha
.a8ca	da		phx				phx
.a8cb	5a		phy				phy
.a8cc	20 36 a4	jsr $a436			jsr 	CodeWriteByte 				; write the opcode.
.a8cf	c8		iny				iny
.a8d0	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a8d2	aa		tax				tax
.a8d3	88		dey				dey
.a8d4	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a8d6	a8		tay				tay
.a8d7	20 3f a4	jsr $a43f			jsr 	CodeWriteBranch 			; write a branch there.
.a8da	7a		ply				ply
.a8db	fa		plx				plx
.a8dc	68		pla				pla
.a8dd	60		rts				rts
.a8de					StackPopStack:
.a8de	18		clc				clc 								; return stack all in same page
.a8df	65 02		adc $02				adc 	aStackPtr 					; so we don't carry out.
.a8e1	85 02		sta $02				sta 	aStackPtr
.a8e3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/system.inc

.a8e4					L10000:
>a8e4	04					.byte L10000_END-L10000-1
.a8e5	a9 63		lda #$63		lda  #$63
.a8e7	a2 73		ldx #$73		ldx  #$73
.a8e9					L10000_END:
.a8e9					L10001:
>a8e9	09					.byte L10001_END-L10001-1
.a8ea	91 63		sta ($63),y		sta  ($63),y
.a8ec	c8		iny			iny
.a8ed	8a		txa			txa
.a8ee	91 63		sta ($63),y		sta  ($63),y
.a8f0	88		dey			dey
.a8f1	b1 63		lda ($63),y		lda  ($63),y
.a8f3					L10001_END:
.a8f3					L10002:
>a8f3	02					.byte L10002_END-L10002-1
.a8f4	91 63		sta ($63),y		sta  ($63),y
.a8f6					L10002_END:
.a8f6					L10003:
>a8f6	02					.byte L10003_END-L10003-1
.a8f7	84 63		sty $63			sty  $63
.a8f9					L10003_END:
.a8f9					L10004:
>a8f9	02					.byte L10004_END-L10004-1
.a8fa	85 63		sta $63			sta  $63
.a8fc					L10004_END:
.a8fc					L10005:
>a8fc	02					.byte L10005_END-L10005-1
.a8fd	85 63		sta $63			sta  $63
.a8ff					L10005_END:
.a8ff					L10006:
>a8ff	04					.byte L10006_END-L10006-1
.a900	a5 63		lda $63			lda  $63
.a902	a2 00		ldx #$00		ldx  #0
.a904					L10006_END:
.a904					L10007:
>a904	02					.byte L10007_END-L10007-1
>a905	a3 00					.byte $a3,$00
.a907					L10007_END:
.a907					L10008:
>a907	06					.byte L10008_END-L10008-1
.a908	8d 63 73	sta $7363		sta  $7363
.a90b	8e 83 73	stx $7383		stx  $7383
.a90e					L10008_END:
.a90e					L10009:
>a90e	06					.byte L10009_END-L10009-1
.a90f	ad 63 73	lda $7363		lda  $7363
.a912	ae 83 73	ldx $7383		ldx  $7383
.a915					L10009_END:
.a915					L10010:
>a915	04					.byte L10010_END-L10010-1
.a916	85 63		sta $63			sta  $63
.a918	86 83		stx $83			stx  $83
.a91a					L10010_END:
.a91a					L10011:
>a91a	04					.byte L10011_END-L10011-1
.a91b	a5 63		lda $63			lda  $63
.a91d	a6 83		ldx $83			ldx  $83
.a91f					L10011_END:
.a91f					L10012:
>a91f	03					.byte L10012_END-L10012-1
.a920	8c 63 73	sty $7363		sty  $7363
.a923					L10012_END:
.a923					L10013:
>a923	03					.byte L10013_END-L10013-1
.a924	8d 63 73	sta $7363		sta  $7363
.a927					L10013_END:
.a927					L10014:
>a927	03					.byte L10014_END-L10014-1
.a928	8d 63 73	sta $7363		sta  $7363
.a92b					L10014_END:
.a92b					L10015:
>a92b	05					.byte L10015_END-L10015-1
.a92c	ad 63 73	lda $7363		lda  $7363
.a92f	a2 00		ldx #$00		ldx  #0
.a931					L10015_END:
.a931					L10016:
>a931	04					.byte L10016_END-L10016-1
.a932	a9 63		lda #$63		lda  #$63
.a934	a2 73		ldx #$73		ldx  #$73
.a936					L10016_END:
.a936					L10017:
>a936	07					.byte L10017_END-L10017-1
.a937	8a		txa			txa
.a938	49 ff		eor #$ff		eor  #$ff
.a93a	aa		tax			tax
.a93b	68		pla			pla
.a93c	49 ff		eor #$ff		eor  #$ff
.a93e					L10017_END:
.a93e					L10018:
>a93e	02					.byte L10018_END-L10018-1
.a93f	49 ff		eor #$ff		eor  #$ff
.a941					L10018_END:
.a941					L10019:
>a941	02					.byte L10019_END-L10019-1
.a942	a4 63		ldy $63			ldy  $63
.a944					L10019_END:
.a944					L10020:
>a944	03					.byte L10020_END-L10020-1
.a945	ac 63 73	ldy $7363		ldy  $7363
.a948					L10020_END:
.a948					L10021:
>a948	02					.byte L10021_END-L10021-1
.a949	a0 63		ldy #$63		ldy  #$63
.a94b					L10021_END:
.a94b					L10022:
>a94b	01					.byte L10022_END-L10022-1
.a94c	a8		tay			tay
.a94d					L10022_END:
.a94d					L10023:
>a94d	01					.byte L10023_END-L10023-1
.a94e	a8		tay			tay
.a94f					L10023_END:
.a94f					L10024:
>a94f	01					.byte L10024_END-L10024-1
.a950	5a		phy			phy
.a951					L10024_END:
.a951					L10025:
>a951	02					.byte L10025_END-L10025-1
>a952	a3 01					.byte $a3,$01
.a954					L10025_END:
.a954					L10026:
>a954	02					.byte L10026_END-L10026-1
>a955	a3 02					.byte $a3,$02
.a957					L10026_END:
.a957					L10027:
>a957	01					.byte L10027_END-L10027-1
.a958	7a		ply			ply
.a959					L10027_END:
.a959					L10028:
>a959	03					.byte L10028_END-L10028-1
.a95a	7a		ply			ply
.a95b	fa		plx			plx
.a95c	68		pla			pla
.a95d					L10028_END:
.a95d					L10029:
>a95d	02					.byte L10029_END-L10029-1
.a95e	fa		plx			plx
.a95f	68		pla			pla
.a960					L10029_END:
.a960					L10030:
>a960	01					.byte L10030_END-L10030-1
.a961	68		pla			pla
.a962					L10030_END:
.a962					L10031:
>a962	08					.byte L10031_END-L10031-1
.a963	49 63		eor #$63		eor  #$63
.a965	48		pha			pha
.a966	8a		txa			txa
.a967	49 73		eor #$73		eor  #$73
.a969	aa		tax			tax
.a96a	68		pla			pla
.a96b					L10031_END:
.a96b					L10032:
>a96b	0a					.byte L10032_END-L10032-1
.a96c	51 63		eor ($63),y		eor  ($63),y
.a96e	48		pha			pha
.a96f	8a		txa			txa
.a970	c8		iny			iny
.a971	51 63		eor ($63),y		eor  ($63),y
.a973	88		dey			dey
.a974	aa		tax			tax
.a975	68		pla			pla
.a976					L10032_END:
.a976					L10033:
>a976	02					.byte L10033_END-L10033-1
.a977	45 63		eor $63			eor  $63
.a979					L10033_END:
.a979					L10034:
>a979	0a					.byte L10034_END-L10034-1
.a97a	4d 63 73	eor $7363		eor  $7363
.a97d	48		pha			pha
.a97e	8a		txa			txa
.a97f	4d 83 73	eor $7383		eor  $7383
.a982	aa		tax			tax
.a983	68		pla			pla
.a984					L10034_END:
.a984					L10035:
>a984	08					.byte L10035_END-L10035-1
.a985	45 63		eor $63			eor  $63
.a987	48		pha			pha
.a988	8a		txa			txa
.a989	45 83		eor $83			eor  $83
.a98b	aa		tax			tax
.a98c	68		pla			pla
.a98d					L10035_END:
.a98d					L10036:
>a98d	03					.byte L10036_END-L10036-1
.a98e	4d 63 73	eor $7363		eor  $7363
.a991					L10036_END:
.a991					L10037:
>a991	02					.byte L10037_END-L10037-1
.a992	49 63		eor #$63		eor  #$63
.a994					L10037_END:
.a994					L10038:
>a994	02					.byte L10038_END-L10038-1
>a995	a3 03					.byte $a3,$03
.a997					L10038_END:
.a997					L10039:
>a997	02					.byte L10039_END-L10039-1
>a998	a3 04					.byte $a3,$04
.a99a					L10039_END:
.a99a					L10040:
>a99a	03					.byte L10040_END-L10040-1
.a99b	48		pha			pha
.a99c	da		phx			phx
.a99d	5a		phy			phy
.a99e					L10040_END:
.a99e					L10041:
>a99e	04					.byte L10041_END-L10041-1
.a99f	a9 63		lda #$63		lda  #$63
.a9a1	a2 73		ldx #$73		ldx  #$73
.a9a3					L10041_END:
.a9a3					L10042:
>a9a3	07					.byte L10042_END-L10042-1
.a9a4	c8		iny			iny
.a9a5	b1 63		lda ($63),y		lda  ($63),y
.a9a7	aa		tax			tax
.a9a8	88		dey			dey
.a9a9	b1 63		lda ($63),y		lda  ($63),y
.a9ab					L10042_END:
.a9ab					L10043:
>a9ab	04					.byte L10043_END-L10043-1
.a9ac	a5 63		lda $63			lda  $63
.a9ae	a2 00		ldx #$00		ldx  #0
.a9b0					L10043_END:
.a9b0					L10044:
>a9b0	06					.byte L10044_END-L10044-1
.a9b1	ad 63 73	lda $7363		lda  $7363
.a9b4	ae 83 73	ldx $7383		ldx  $7383
.a9b7					L10044_END:
.a9b7					L10045:
>a9b7	04					.byte L10045_END-L10045-1
.a9b8	a5 63		lda $63			lda  $63
.a9ba	a6 83		ldx $83			ldx  $83
.a9bc					L10045_END:
.a9bc					L10046:
>a9bc	05					.byte L10046_END-L10046-1
.a9bd	ad 63 73	lda $7363		lda  $7363
.a9c0	a2 00		ldx #$00		ldx  #0
.a9c2					L10046_END:
.a9c2					L10047:
>a9c2	04					.byte L10047_END-L10047-1
.a9c3	a9 63		lda #$63		lda  #$63
.a9c5	a2 73		ldx #$73		ldx  #$73
.a9c7					L10047_END:
.a9c7					L10048:
>a9c7	03					.byte L10048_END-L10048-1
.a9c8	98		tya			tya
.a9c9	a2 00		ldx #$00		ldx  #0
.a9cb					L10048_END:
.a9cb					L10049:
>a9cb	02					.byte L10049_END-L10049-1
.a9cc	a2 00		ldx #$00		ldx  #0
.a9ce					L10049_END:
.a9ce					L10050:
>a9ce	09					.byte L10050_END-L10050-1
.a9cf	c9 00		cmp #$00		cmp #0
.a9d1	d0 02		bne $a9d5		bne *+4
.a9d3	e0 00		cpx #$00		cpx #0
>a9d5	93					.byte $93
.a9d6	f0 fe		beq $a9d6		beq *
.a9d8					L10050_END:
.a9d8					L10051:
>a9d8	09					.byte L10051_END-L10051-1
.a9d9	c9 00		cmp #$00		cmp #0
.a9db	d0 02		bne $a9df		bne *+4
.a9dd	e0 00		cpx #$00		cpx #0
>a9df	93					.byte $93
.a9e0	d0 fe		bne $a9e0		bne *
.a9e2					L10051_END:
.a9e2					L10052:
>a9e2	08					.byte L10052_END-L10052-1
.a9e3	09 63		ora #$63		ora  #$63
.a9e5	48		pha			pha
.a9e6	8a		txa			txa
.a9e7	09 73		ora #$73		ora  #$73
.a9e9	aa		tax			tax
.a9ea	68		pla			pla
.a9eb					L10052_END:
.a9eb					L10053:
>a9eb	0a					.byte L10053_END-L10053-1
.a9ec	11 63		ora ($63),y		ora  ($63),y
.a9ee	48		pha			pha
.a9ef	8a		txa			txa
.a9f0	c8		iny			iny
.a9f1	11 63		ora ($63),y		ora  ($63),y
.a9f3	88		dey			dey
.a9f4	aa		tax			tax
.a9f5	68		pla			pla
.a9f6					L10053_END:
.a9f6					L10054:
>a9f6	02					.byte L10054_END-L10054-1
.a9f7	05 63		ora $63			ora  $63
.a9f9					L10054_END:
.a9f9					L10055:
>a9f9	0a					.byte L10055_END-L10055-1
.a9fa	0d 63 73	ora $7363		ora  $7363
.a9fd	48		pha			pha
.a9fe	8a		txa			txa
.a9ff	0d 83 73	ora $7383		ora  $7383
.aa02	aa		tax			tax
.aa03	68		pla			pla
.aa04					L10055_END:
.aa04					L10056:
>aa04	08					.byte L10056_END-L10056-1
.aa05	05 63		ora $63			ora  $63
.aa07	48		pha			pha
.aa08	8a		txa			txa
.aa09	05 83		ora $83			ora  $83
.aa0b	aa		tax			tax
.aa0c	68		pla			pla
.aa0d					L10056_END:
.aa0d					L10057:
>aa0d	03					.byte L10057_END-L10057-1
.aa0e	0d 63 73	ora $7363		ora  $7363
.aa11					L10057_END:
.aa11					L10058:
>aa11	02					.byte L10058_END-L10058-1
.aa12	09 63		ora #$63		ora  #$63
.aa14					L10058_END:
.aa14					L10059:
>aa14	03					.byte L10059_END-L10059-1
.aa15	48		pha			pha
.aa16	8a		txa			txa
.aa17	fa		plx			plx
.aa18					L10059_END:
.aa18					L10060:
>aa18	02					.byte L10060_END-L10060-1
>aa19	a3 05					.byte $a3,$05
.aa1b					L10060_END:
.aa1b					L10061:
>aa1b	09					.byte L10061_END-L10061-1
.aa1c	38		sec			sec
.aa1d	e9 63		sbc #$63		sbc  #$63
.aa1f	48		pha			pha
.aa20	8a		txa			txa
.aa21	e9 73		sbc #$73		sbc  #$73
.aa23	aa		tax			tax
.aa24	68		pla			pla
.aa25					L10061_END:
.aa25					L10062:
>aa25	0b					.byte L10062_END-L10062-1
.aa26	38		sec			sec
.aa27	f1 63		sbc ($63),y		sbc  ($63),y
.aa29	48		pha			pha
.aa2a	8a		txa			txa
.aa2b	c8		iny			iny
.aa2c	f1 63		sbc ($63),y		sbc  ($63),y
.aa2e	88		dey			dey
.aa2f	aa		tax			tax
.aa30	68		pla			pla
.aa31					L10062_END:
.aa31					L10063:
>aa31	06					.byte L10063_END-L10063-1
.aa32	38		sec			sec
.aa33	e5 63		sbc $63			sbc  $63
.aa35	b0 01		bcs $aa38		bcs  *+3
.aa37	ca		dex			dex
.aa38					L10063_END:
.aa38					L10064:
>aa38	0b					.byte L10064_END-L10064-1
.aa39	38		sec			sec
.aa3a	ed 63 73	sbc $7363		sbc  $7363
.aa3d	48		pha			pha
.aa3e	8a		txa			txa
.aa3f	ed 83 73	sbc $7383		sbc  $7383
.aa42	aa		tax			tax
.aa43	68		pla			pla
.aa44					L10064_END:
.aa44					L10065:
>aa44	09					.byte L10065_END-L10065-1
.aa45	38		sec			sec
.aa46	e5 63		sbc $63			sbc  $63
.aa48	48		pha			pha
.aa49	8a		txa			txa
.aa4a	e5 83		sbc $83			sbc  $83
.aa4c	aa		tax			tax
.aa4d	68		pla			pla
.aa4e					L10065_END:
.aa4e					L10066:
>aa4e	07					.byte L10066_END-L10066-1
.aa4f	38		sec			sec
.aa50	ed 63 73	sbc $7363		sbc  $7363
.aa53	b0 01		bcs $aa56		bcs  *+3
.aa55	ca		dex			dex
.aa56					L10066_END:
.aa56					L10067:
>aa56	06					.byte L10067_END-L10067-1
.aa57	38		sec			sec
.aa58	e9 63		sbc #$63		sbc  #$63
.aa5a	b0 01		bcs $aa5d		bcs  *+3
.aa5c	ca		dex			dex
.aa5d					L10067_END:
.aa5d					L10068:
>aa5d	05					.byte L10068_END-L10068-1
.aa5e	e0 00		cpx #$00		cpx #0
>aa60	93					.byte $93
.aa61	30 fe		bmi $aa61		bmi *
.aa63					L10068_END:
.aa63					L10069:
>aa63	02					.byte L10069_END-L10069-1
.aa64	48		pha			pha
.aa65	da		phx			phx
.aa66					L10069_END:
.aa66					L10070:
>aa66	09					.byte L10070_END-L10070-1
.aa67	18		clc			clc
.aa68	69 63		adc #$63		adc  #$63
.aa6a	48		pha			pha
.aa6b	8a		txa			txa
.aa6c	69 73		adc #$73		adc  #$73
.aa6e	aa		tax			tax
.aa6f	68		pla			pla
.aa70					L10070_END:
.aa70					L10071:
>aa70	0b					.byte L10071_END-L10071-1
.aa71	18		clc			clc
.aa72	71 63		adc ($63),y		adc  ($63),y
.aa74	48		pha			pha
.aa75	8a		txa			txa
.aa76	c8		iny			iny
.aa77	71 63		adc ($63),y		adc  ($63),y
.aa79	88		dey			dey
.aa7a	aa		tax			tax
.aa7b	68		pla			pla
.aa7c					L10071_END:
.aa7c					L10072:
>aa7c	06					.byte L10072_END-L10072-1
.aa7d	18		clc			clc
.aa7e	65 63		adc $63			adc  $63
.aa80	90 01		bcc $aa83		bcc  *+3
.aa82	e8		inx			inx
.aa83					L10072_END:
.aa83					L10073:
>aa83	0b					.byte L10073_END-L10073-1
.aa84	18		clc			clc
.aa85	6d 63 73	adc $7363		adc  $7363
.aa88	48		pha			pha
.aa89	8a		txa			txa
.aa8a	6d 83 73	adc $7383		adc  $7383
.aa8d	aa		tax			tax
.aa8e	68		pla			pla
.aa8f					L10073_END:
.aa8f					L10074:
>aa8f	09					.byte L10074_END-L10074-1
.aa90	18		clc			clc
.aa91	65 63		adc $63			adc  $63
.aa93	48		pha			pha
.aa94	8a		txa			txa
.aa95	65 83		adc $83			adc  $83
.aa97	aa		tax			tax
.aa98	68		pla			pla
.aa99					L10074_END:
.aa99					L10075:
>aa99	07					.byte L10075_END-L10075-1
.aa9a	18		clc			clc
.aa9b	6d 63 73	adc $7363		adc  $7363
.aa9e	90 01		bcc $aaa1		bcc  *+3
.aaa0	e8		inx			inx
.aaa1					L10075_END:
.aaa1					L10076:
>aaa1	06					.byte L10076_END-L10076-1
.aaa2	18		clc			clc
.aaa3	69 63		adc #$63		adc  #$63
.aaa5	90 01		bcc $aaa8		bcc  *+3
.aaa7	e8		inx			inx
.aaa8					L10076_END:
.aaa8					L10077:
>aaa8	05					.byte L10077_END-L10077-1
.aaa9	e0 00		cpx #$00		cpx #0
>aaab	93					.byte $93
.aaac	10 fe		bpl $aaac		bpl *
.aaae					L10077_END:
.aaae					L10078:
>aaae	08					.byte L10078_END-L10078-1
.aaaf	29 63		and #$63		and  #$63
.aab1	48		pha			pha
.aab2	8a		txa			txa
.aab3	29 73		and #$73		and  #$73
.aab5	aa		tax			tax
.aab6	68		pla			pla
.aab7					L10078_END:
.aab7					L10079:
>aab7	0a					.byte L10079_END-L10079-1
.aab8	31 63		and ($63),y		and  ($63),y
.aaba	48		pha			pha
.aabb	8a		txa			txa
.aabc	c8		iny			iny
.aabd	31 63		and ($63),y		and  ($63),y
.aabf	88		dey			dey
.aac0	aa		tax			tax
.aac1	68		pla			pla
.aac2					L10079_END:
.aac2					L10080:
>aac2	04					.byte L10080_END-L10080-1
.aac3	25 63		and $63			and  $63
.aac5	a2 00		ldx #$00		ldx  #0
.aac7					L10080_END:
.aac7					L10081:
>aac7	0a					.byte L10081_END-L10081-1
.aac8	2d 63 73	and $7363		and  $7363
.aacb	48		pha			pha
.aacc	8a		txa			txa
.aacd	2d 83 73	and $7383		and  $7383
.aad0	aa		tax			tax
.aad1	68		pla			pla
.aad2					L10081_END:
.aad2					L10082:
>aad2	08					.byte L10082_END-L10082-1
.aad3	25 63		and $63			and  $63
.aad5	48		pha			pha
.aad6	8a		txa			txa
.aad7	25 83		and $83			and  $83
.aad9	aa		tax			tax
.aada	68		pla			pla
.aadb					L10082_END:
.aadb					L10083:
>aadb	05					.byte L10083_END-L10083-1
.aadc	2d 63 73	and $7363		and  $7363
.aadf	a2 00		ldx #$00		ldx  #0
.aae1					L10083_END:
.aae1					L10084:
>aae1	04					.byte L10084_END-L10084-1
.aae2	29 63		and #$63		and  #$63
.aae4	a2 00		ldx #$00		ldx  #0
.aae6					L10084_END:
.aae6					L10085:
>aae6	02					.byte L10085_END-L10085-1
>aae7	a3 06					.byte $a3,$06
.aae9					L10085_END:
.aae9					L10086:
>aae9	02					.byte L10086_END-L10086-1
>aaea	a3 07					.byte $a3,$07
.aaec					L10086_END:
.aaec					L10087:
>aaec	02					.byte L10087_END-L10087-1
>aaed	a3 08					.byte $a3,$08
.aaef					L10087_END:
.aaef					L10088:
>aaef	02					.byte L10088_END-L10088-1
>aaf0	a3 09					.byte $a3,$09
.aaf2					L10088_END:
.aaf2					L10089:
>aaf2	02					.byte L10089_END-L10089-1
>aaf3	a3 0a					.byte $a3,$0a
.aaf5					L10089_END:
.aaf5					L10090:
>aaf5	02					.byte L10090_END-L10090-1
>aaf6	a3 0b					.byte $a3,$0b
.aaf8					L10090_END:
.aaf8					L10091:
>aaf8	03					.byte L10091_END-L10091-1
>aaf9	93					.byte $93
.aafa	b0 fe		bcs $aafa		bcs  *
.aafc					L10091_END:
.aafc					L10092:
>aafc	03					.byte L10092_END-L10092-1
>aafd	93					.byte $93
.aafe	90 fe		bcc $aafe		bcc  *
.ab00					L10092_END:
.ab00					L10093:
>ab00	02					.byte L10093_END-L10093-1
>ab01	a3 0c					.byte $a3,$0c
.ab03					L10093_END:
.ab03					L10094:
>ab03	01					.byte L10094_END-L10094-1
>ab04	ff					.byte  $ff
.ab05					L10094_END:
.ab05					L10095:
>ab05	02					.byte L10095_END-L10095-1
.ab06	51 63		eor ($63),y		eor  ($63),y
.ab08					L10095_END:
.ab08					L10096:
>ab08	02					.byte L10096_END-L10096-1
.ab09	45 63		eor $63			eor  $63
.ab0b					L10096_END:
.ab0b					L10097:
>ab0b	03					.byte L10097_END-L10097-1
.ab0c	4d 63 73	eor $7363		eor  $7363
.ab0f					L10097_END:
.ab0f					L10098:
>ab0f	02					.byte L10098_END-L10098-1
.ab10	49 63		eor #$63		eor  #$63
.ab12					L10098_END:
.ab12					L10099:
>ab12	02					.byte L10099_END-L10099-1
.ab13	b1 63		lda ($63),y		lda  ($63),y
.ab15					L10099_END:
.ab15					L10100:
>ab15	02					.byte L10100_END-L10100-1
.ab16	a5 63		lda $63			lda  $63
.ab18					L10100_END:
.ab18					L10101:
>ab18	03					.byte L10101_END-L10101-1
.ab19	ad 63 73	lda $7363		lda  $7363
.ab1c					L10101_END:
.ab1c					L10102:
>ab1c	02					.byte L10102_END-L10102-1
.ab1d	a9 63		lda #$63		lda  #$63
.ab1f					L10102_END:
.ab1f					L10103:
>ab1f	01					.byte L10103_END-L10103-1
.ab20	98		tya			tya
.ab21					L10103_END:
.ab21					L10104:
>ab21	00					.byte L10104_END-L10104-1
.ab22					L10104_END:
.ab22					L10105:
>ab22	05					.byte L10105_END-L10105-1
.ab23	c9 00		cmp #$00		cmp #0
>ab25	93					.byte $93
.ab26	f0 fe		beq $ab26		beq *
.ab28					L10105_END:
.ab28					L10106:
>ab28	05					.byte L10106_END-L10106-1
.ab29	c9 00		cmp #$00		cmp #0
>ab2b	93					.byte $93
.ab2c	d0 fe		bne $ab2c		bne *
.ab2e					L10106_END:
.ab2e					L10107:
>ab2e	02					.byte L10107_END-L10107-1
.ab2f	11 63		ora ($63),y		ora  ($63),y
.ab31					L10107_END:
.ab31					L10108:
>ab31	02					.byte L10108_END-L10108-1
.ab32	05 63		ora $63			ora  $63
.ab34					L10108_END:
.ab34					L10109:
>ab34	03					.byte L10109_END-L10109-1
.ab35	0d 63 73	ora $7363		ora  $7363
.ab38					L10109_END:
.ab38					L10110:
>ab38	02					.byte L10110_END-L10110-1
.ab39	09 63		ora #$63		ora  #$63
.ab3b					L10110_END:
.ab3b					L10111:
>ab3b	02					.byte L10111_END-L10111-1
>ab3c	a3 0d					.byte $a3,$0d
.ab3e					L10111_END:
.ab3e					L10112:
>ab3e	03					.byte L10112_END-L10112-1
.ab3f	38		sec			sec
.ab40	f1 63		sbc ($63),y		sbc  ($63),y
.ab42					L10112_END:
.ab42					L10113:
>ab42	03					.byte L10113_END-L10113-1
.ab43	38		sec			sec
.ab44	e5 63		sbc $63			sbc  $63
.ab46					L10113_END:
.ab46					L10114:
>ab46	04					.byte L10114_END-L10114-1
.ab47	38		sec			sec
.ab48	ed 63 73	sbc $7363		sbc  $7363
.ab4b					L10114_END:
.ab4b					L10115:
>ab4b	03					.byte L10115_END-L10115-1
.ab4c	38		sec			sec
.ab4d	e9 63		sbc #$63		sbc  #$63
.ab4f					L10115_END:
.ab4f					L10116:
>ab4f	05					.byte L10116_END-L10116-1
.ab50	c9 00		cmp #$00		cmp #0
>ab52	93					.byte $93
.ab53	30 fe		bmi $ab53		bmi *
.ab55					L10116_END:
.ab55					L10117:
>ab55	01					.byte L10117_END-L10117-1
.ab56	48		pha			pha
.ab57					L10117_END:
.ab57					L10118:
>ab57	03					.byte L10118_END-L10118-1
.ab58	18		clc			clc
.ab59	71 63		adc ($63),y		adc  ($63),y
.ab5b					L10118_END:
.ab5b					L10119:
>ab5b	03					.byte L10119_END-L10119-1
.ab5c	18		clc			clc
.ab5d	65 63		adc $63			adc  $63
.ab5f					L10119_END:
.ab5f					L10120:
>ab5f	04					.byte L10120_END-L10120-1
.ab60	18		clc			clc
.ab61	6d 63 73	adc $7363		adc  $7363
.ab64					L10120_END:
.ab64					L10121:
>ab64	03					.byte L10121_END-L10121-1
.ab65	18		clc			clc
.ab66	69 63		adc #$63		adc  #$63
.ab68					L10121_END:
.ab68					L10122:
>ab68	05					.byte L10122_END-L10122-1
.ab69	c9 00		cmp #$00		cmp #0
>ab6b	93					.byte $93
.ab6c	10 fe		bpl $ab6c		bpl *
.ab6e					L10122_END:
.ab6e					L10123:
>ab6e	02					.byte L10123_END-L10123-1
.ab6f	31 63		and ($63),y		and  ($63),y
.ab71					L10123_END:
.ab71					L10124:
>ab71	02					.byte L10124_END-L10124-1
.ab72	25 63		and $63			and  $63
.ab74					L10124_END:
.ab74					L10125:
>ab74	03					.byte L10125_END-L10125-1
.ab75	2d 63 73	and $7363		and  $7363
.ab78					L10125_END:
.ab78					L10126:
>ab78	02					.byte L10126_END-L10126-1
.ab79	29 63		and #$63		and  #$63
.ab7b					L10126_END:
.ab7b					L10127:
>ab7b	02					.byte L10127_END-L10127-1
.ab7c	46 63		lsr $63			lsr  $63
.ab7e					L10127_END:
.ab7e					L10128:
>ab7e	06					.byte L10128_END-L10128-1
.ab7f	4e 83 73	lsr $7383		lsr  $7383
.ab82	6e 63 73	ror $7363		ror  $7363
.ab85					L10128_END:
.ab85					L10129:
>ab85	04					.byte L10129_END-L10129-1
.ab86	46 83		lsr $83			lsr  $83
.ab88	66 63		ror $63			ror  $63
.ab8a					L10129_END:
.ab8a					L10130:
>ab8a	03					.byte L10130_END-L10130-1
.ab8b	4e 63 73	lsr $7363		lsr  $7363
.ab8e					L10130_END:
.ab8e					L10131:
>ab8e	06					.byte L10131_END-L10131-1
.ab8f	48		pha			pha
.ab90	8a		txa			txa
.ab91	4a		lsr a			lsr  a
.ab92	aa		tax			tax
.ab93	68		pla			pla
.ab94	6a		ror a			ror  a
.ab95					L10131_END:
.ab95					L10132:
>ab95	01					.byte L10132_END-L10132-1
.ab96	4a		lsr a			lsr  a
.ab97					L10132_END:
.ab97					L10133:
>ab97	02					.byte L10133_END-L10133-1
.ab98	06 63		asl $63			asl  $63
.ab9a					L10133_END:
.ab9a					L10134:
>ab9a	06					.byte L10134_END-L10134-1
.ab9b	0e 63 73	asl $7363		asl  $7363
.ab9e	2e 83 73	rol $7383		rol  $7383
.aba1					L10134_END:
.aba1					L10135:
>aba1	04					.byte L10135_END-L10135-1
.aba2	06 63		asl $63			asl  $63
.aba4	26 83		rol $83			rol  $83
.aba6					L10135_END:
.aba6					L10136:
>aba6	03					.byte L10136_END-L10136-1
.aba7	0e 63 73	asl $7363		asl  $7363
.abaa					L10136_END:
.abaa					L10137:
>abaa	06					.byte L10137_END-L10137-1
.abab	0a		asl a			asl  a
.abac	48		pha			pha
.abad	8a		txa			txa
.abae	2a		rol a			rol  a
.abaf	aa		tax			tax
.abb0	68		pla			pla
.abb1					L10137_END:
.abb1					L10138:
>abb1	01					.byte L10138_END-L10138-1
.abb2	0a		asl a			asl  a
.abb3					L10138_END:
.abb3					L10139:
>abb3	0b					.byte L10139_END-L10139-1
.abb4	8a		txa			txa
.abb5	49 ff		eor #$ff		eor  #$ff
.abb7	aa		tax			tax
.abb8	68		pla			pla
.abb9	49 ff		eor #$ff		eor  #$ff
.abbb	1a		inc a			inc  a
.abbc	d0 01		bne $abbf		bne  *+3
.abbe	e8		inx			inx
.abbf					L10139_END:
.abbf					L10140:
>abbf	03					.byte L10140_END-L10140-1
.abc0	49 ff		eor #$ff		eor  #$ff
.abc2	1a		inc a			inc  a
.abc3					L10140_END:
.abc3					L10141:
>abc3	02					.byte L10141_END-L10141-1
.abc4	c6 63		dec $63			dec  $63
.abc6					L10141_END:
.abc6					L10142:
>abc6	0d					.byte L10142_END-L10142-1
.abc7	48		pha			pha
.abc8	ad 63 73	lda $7363		lda  $7363
.abcb	d0 03		bne $abd0		bne  _noborrow
.abcd	ce 83 73	dec $7383		dec  $7383
.abd0					_noborrow:
.abd0	ce 63 73	dec $7363		dec  $7363
.abd3	68		pla			pla
.abd4					L10142_END:
.abd4					L10143:
>abd4	0a					.byte L10143_END-L10143-1
.abd5	48		pha			pha
.abd6	a5 63		lda $63			lda  $63
.abd8	d0 02		bne $abdc		bne  _noborrow
.abda	c6 83		dec $83			dec  $83
.abdc					_noborrow:
.abdc	c6 63		dec $63			dec  $63
.abde	68		pla			pla
.abdf					L10143_END:
.abdf					L10144:
>abdf	03					.byte L10144_END-L10144-1
.abe0	ce 63 73	dec $7363		dec  $7363
.abe3					L10144_END:
.abe3					L10145:
>abe3	01					.byte L10145_END-L10145-1
.abe4	88		dey			dey
.abe5					L10145_END:
.abe5					L10146:
>abe5	06					.byte L10146_END-L10146-1
.abe6	c9 00		cmp #$00		cmp  #0
.abe8	d0 01		bne $abeb		bne  *+3
.abea	ca		dex			dex
.abeb	3a		dec a			dec  a
.abec					L10146_END:
.abec					L10147:
>abec	01					.byte L10147_END-L10147-1
.abed	3a		dec a			dec  a
.abee					L10147_END:
.abee					L10148:
>abee	02					.byte L10148_END-L10148-1
.abef	e6 63		inc $63			inc  $63
.abf1					L10148_END:
.abf1					L10149:
>abf1	08					.byte L10149_END-L10149-1
.abf2	ee 63 73	inc $7363		inc  $7363
.abf5	d0 03		bne $abfa		bne  _nocarry
.abf7	ee 83 73	inc $7383		inc  $7383
.abfa					_nocarry:
.abfa					L10149_END:
.abfa					L10150:
>abfa	06					.byte L10150_END-L10150-1
.abfb	e6 63		inc $63			inc  $63
.abfd	d0 02		bne $ac01		bne  _nocarry
.abff	e6 83		inc $83			inc  $83
.ac01					_nocarry:
.ac01					L10150_END:
.ac01					L10151:
>ac01	03					.byte L10151_END-L10151-1
.ac02	ee 63 73	inc $7363		inc  $7363
.ac05					L10151_END:
.ac05					L10152:
>ac05	01					.byte L10152_END-L10152-1
.ac06	c8		iny			iny
.ac07					L10152_END:
.ac07					L10153:
>ac07	04					.byte L10153_END-L10153-1
.ac08	1a		inc a			inc  a
.ac09	d0 01		bne $ac0c		bne  *+3
.ac0b	e8		inx			inx
.ac0c					L10153_END:
.ac0c					L10154:
>ac0c	01					.byte L10154_END-L10154-1
.ac0d	1a		inc a			inc  a
.ac0e					L10154_END:
.ac0e					ExecutableVectorTable:
>ac0e	36 a5					.word Action_call                      ; 0
>ac10	c9 a6					.word Action_wordvar                   ; 1
>ac12	1f a6					.word Action_until                     ; 2
>ac14	16 a6					.word Action_repeat                    ; 3
>ac16	38 a7					.word Action_dictionarycrunch          ; 4
>ac18	46 a6					.word Action_rfor                      ; 5
>ac1a	f1 a4					.word Action_procedure_def             ; 6
>ac1c	77 a6					.word Action_next                      ; 7
>ac1e	b1 a5					.word Action_if                        ; 8
>ac20	26 a5					.word Action_endproc                   ; 9
>ac22	e8 a5					.word Action_endif                     ; 10
>ac24	c6 a5					.word Action_else                      ; 11
>ac26	c5 a6					.word Action_bytevar                   ; 12
>ac28	33 a6					.word Action_afor                      ; 13
.ac2a					SystemDictionary:
>ac2a	07					.byte	7
>ac2b	4d					.byte	'M'
>ac2c	e4 a8					.word	L10000
>ac2e	00					.byte	0
>ac2f	01					.byte	1
>ac30	f7					.byte	$f7
>ac31	0c					.byte	12
>ac32	4d					.byte	'M'
>ac33	e9 a8					.word	L10001
>ac35	00					.byte	0
>ac36	06					.byte	6
>ac37	f3 db d9 dd bd d2			.byte	$f3,$db,$d9,$dd,$bd,$d2
>ac3d	0c					.byte	12
>ac3e	4d					.byte	'M'
>ac3f	f3 a8					.word	L10002
>ac41	00					.byte	0
>ac42	06					.byte	6
>ac43	f3 db d9 dd bd c1			.byte	$f3,$db,$d9,$dd,$bd,$c1
>ac49	09					.byte	9
>ac4a	4d					.byte	'M'
>ac4b	f6 a8					.word	L10003
>ac4d	00					.byte	0
>ac4e	03					.byte	3
>ac4f	f3 bd d9				.byte	$f3,$bd,$d9
>ac52	09					.byte	9
>ac53	4d					.byte	'M'
>ac54	f9 a8					.word	L10004
>ac56	00					.byte	0
>ac57	03					.byte	3
>ac58	f3 bd d2				.byte	$f3,$bd,$d2
>ac5b	09					.byte	9
>ac5c	4d					.byte	'M'
>ac5d	fc a8					.word	L10005
>ac5f	00					.byte	0
>ac60	03					.byte	3
>ac61	f3 bd c1				.byte	$f3,$bd,$c1
>ac64	07					.byte	7
>ac65	4d					.byte	'M'
>ac66	ff a8					.word	L10006
>ac68	00					.byte	0
>ac69	01					.byte	1
>ac6a	f3					.byte	$f3
>ac6b	07					.byte	7
>ac6c	4d					.byte	'M'
>ac6d	04 a9					.word	L10007
>ac6f	00					.byte	0
>ac70	01					.byte	1
>ac71	f0					.byte	$f0
>ac72	09					.byte	9
>ac73	4d					.byte	'M'
>ac74	07 a9					.word	L10008
>ac76	00					.byte	0
>ac77	03					.byte	3
>ac78	ec bd d2				.byte	$ec,$bd,$d2
>ac7b	07					.byte	7
>ac7c	4d					.byte	'M'
>ac7d	0e a9					.word	L10009
>ac7f	00					.byte	0
>ac80	01					.byte	1
>ac81	ec					.byte	$ec
>ac82	09					.byte	9
>ac83	4d					.byte	'M'
>ac84	15 a9					.word	L10010
>ac86	00					.byte	0
>ac87	03					.byte	3
>ac88	e9 bd d2				.byte	$e9,$bd,$d2
>ac8b	07					.byte	7
>ac8c	4d					.byte	'M'
>ac8d	1a a9					.word	L10011
>ac8f	00					.byte	0
>ac90	01					.byte	1
>ac91	e9					.byte	$e9
>ac92	09					.byte	9
>ac93	4d					.byte	'M'
>ac94	1f a9					.word	L10012
>ac96	00					.byte	0
>ac97	03					.byte	3
>ac98	e3 bd d9				.byte	$e3,$bd,$d9
>ac9b	09					.byte	9
>ac9c	4d					.byte	'M'
>ac9d	23 a9					.word	L10013
>ac9f	00					.byte	0
>aca0	03					.byte	3
>aca1	e3 bd d2				.byte	$e3,$bd,$d2
>aca4	09					.byte	9
>aca5	4d					.byte	'M'
>aca6	27 a9					.word	L10014
>aca8	00					.byte	0
>aca9	03					.byte	3
>acaa	e3 bd c1				.byte	$e3,$bd,$c1
>acad	07					.byte	7
>acae	4d					.byte	'M'
>acaf	2b a9					.word	L10015
>acb1	00					.byte	0
>acb2	01					.byte	1
>acb3	e3					.byte	$e3
>acb4	07					.byte	7
>acb5	4d					.byte	'M'
>acb6	31 a9					.word	L10016
>acb8	00					.byte	0
>acb9	01					.byte	1
>acba	e2					.byte	$e2
>acbb	0b					.byte	11
>acbc	4d					.byte	'M'
>acbd	36 a9					.word	L10017
>acbf	00					.byte	0
>acc0	05					.byte	5
>acc1	de 52 50 48 c1				.byte	$de,$52,$50,$48,$c1
>acc6	08					.byte	8
>acc7	4d					.byte	'M'
>acc8	3e a9					.word	L10018
>acca	00					.byte	0
>accb	02					.byte	2
>accc	de c1					.byte	$de,$c1
>acce	09					.byte	9
>accf	4d					.byte	'M'
>acd0	41 a9					.word	L10019
>acd2	00					.byte	0
>acd3	03					.byte	3
>acd4	d9 bd f3				.byte	$d9,$bd,$f3
>acd7	09					.byte	9
>acd8	4d					.byte	'M'
>acd9	44 a9					.word	L10020
>acdb	00					.byte	0
>acdc	03					.byte	3
>acdd	d9 bd e3				.byte	$d9,$bd,$e3
>ace0	09					.byte	9
>ace1	4d					.byte	'M'
>ace2	48 a9					.word	L10021
>ace4	00					.byte	0
>ace5	03					.byte	3
>ace6	d9 bd e2				.byte	$d9,$bd,$e2
>ace9	09					.byte	9
>acea	4d					.byte	'M'
>aceb	4b a9					.word	L10022
>aced	00					.byte	0
>acee	03					.byte	3
>acef	d9 bd d2				.byte	$d9,$bd,$d2
>acf2	09					.byte	9
>acf3	4d					.byte	'M'
>acf4	4d a9					.word	L10023
>acf6	00					.byte	0
>acf7	03					.byte	3
>acf8	d9 bd c1				.byte	$d9,$bd,$c1
>acfb	0a					.byte	10
>acfc	4d					.byte	'M'
>acfd	4f a9					.word	L10024
>acff	00					.byte	0
>ad00	04					.byte	4
>ad01	d9 ad be d3				.byte	$d9,$ad,$be,$d3
>ad05	0a					.byte	10
>ad06	4d					.byte	'M'
>ad07	51 a9					.word	L10025
>ad09	00					.byte	0
>ad0a	04					.byte	4
>ad0b	57 4f 52 c4				.byte	$57,$4f,$52,$c4
>ad0f	0b					.byte	11
>ad10	4d					.byte	'M'
>ad11	54 a9					.word	L10026
>ad13	00					.byte	0
>ad14	05					.byte	5
>ad15	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
>ad1a	0a					.byte	10
>ad1b	4d					.byte	'M'
>ad1c	57 a9					.word	L10027
>ad1e	00					.byte	0
>ad1f	04					.byte	4
>ad20	d3 ad be d9				.byte	$d3,$ad,$be,$d9
>ad24	0c					.byte	12
>ad25	4d					.byte	'M'
>ad26	59 a9					.word	L10028
>ad28	00					.byte	0
>ad29	06					.byte	6
>ad2a	d3 ad be 52 41 d9			.byte	$d3,$ad,$be,$52,$41,$d9
>ad30	0a					.byte	10
>ad31	4d					.byte	'M'
>ad32	5d a9					.word	L10029
>ad34	00					.byte	0
>ad35	04					.byte	4
>ad36	d3 ad be d2				.byte	$d3,$ad,$be,$d2
>ad3a	0a					.byte	10
>ad3b	4d					.byte	'M'
>ad3c	60 a9					.word	L10030
>ad3e	00					.byte	0
>ad3f	04					.byte	4
>ad40	d3 ad be c1				.byte	$d3,$ad,$be,$c1
>ad44	09					.byte	9
>ad45	4d					.byte	'M'
>ad46	62 a9					.word	L10031
>ad48	00					.byte	0
>ad49	03					.byte	3
>ad4a	d2 f7 f7				.byte	$d2,$f7,$f7
>ad4d	0c					.byte	12
>ad4e	4d					.byte	'M'
>ad4f	6b a9					.word	L10032
>ad51	00					.byte	0
>ad52	06					.byte	6
>ad53	d2 f3 f3 db d9 dd			.byte	$d2,$f3,$f3,$db,$d9,$dd
>ad59	09					.byte	9
>ad5a	4d					.byte	'M'
>ad5b	76 a9					.word	L10033
>ad5d	00					.byte	0
>ad5e	03					.byte	3
>ad5f	d2 f3 f3				.byte	$d2,$f3,$f3
>ad62	09					.byte	9
>ad63	4d					.byte	'M'
>ad64	79 a9					.word	L10034
>ad66	00					.byte	0
>ad67	03					.byte	3
>ad68	d2 ec ec				.byte	$d2,$ec,$ec
>ad6b	09					.byte	9
>ad6c	4d					.byte	'M'
>ad6d	84 a9					.word	L10035
>ad6f	00					.byte	0
>ad70	03					.byte	3
>ad71	d2 e9 e9				.byte	$d2,$e9,$e9
>ad74	09					.byte	9
>ad75	4d					.byte	'M'
>ad76	8d a9					.word	L10036
>ad78	00					.byte	0
>ad79	03					.byte	3
>ad7a	d2 e3 e3				.byte	$d2,$e3,$e3
>ad7d	09					.byte	9
>ad7e	4d					.byte	'M'
>ad7f	91 a9					.word	L10037
>ad81	00					.byte	0
>ad82	03					.byte	3
>ad83	d2 e2 e2				.byte	$d2,$e2,$e2
>ad86	0c					.byte	12
>ad87	4d					.byte	'M'
>ad88	94 a9					.word	L10038
>ad8a	00					.byte	0
>ad8b	06					.byte	6
>ad8c	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
>ad92	13					.byte	19
>ad93	4d					.byte	'M'
>ad94	97 a9					.word	L10039
>ad96	00					.byte	0
>ad97	0d					.byte	13
>ad98	52 45 4d 4f 56 45 2e 4c			.byte	$52,$45,$4d,$4f,$56,$45,$2e,$4c,$4f,$43,$41,$4c,$d3
>ada0	4f 43 41 4c d3
>ada5	0c					.byte	12
>ada6	4d					.byte	'M'
>ada7	9a a9					.word	L10040
>ada9	00					.byte	0
>adaa	06					.byte	6
>adab	52 41 d9 ad be d3			.byte	$52,$41,$d9,$ad,$be,$d3
>adb1	09					.byte	9
>adb2	4d					.byte	'M'
>adb3	9e a9					.word	L10041
>adb5	00					.byte	0
>adb6	03					.byte	3
>adb7	d2 bd f7				.byte	$d2,$bd,$f7
>adba	0c					.byte	12
>adbb	4d					.byte	'M'
>adbc	a3 a9					.word	L10042
>adbe	00					.byte	0
>adbf	06					.byte	6
>adc0	d2 bd f3 db d9 dd			.byte	$d2,$bd,$f3,$db,$d9,$dd
>adc6	09					.byte	9
>adc7	4d					.byte	'M'
>adc8	ab a9					.word	L10043
>adca	00					.byte	0
>adcb	03					.byte	3
>adcc	d2 bd f3				.byte	$d2,$bd,$f3
>adcf	09					.byte	9
>add0	4d					.byte	'M'
>add1	b0 a9					.word	L10044
>add3	00					.byte	0
>add4	03					.byte	3
>add5	d2 bd ec				.byte	$d2,$bd,$ec
>add8	09					.byte	9
>add9	4d					.byte	'M'
>adda	b7 a9					.word	L10045
>addc	00					.byte	0
>addd	03					.byte	3
>adde	d2 bd e9				.byte	$d2,$bd,$e9
>ade1	09					.byte	9
>ade2	4d					.byte	'M'
>ade3	bc a9					.word	L10046
>ade5	00					.byte	0
>ade6	03					.byte	3
>ade7	d2 bd e3				.byte	$d2,$bd,$e3
>adea	09					.byte	9
>adeb	4d					.byte	'M'
>adec	c2 a9					.word	L10047
>adee	00					.byte	0
>adef	03					.byte	3
>adf0	d2 bd e2				.byte	$d2,$bd,$e2
>adf3	09					.byte	9
>adf4	4d					.byte	'M'
>adf5	c7 a9					.word	L10048
>adf7	00					.byte	0
>adf8	03					.byte	3
>adf9	d2 bd d9				.byte	$d2,$bd,$d9
>adfc	09					.byte	9
>adfd	4d					.byte	'M'
>adfe	cb a9					.word	L10049
>ae00	00					.byte	0
>ae01	03					.byte	3
>ae02	d2 bd c1				.byte	$d2,$bd,$c1
>ae05	09					.byte	9
>ae06	4d					.byte	'M'
>ae07	ce a9					.word	L10050
>ae09	00					.byte	0
>ae0a	03					.byte	3
>ae0b	d2 bd bf				.byte	$d2,$bd,$bf
>ae0e	0a					.byte	10
>ae0f	4d					.byte	'M'
>ae10	d8 a9					.word	L10051
>ae12	00					.byte	0
>ae13	04					.byte	4
>ae14	d2 bc be bf				.byte	$d2,$bc,$be,$bf
>ae18	09					.byte	9
>ae19	4d					.byte	'M'
>ae1a	e2 a9					.word	L10052
>ae1c	00					.byte	0
>ae1d	03					.byte	3
>ae1e	d2 ba f7				.byte	$d2,$ba,$f7
>ae21	0c					.byte	12
>ae22	4d					.byte	'M'
>ae23	eb a9					.word	L10053
>ae25	00					.byte	0
>ae26	06					.byte	6
>ae27	d2 ba f3 db d9 dd			.byte	$d2,$ba,$f3,$db,$d9,$dd
>ae2d	09					.byte	9
>ae2e	4d					.byte	'M'
>ae2f	f6 a9					.word	L10054
>ae31	00					.byte	0
>ae32	03					.byte	3
>ae33	d2 ba f3				.byte	$d2,$ba,$f3
>ae36	09					.byte	9
>ae37	4d					.byte	'M'
>ae38	f9 a9					.word	L10055
>ae3a	00					.byte	0
>ae3b	03					.byte	3
>ae3c	d2 ba ec				.byte	$d2,$ba,$ec
>ae3f	09					.byte	9
>ae40	4d					.byte	'M'
>ae41	04 aa					.word	L10056
>ae43	00					.byte	0
>ae44	03					.byte	3
>ae45	d2 ba e9				.byte	$d2,$ba,$e9
>ae48	09					.byte	9
>ae49	4d					.byte	'M'
>ae4a	0d aa					.word	L10057
>ae4c	00					.byte	0
>ae4d	03					.byte	3
>ae4e	d2 ba e3				.byte	$d2,$ba,$e3
>ae51	09					.byte	9
>ae52	4d					.byte	'M'
>ae53	11 aa					.word	L10058
>ae55	00					.byte	0
>ae56	03					.byte	3
>ae57	d2 ba e2				.byte	$d2,$ba,$e2
>ae5a	0c					.byte	12
>ae5b	4d					.byte	'M'
>ae5c	14 aa					.word	L10059
>ae5e	00					.byte	0
>ae5f	06					.byte	6
>ae60	52 2e 53 57 41 d0			.byte	$52,$2e,$53,$57,$41,$d0
>ae66	0b					.byte	11
>ae67	4d					.byte	'M'
>ae68	18 aa					.word	L10060
>ae6a	00					.byte	0
>ae6b	05					.byte	5
>ae6c	52 2e 46 4f d2				.byte	$52,$2e,$46,$4f,$d2
>ae71	09					.byte	9
>ae72	4d					.byte	'M'
>ae73	1b aa					.word	L10061
>ae75	00					.byte	0
>ae76	03					.byte	3
>ae77	d2 ad f7				.byte	$d2,$ad,$f7
>ae7a	0c					.byte	12
>ae7b	4d					.byte	'M'
>ae7c	25 aa					.word	L10062
>ae7e	00					.byte	0
>ae7f	06					.byte	6
>ae80	d2 ad f3 db d9 dd			.byte	$d2,$ad,$f3,$db,$d9,$dd
>ae86	09					.byte	9
>ae87	4d					.byte	'M'
>ae88	31 aa					.word	L10063
>ae8a	00					.byte	0
>ae8b	03					.byte	3
>ae8c	d2 ad f3				.byte	$d2,$ad,$f3
>ae8f	09					.byte	9
>ae90	4d					.byte	'M'
>ae91	38 aa					.word	L10064
>ae93	00					.byte	0
>ae94	03					.byte	3
>ae95	d2 ad ec				.byte	$d2,$ad,$ec
>ae98	09					.byte	9
>ae99	4d					.byte	'M'
>ae9a	44 aa					.word	L10065
>ae9c	00					.byte	0
>ae9d	03					.byte	3
>ae9e	d2 ad e9				.byte	$d2,$ad,$e9
>aea1	09					.byte	9
>aea2	4d					.byte	'M'
>aea3	4e aa					.word	L10066
>aea5	00					.byte	0
>aea6	03					.byte	3
>aea7	d2 ad e3				.byte	$d2,$ad,$e3
>aeaa	09					.byte	9
>aeab	4d					.byte	'M'
>aeac	56 aa					.word	L10067
>aeae	00					.byte	0
>aeaf	03					.byte	3
>aeb0	d2 ad e2				.byte	$d2,$ad,$e2
>aeb3	09					.byte	9
>aeb4	4d					.byte	'M'
>aeb5	5d aa					.word	L10068
>aeb7	00					.byte	0
>aeb8	03					.byte	3
>aeb9	d2 ad bf				.byte	$d2,$ad,$bf
>aebc	0a					.byte	10
>aebd	4d					.byte	'M'
>aebe	63 aa					.word	L10069
>aec0	00					.byte	0
>aec1	04					.byte	4
>aec2	d2 ad be d3				.byte	$d2,$ad,$be,$d3
>aec6	09					.byte	9
>aec7	4d					.byte	'M'
>aec8	66 aa					.word	L10070
>aeca	00					.byte	0
>aecb	03					.byte	3
>aecc	d2 ab f7				.byte	$d2,$ab,$f7
>aecf	0c					.byte	12
>aed0	4d					.byte	'M'
>aed1	70 aa					.word	L10071
>aed3	00					.byte	0
>aed4	06					.byte	6
>aed5	d2 ab f3 db d9 dd			.byte	$d2,$ab,$f3,$db,$d9,$dd
>aedb	09					.byte	9
>aedc	4d					.byte	'M'
>aedd	7c aa					.word	L10072
>aedf	00					.byte	0
>aee0	03					.byte	3
>aee1	d2 ab f3				.byte	$d2,$ab,$f3
>aee4	09					.byte	9
>aee5	4d					.byte	'M'
>aee6	83 aa					.word	L10073
>aee8	00					.byte	0
>aee9	03					.byte	3
>aeea	d2 ab ec				.byte	$d2,$ab,$ec
>aeed	09					.byte	9
>aeee	4d					.byte	'M'
>aeef	8f aa					.word	L10074
>aef1	00					.byte	0
>aef2	03					.byte	3
>aef3	d2 ab e9				.byte	$d2,$ab,$e9
>aef6	09					.byte	9
>aef7	4d					.byte	'M'
>aef8	99 aa					.word	L10075
>aefa	00					.byte	0
>aefb	03					.byte	3
>aefc	d2 ab e3				.byte	$d2,$ab,$e3
>aeff	09					.byte	9
>af00	4d					.byte	'M'
>af01	a1 aa					.word	L10076
>af03	00					.byte	0
>af04	03					.byte	3
>af05	d2 ab e2				.byte	$d2,$ab,$e2
>af08	09					.byte	9
>af09	4d					.byte	'M'
>af0a	a8 aa					.word	L10077
>af0c	00					.byte	0
>af0d	03					.byte	3
>af0e	d2 ab bf				.byte	$d2,$ab,$bf
>af11	09					.byte	9
>af12	4d					.byte	'M'
>af13	ae aa					.word	L10078
>af15	00					.byte	0
>af16	03					.byte	3
>af17	d2 a6 f7				.byte	$d2,$a6,$f7
>af1a	0c					.byte	12
>af1b	4d					.byte	'M'
>af1c	b7 aa					.word	L10079
>af1e	00					.byte	0
>af1f	06					.byte	6
>af20	d2 a6 f3 db d9 dd			.byte	$d2,$a6,$f3,$db,$d9,$dd
>af26	09					.byte	9
>af27	4d					.byte	'M'
>af28	c2 aa					.word	L10080
>af2a	00					.byte	0
>af2b	03					.byte	3
>af2c	d2 a6 f3				.byte	$d2,$a6,$f3
>af2f	09					.byte	9
>af30	4d					.byte	'M'
>af31	c7 aa					.word	L10081
>af33	00					.byte	0
>af34	03					.byte	3
>af35	d2 a6 ec				.byte	$d2,$a6,$ec
>af38	09					.byte	9
>af39	4d					.byte	'M'
>af3a	d2 aa					.word	L10082
>af3c	00					.byte	0
>af3d	03					.byte	3
>af3e	d2 a6 e9				.byte	$d2,$a6,$e9
>af41	09					.byte	9
>af42	4d					.byte	'M'
>af43	db aa					.word	L10083
>af45	00					.byte	0
>af46	03					.byte	3
>af47	d2 a6 e3				.byte	$d2,$a6,$e3
>af4a	09					.byte	9
>af4b	4d					.byte	'M'
>af4c	e1 aa					.word	L10084
>af4e	00					.byte	0
>af4f	03					.byte	3
>af50	d2 a6 e2				.byte	$d2,$a6,$e2
>af53	0a					.byte	10
>af54	4d					.byte	'M'
>af55	e6 aa					.word	L10085
>af57	00					.byte	0
>af58	04					.byte	4
>af59	50 52 4f c3				.byte	$50,$52,$4f,$c3
>af5d	0a					.byte	10
>af5e	4d					.byte	'M'
>af5f	e9 aa					.word	L10086
>af61	00					.byte	0
>af62	04					.byte	4
>af63	4e 45 58 d4				.byte	$4e,$45,$58,$d4
>af67	08					.byte	8
>af68	4d					.byte	'M'
>af69	ec aa					.word	L10087
>af6b	00					.byte	0
>af6c	02					.byte	2
>af6d	49 c6					.byte	$49,$c6
>af6f	0d					.byte	13
>af70	4d					.byte	'M'
>af71	ef aa					.word	L10088
>af73	00					.byte	0
>af74	07					.byte	7
>af75	45 4e 44 50 52 4f c3			.byte	$45,$4e,$44,$50,$52,$4f,$c3
>af7c	0b					.byte	11
>af7d	4d					.byte	'M'
>af7e	f2 aa					.word	L10089
>af80	00					.byte	0
>af81	05					.byte	5
>af82	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
>af87	0a					.byte	10
>af88	4d					.byte	'M'
>af89	f5 aa					.word	L10090
>af8b	00					.byte	0
>af8c	04					.byte	4
>af8d	45 4c 53 c5				.byte	$45,$4c,$53,$c5
>af91	09					.byte	9
>af92	4d					.byte	'M'
>af93	f8 aa					.word	L10091
>af95	00					.byte	0
>af96	03					.byte	3
>af97	43 d3 bf				.byte	$43,$d3,$bf
>af9a	09					.byte	9
>af9b	4d					.byte	'M'
>af9c	fc aa					.word	L10092
>af9e	00					.byte	0
>af9f	03					.byte	3
>afa0	43 c3 bf				.byte	$43,$c3,$bf
>afa3	0a					.byte	10
>afa4	4d					.byte	'M'
>afa5	00 ab					.word	L10093
>afa7	00					.byte	0
>afa8	04					.byte	4
>afa9	42 59 54 c5				.byte	$42,$59,$54,$c5
>afad	0b					.byte	11
>afae	4d					.byte	'M'
>afaf	03 ab					.word	L10094
>afb1	00					.byte	0
>afb2	05					.byte	5
>afb3	42 52 45 41 cb				.byte	$42,$52,$45,$41,$cb
>afb8	0c					.byte	12
>afb9	4d					.byte	'M'
>afba	05 ab					.word	L10095
>afbc	00					.byte	0
>afbd	06					.byte	6
>afbe	c1 f3 f3 db d9 dd			.byte	$c1,$f3,$f3,$db,$d9,$dd
>afc4	09					.byte	9
>afc5	4d					.byte	'M'
>afc6	08 ab					.word	L10096
>afc8	00					.byte	0
>afc9	03					.byte	3
>afca	c1 f3 f3				.byte	$c1,$f3,$f3
>afcd	09					.byte	9
>afce	4d					.byte	'M'
>afcf	0b ab					.word	L10097
>afd1	00					.byte	0
>afd2	03					.byte	3
>afd3	c1 e3 e3				.byte	$c1,$e3,$e3
>afd6	09					.byte	9
>afd7	4d					.byte	'M'
>afd8	0f ab					.word	L10098
>afda	00					.byte	0
>afdb	03					.byte	3
>afdc	c1 e2 e2				.byte	$c1,$e2,$e2
>afdf	0c					.byte	12
>afe0	4d					.byte	'M'
>afe1	12 ab					.word	L10099
>afe3	00					.byte	0
>afe4	06					.byte	6
>afe5	c1 bd f3 db d9 dd			.byte	$c1,$bd,$f3,$db,$d9,$dd
>afeb	09					.byte	9
>afec	4d					.byte	'M'
>afed	15 ab					.word	L10100
>afef	00					.byte	0
>aff0	03					.byte	3
>aff1	c1 bd f3				.byte	$c1,$bd,$f3
>aff4	09					.byte	9
>aff5	4d					.byte	'M'
>aff6	18 ab					.word	L10101
>aff8	00					.byte	0
>aff9	03					.byte	3
>affa	c1 bd e3				.byte	$c1,$bd,$e3
>affd	09					.byte	9
>affe	4d					.byte	'M'
>afff	1c ab					.word	L10102
>b001	00					.byte	0
>b002	03					.byte	3
>b003	c1 bd e2				.byte	$c1,$bd,$e2
>b006	09					.byte	9
>b007	4d					.byte	'M'
>b008	1f ab					.word	L10103
>b00a	00					.byte	0
>b00b	03					.byte	3
>b00c	c1 bd d9				.byte	$c1,$bd,$d9
>b00f	09					.byte	9
>b010	4d					.byte	'M'
>b011	21 ab					.word	L10104
>b013	00					.byte	0
>b014	03					.byte	3
>b015	c1 bd d2				.byte	$c1,$bd,$d2
>b018	09					.byte	9
>b019	4d					.byte	'M'
>b01a	22 ab					.word	L10105
>b01c	00					.byte	0
>b01d	03					.byte	3
>b01e	c1 bd bf				.byte	$c1,$bd,$bf
>b021	0a					.byte	10
>b022	4d					.byte	'M'
>b023	28 ab					.word	L10106
>b025	00					.byte	0
>b026	04					.byte	4
>b027	c1 bc be bf				.byte	$c1,$bc,$be,$bf
>b02b	0c					.byte	12
>b02c	4d					.byte	'M'
>b02d	2e ab					.word	L10107
>b02f	00					.byte	0
>b030	06					.byte	6
>b031	c1 ba f3 db d9 dd			.byte	$c1,$ba,$f3,$db,$d9,$dd
>b037	09					.byte	9
>b038	4d					.byte	'M'
>b039	31 ab					.word	L10108
>b03b	00					.byte	0
>b03c	03					.byte	3
>b03d	c1 ba f3				.byte	$c1,$ba,$f3
>b040	09					.byte	9
>b041	4d					.byte	'M'
>b042	34 ab					.word	L10109
>b044	00					.byte	0
>b045	03					.byte	3
>b046	c1 ba e3				.byte	$c1,$ba,$e3
>b049	09					.byte	9
>b04a	4d					.byte	'M'
>b04b	38 ab					.word	L10110
>b04d	00					.byte	0
>b04e	03					.byte	3
>b04f	c1 ba e2				.byte	$c1,$ba,$e2
>b052	0b					.byte	11
>b053	4d					.byte	'M'
>b054	3b ab					.word	L10111
>b056	00					.byte	0
>b057	05					.byte	5
>b058	41 2e 46 4f d2				.byte	$41,$2e,$46,$4f,$d2
>b05d	0c					.byte	12
>b05e	4d					.byte	'M'
>b05f	3e ab					.word	L10112
>b061	00					.byte	0
>b062	06					.byte	6
>b063	c1 ad f3 db d9 dd			.byte	$c1,$ad,$f3,$db,$d9,$dd
>b069	09					.byte	9
>b06a	4d					.byte	'M'
>b06b	42 ab					.word	L10113
>b06d	00					.byte	0
>b06e	03					.byte	3
>b06f	c1 ad f3				.byte	$c1,$ad,$f3
>b072	09					.byte	9
>b073	4d					.byte	'M'
>b074	46 ab					.word	L10114
>b076	00					.byte	0
>b077	03					.byte	3
>b078	c1 ad e3				.byte	$c1,$ad,$e3
>b07b	09					.byte	9
>b07c	4d					.byte	'M'
>b07d	4b ab					.word	L10115
>b07f	00					.byte	0
>b080	03					.byte	3
>b081	c1 ad e2				.byte	$c1,$ad,$e2
>b084	09					.byte	9
>b085	4d					.byte	'M'
>b086	4f ab					.word	L10116
>b088	00					.byte	0
>b089	03					.byte	3
>b08a	c1 ad bf				.byte	$c1,$ad,$bf
>b08d	0a					.byte	10
>b08e	4d					.byte	'M'
>b08f	55 ab					.word	L10117
>b091	00					.byte	0
>b092	04					.byte	4
>b093	c1 ad be d3				.byte	$c1,$ad,$be,$d3
>b097	0c					.byte	12
>b098	4d					.byte	'M'
>b099	57 ab					.word	L10118
>b09b	00					.byte	0
>b09c	06					.byte	6
>b09d	c1 ab f3 db d9 dd			.byte	$c1,$ab,$f3,$db,$d9,$dd
>b0a3	09					.byte	9
>b0a4	4d					.byte	'M'
>b0a5	5b ab					.word	L10119
>b0a7	00					.byte	0
>b0a8	03					.byte	3
>b0a9	c1 ab f3				.byte	$c1,$ab,$f3
>b0ac	09					.byte	9
>b0ad	4d					.byte	'M'
>b0ae	5f ab					.word	L10120
>b0b0	00					.byte	0
>b0b1	03					.byte	3
>b0b2	c1 ab e3				.byte	$c1,$ab,$e3
>b0b5	09					.byte	9
>b0b6	4d					.byte	'M'
>b0b7	64 ab					.word	L10121
>b0b9	00					.byte	0
>b0ba	03					.byte	3
>b0bb	c1 ab e2				.byte	$c1,$ab,$e2
>b0be	09					.byte	9
>b0bf	4d					.byte	'M'
>b0c0	68 ab					.word	L10122
>b0c2	00					.byte	0
>b0c3	03					.byte	3
>b0c4	c1 ab bf				.byte	$c1,$ab,$bf
>b0c7	0c					.byte	12
>b0c8	4d					.byte	'M'
>b0c9	6e ab					.word	L10123
>b0cb	00					.byte	0
>b0cc	06					.byte	6
>b0cd	c1 a6 f3 db d9 dd			.byte	$c1,$a6,$f3,$db,$d9,$dd
>b0d3	09					.byte	9
>b0d4	4d					.byte	'M'
>b0d5	71 ab					.word	L10124
>b0d7	00					.byte	0
>b0d8	03					.byte	3
>b0d9	c1 a6 f3				.byte	$c1,$a6,$f3
>b0dc	09					.byte	9
>b0dd	4d					.byte	'M'
>b0de	74 ab					.word	L10125
>b0e0	00					.byte	0
>b0e1	03					.byte	3
>b0e2	c1 a6 e3				.byte	$c1,$a6,$e3
>b0e5	09					.byte	9
>b0e6	4d					.byte	'M'
>b0e7	78 ab					.word	L10126
>b0e9	00					.byte	0
>b0ea	03					.byte	3
>b0eb	c1 a6 e2				.byte	$c1,$a6,$e2
>b0ee	09					.byte	9
>b0ef	4d					.byte	'M'
>b0f0	7b ab					.word	L10127
>b0f2	00					.byte	0
>b0f3	03					.byte	3
>b0f4	be be f3				.byte	$be,$be,$f3
>b0f7	09					.byte	9
>b0f8	4d					.byte	'M'
>b0f9	7e ab					.word	L10128
>b0fb	00					.byte	0
>b0fc	03					.byte	3
>b0fd	be be ec				.byte	$be,$be,$ec
>b100	09					.byte	9
>b101	4d					.byte	'M'
>b102	85 ab					.word	L10129
>b104	00					.byte	0
>b105	03					.byte	3
>b106	be be e9				.byte	$be,$be,$e9
>b109	09					.byte	9
>b10a	4d					.byte	'M'
>b10b	8a ab					.word	L10130
>b10d	00					.byte	0
>b10e	03					.byte	3
>b10f	be be e3				.byte	$be,$be,$e3
>b112	09					.byte	9
>b113	4d					.byte	'M'
>b114	8e ab					.word	L10131
>b116	00					.byte	0
>b117	03					.byte	3
>b118	be be d2				.byte	$be,$be,$d2
>b11b	09					.byte	9
>b11c	4d					.byte	'M'
>b11d	95 ab					.word	L10132
>b11f	00					.byte	0
>b120	03					.byte	3
>b121	be be c1				.byte	$be,$be,$c1
>b124	09					.byte	9
>b125	4d					.byte	'M'
>b126	97 ab					.word	L10133
>b128	00					.byte	0
>b129	03					.byte	3
>b12a	bc bc f3				.byte	$bc,$bc,$f3
>b12d	09					.byte	9
>b12e	4d					.byte	'M'
>b12f	9a ab					.word	L10134
>b131	00					.byte	0
>b132	03					.byte	3
>b133	bc bc ec				.byte	$bc,$bc,$ec
>b136	09					.byte	9
>b137	4d					.byte	'M'
>b138	a1 ab					.word	L10135
>b13a	00					.byte	0
>b13b	03					.byte	3
>b13c	bc bc e9				.byte	$bc,$bc,$e9
>b13f	09					.byte	9
>b140	4d					.byte	'M'
>b141	a6 ab					.word	L10136
>b143	00					.byte	0
>b144	03					.byte	3
>b145	bc bc e3				.byte	$bc,$bc,$e3
>b148	09					.byte	9
>b149	4d					.byte	'M'
>b14a	aa ab					.word	L10137
>b14c	00					.byte	0
>b14d	03					.byte	3
>b14e	bc bc d2				.byte	$bc,$bc,$d2
>b151	09					.byte	9
>b152	4d					.byte	'M'
>b153	b1 ab					.word	L10138
>b155	00					.byte	0
>b156	03					.byte	3
>b157	bc bc c1				.byte	$bc,$bc,$c1
>b15a	0b					.byte	11
>b15b	4d					.byte	'M'
>b15c	b3 ab					.word	L10139
>b15e	00					.byte	0
>b15f	05					.byte	5
>b160	ad 52 50 48 c1				.byte	$ad,$52,$50,$48,$c1
>b165	08					.byte	8
>b166	4d					.byte	'M'
>b167	bf ab					.word	L10140
>b169	00					.byte	0
>b16a	02					.byte	2
>b16b	ad c1					.byte	$ad,$c1
>b16d	09					.byte	9
>b16e	4d					.byte	'M'
>b16f	c3 ab					.word	L10141
>b171	00					.byte	0
>b172	03					.byte	3
>b173	ad ad f3				.byte	$ad,$ad,$f3
>b176	09					.byte	9
>b177	4d					.byte	'M'
>b178	c6 ab					.word	L10142
>b17a	00					.byte	0
>b17b	03					.byte	3
>b17c	ad ad ec				.byte	$ad,$ad,$ec
>b17f	09					.byte	9
>b180	4d					.byte	'M'
>b181	d4 ab					.word	L10143
>b183	00					.byte	0
>b184	03					.byte	3
>b185	ad ad e9				.byte	$ad,$ad,$e9
>b188	09					.byte	9
>b189	4d					.byte	'M'
>b18a	df ab					.word	L10144
>b18c	00					.byte	0
>b18d	03					.byte	3
>b18e	ad ad e3				.byte	$ad,$ad,$e3
>b191	09					.byte	9
>b192	4d					.byte	'M'
>b193	e3 ab					.word	L10145
>b195	00					.byte	0
>b196	03					.byte	3
>b197	ad ad d9				.byte	$ad,$ad,$d9
>b19a	09					.byte	9
>b19b	4d					.byte	'M'
>b19c	e5 ab					.word	L10146
>b19e	00					.byte	0
>b19f	03					.byte	3
>b1a0	ad ad d2				.byte	$ad,$ad,$d2
>b1a3	09					.byte	9
>b1a4	4d					.byte	'M'
>b1a5	ec ab					.word	L10147
>b1a7	00					.byte	0
>b1a8	03					.byte	3
>b1a9	ad ad c1				.byte	$ad,$ad,$c1
>b1ac	09					.byte	9
>b1ad	4d					.byte	'M'
>b1ae	ee ab					.word	L10148
>b1b0	00					.byte	0
>b1b1	03					.byte	3
>b1b2	ab ab f3				.byte	$ab,$ab,$f3
>b1b5	09					.byte	9
>b1b6	4d					.byte	'M'
>b1b7	f1 ab					.word	L10149
>b1b9	00					.byte	0
>b1ba	03					.byte	3
>b1bb	ab ab ec				.byte	$ab,$ab,$ec
>b1be	09					.byte	9
>b1bf	4d					.byte	'M'
>b1c0	fa ab					.word	L10150
>b1c2	00					.byte	0
>b1c3	03					.byte	3
>b1c4	ab ab e9				.byte	$ab,$ab,$e9
>b1c7	09					.byte	9
>b1c8	4d					.byte	'M'
>b1c9	01 ac					.word	L10151
>b1cb	00					.byte	0
>b1cc	03					.byte	3
>b1cd	ab ab e3				.byte	$ab,$ab,$e3
>b1d0	09					.byte	9
>b1d1	4d					.byte	'M'
>b1d2	05 ac					.word	L10152
>b1d4	00					.byte	0
>b1d5	03					.byte	3
>b1d6	ab ab d9				.byte	$ab,$ab,$d9
>b1d9	09					.byte	9
>b1da	4d					.byte	'M'
>b1db	07 ac					.word	L10153
>b1dd	00					.byte	0
>b1de	03					.byte	3
>b1df	ab ab d2				.byte	$ab,$ab,$d2
>b1e2	09					.byte	9
>b1e3	4d					.byte	'M'
>b1e4	0c ac					.word	L10154
>b1e6	00					.byte	0
>b1e7	03					.byte	3
>b1e8	ab ab c1				.byte	$ab,$ab,$c1
>b1eb	00					.byte	$00

;******  Return to file: main.asm


;******  Processing file: utility/loadcode.asm

.b1ec					LoadBasicCode:
.b1ec	a9 1b		lda #$1b			lda 	#(LBCTest) & $FF
.b1ee	85 0a		sta $0a				sta 	zTemp0
.b1f0	a9 b2		lda #$b2			lda 	#(LBCTest) >> 8
.b1f2	85 0b		sta $0b				sta 	zTemp0+1
.b1f4	a9 01		lda #$01			lda 	#($801) & $FF
.b1f6	85 0c		sta $0c				sta 	zTemp1
.b1f8	a9 08		lda #$08			lda 	#($801) >> 8
.b1fa	85 0d		sta $0d				sta 	zTemp1+1
.b1fc					_LBCCopy:
.b1fc	a0 02		ldy #$02			ldy 	#2							; skip over the loading address
.b1fe	b1 0a		lda ($0a),y			lda 	(zTemp0),y 					; skips first two bytes :)
.b200	92 0c		sta ($0c)			sta 	(zTemp1)
.b202	e6 0a		inc $0a				inc 	zTemp0
.b204	d0 02		bne $b208			bne 	_NoCarry
.b206	e6 0b		inc $0b				inc 	zTemp0+1
.b208					_NoCarry:
.b208	e6 0c		inc $0c				inc 	zTemp1
.b20a	d0 02		bne $b20e			bne 	_NoCarry
.b20c	e6 0d		inc $0d				inc 	zTemp1+1
.b20e					_NoCarry:
.b20e	a5 0a		lda $0a				lda 	zTemp0
.b210	c9 bf		cmp #$bf			cmp 	#LBCTestEnd & $FF
.b212	d0 e8		bne $b1fc			bne 	_LBCCopy
.b214	a5 0b		lda $0b				lda 	zTemp0+1
.b216	c9 b8		cmp #$b8			cmp 	#LBCTestEnd >> 8
.b218	d0 e2		bne $b1fc			bne 	_LBCCopy
.b21a	60		rts				rts
.b21b					LBCTest:
>b21b	01 08 0c 08 e8 03 99 c7				.binary 	"../generated/test.prg"
>b223	28 31 34 29 00 17 08 f2 03 9e 34 30 39 36 30 00
>b233	32 08 fc 03 8f 2e 20 57 4f 52 44 20 56 45 52 41
>b243	2e 4c 4f 57 40 24 39 46 32 30 00 4e 08 06 04 8f
>b253	2e 20 42 59 54 45 20 56 45 52 41 2e 48 49 47 48
>b263	40 24 39 46 32 32 00 6a 08 10 04 8f 2e 20 42 59
>b273	54 45 20 56 45 52 41 2e 44 41 54 41 40 24 39 46
>b283	32 33 00 83 08 1a 04 8f 2e 20 57 4f 52 44 20 2e
>b293	53 50 52 49 54 45 2e 42 41 53 45 00 9c 08 24 04
>b2a3	8f 2e 20 42 59 54 45 20 2e 53 50 52 49 54 45 2e
>b2b3	4d 4f 44 45 00 b3 08 2e 04 8f 2e 20 50 52 4f 43
>b2c3	20 56 45 52 41 2e 53 45 54 28 29 00 c7 08 38 04
>b2d3	8f 2e 20 56 45 52 41 2e 4c 4f 57 20 3d 20 52 00
>b2e3	ea 08 42 04 8f 2e 20 41 3d 59 20 41 26 24 30 46
>b2f3	20 41 3a 24 31 30 20 56 45 52 41 2e 48 49 47 48
>b303	3d 41 00 f9 08 4c 04 8f 2e 20 45 4e 44 50 52 4f
>b313	43 00 14 09 56 04 8f 2e 20 50 52 4f 43 20 56 45
>b323	52 41 2e 50 41 4c 45 54 54 45 28 29 00 22 09 60
>b333	04 8f 2e 20 52 41 59 2d 3e 53 00 4f 09 6a 04 8f
>b343	2e 20 52 2d 3e 53 20 52 3d 59 20 3c 3c 52 20 52
>b353	3a 24 31 30 30 30 20 59 3d 24 30 46 20 56 45 52
>b363	41 2e 53 45 54 28 29 00 7a 09 74 04 8f 2e 20 53
>b373	2d 3e 52 20 56 45 52 41 2e 44 41 54 41 3d 41 20
>b383	52 2e 53 57 41 50 20 56 45 52 41 2e 44 41 54 41
>b393	3d 41 00 88 09 7e 04 8f 2e 20 53 2d 3e 52 41 59
>b3a3	00 97 09 88 04 8f 2e 20 45 4e 44 50 52 4f 43 00
>b3b3	b9 09 92 04 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b3c3	2e 53 50 52 49 54 45 53 2e 45 4e 41 42 4c 45 28
>b3d3	29 00 16 0a 9c 04 8f 2e 20 52 41 59 2d 3e 53 20
>b3e3	2e 53 50 52 49 54 45 2e 4d 4f 44 45 3d 59 20 52
>b3f3	3c 3e 3f 20 49 46 20 31 20 45 4e 44 49 46 20 41
>b403	2d 3e 53 20 56 45 52 41 2e 53 45 54 28 24 34 30
>b413	30 30 2c 24 46 29 20 53 2d 3e 41 20 56 45 52 41
>b423	2e 44 41 54 41 3d 41 20 53 2d 3e 52 41 59 00 25
>b433	0a a6 04 8f 2e 20 45 4e 44 50 52 4f 43 00 3f 0a
>b443	b0 04 8f 2e 20 50 52 4f 43 20 56 45 52 41 2e 53
>b453	45 4c 45 43 54 28 29 00 7d 0a ba 04 8f 2e 20 52
>b463	41 59 2d 3e 53 20 52 26 24 37 46 20 3c 3c 41 20
>b473	3c 3c 52 20 3c 3c 52 20 52 3a 24 35 30 30 30 20
>b483	2e 53 50 52 49 54 45 2e 42 41 53 45 3d 52 20 53
>b493	2d 3e 52 41 59 00 8c 0a c4 04 8f 2e 20 45 4e 44
>b4a3	50 52 4f 43 00 a7 0a ce 04 8f 2e 20 50 52 4f 43
>b4b3	20 2e 56 45 52 41 2e 41 43 43 45 53 53 28 29 00
>b4c3	d8 0a d8 04 8f 2e 20 59 2d 3e 53 20 52 2b 2e 53
>b4d3	50 52 49 54 45 2e 42 41 53 45 20 59 3d 24 30 46
>b4e3	20 56 45 52 41 2e 53 45 54 28 29 20 53 2d 3e 59
>b4f3	00 e7 0a e2 04 8f 2e 20 45 4e 44 50 52 4f 43 00
>b503	fc 0a ec 04 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b513	2e 58 28 29 00 4a 0b f6 04 8f 2e 20 52 41 59 2d
>b523	3e 53 20 52 2d 3e 53 20 2e 56 45 52 41 2e 41 43
>b533	43 45 53 53 28 32 29 20 53 2d 3e 52 20 56 45 52
>b543	41 2e 44 41 54 41 3d 41 20 52 2e 53 57 41 50 20
>b553	56 45 52 41 2e 44 41 54 41 3d 41 20 53 2d 3e 52
>b563	41 59 00 59 0b 00 05 8f 2e 20 45 4e 44 50 52 4f
>b573	43 00 6e 0b 0a 05 8f 2e 20 50 52 4f 43 20 56 45
>b583	52 41 2e 59 28 29 00 bc 0b 14 05 8f 2e 20 52 41
>b593	59 2d 3e 53 20 52 2d 3e 53 20 2e 56 45 52 41 2e
>b5a3	41 43 43 45 53 53 28 34 29 20 53 2d 3e 52 20 56
>b5b3	45 52 41 2e 44 41 54 41 3d 41 20 52 2e 53 57 41
>b5c3	50 20 56 45 52 41 2e 44 41 54 41 3d 41 20 53 2d
>b5d3	3e 52 41 59 00 cb 0b 1e 05 8f 2e 20 45 4e 44 50
>b5e3	52 4f 43 00 e5 0b 28 05 8f 2e 20 50 52 4f 43 20
>b5f3	56 45 52 41 2e 43 52 45 41 54 45 28 29 00 f3 0b
>b603	32 05 8f 2e 20 52 41 59 2d 3e 53 00 0f 0c 3c 05
>b613	8f 2e 20 3c 3c 41 20 3c 3c 41 20 3c 3c 41 20 3c
>b623	3c 41 20 41 2d 3e 53 00 4a 0c 46 05 8f 2e 20 2e
>b633	56 45 52 41 2e 41 43 43 45 53 53 28 36 29 20 41
>b643	20 3d 20 31 32 20 56 45 52 41 2e 44 41 54 41 3d
>b653	41 20 53 2d 3e 41 20 56 45 52 41 2e 44 41 54 41
>b663	3d 41 00 58 0c 50 05 8f 2e 20 53 2d 3e 52 41 59
>b673	00 67 0c 5a 05 8f 2e 20 45 4e 44 50 52 4f 43 00
>b683	82 0c 64 05 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b693	2e 47 52 41 50 48 49 43 28 29 00 90 0c 6e 05 8f
>b6a3	2e 20 52 41 59 2d 3e 53 00 b5 0c 78 05 8f 2e 20
>b6b3	3e 3e 52 20 52 2d 3e 53 20 52 2d 3e 53 20 2e 56
>b6c3	45 52 41 2e 41 43 43 45 53 53 28 30 29 00 cd 0c
>b6d3	82 05 8f 2e 20 53 2d 3e 52 20 56 45 52 41 2e 44
>b6e3	41 54 41 3d 41 00 01 0d 8c 05 8f 2e 20 53 2d 3e
>b6f3	52 20 52 2e 53 57 41 50 20 41 26 24 30 46 20 41
>b703	2b 2e 53 50 52 49 54 45 2e 4d 4f 44 45 20 56 45
>b713	52 41 2e 44 41 54 41 3d 41 00 0f 0d 96 05 8f 2e
>b723	20 53 2d 3e 52 41 59 00 1e 0d a0 05 8f 2e 20 45
>b733	4e 44 50 52 4f 43 00 31 0d aa 05 8f 2e 20 50 52
>b743	4f 43 20 4d 41 49 4e 28 29 00 4d 0d b4 05 8f 2e
>b753	20 56 45 52 41 2e 50 41 4c 45 54 54 45 28 24 46
>b763	38 30 2c 31 29 00 69 0d be 05 8f 2e 20 56 45 52
>b773	41 2e 50 41 4c 45 54 54 45 28 24 30 30 30 2c 36
>b783	29 00 8b 0d c8 05 8f 2e 20 56 45 52 41 2e 53 50
>b793	52 49 54 45 53 2e 45 4e 41 42 4c 45 28 31 2c 24
>b7a3	30 30 29 00 a6 0d d2 05 8f 2e 20 56 45 52 41 2e
>b7b3	53 45 54 28 24 34 30 30 30 2c 24 30 31 29 00 d1
>b7c3	0d dc 05 8f 2e 20 34 30 39 36 20 52 2e 46 4f 52
>b7d3	20 3e 3e 41 20 3e 3e 41 20 56 45 52 41 2e 44 41
>b7e3	54 41 3d 41 20 4e 45 58 54 00 e1 0d e6 05 8f 2e
>b7f3	20 31 32 20 41 2e 46 4f 52 00 ed 0d f0 05 8f 2e
>b803	20 52 2d 3e 53 00 02 0e fa 05 8f 2e 20 56 45 52
>b813	41 2e 53 45 4c 45 43 54 28 29 00 1a 0e 04 06 8f
>b823	2e 20 56 45 52 41 2e 43 52 45 41 54 45 28 24 30
>b833	41 29 00 35 0e 0e 06 8f 2e 20 56 45 52 41 2e 47
>b843	52 41 50 48 49 43 28 24 31 34 30 30 29 00 4d 0e
>b853	18 06 8f 2e 20 53 2d 3e 52 20 3c 3c 52 20 3c 3c
>b863	52 20 3c 3c 52 00 61 0e 22 06 8f 2e 20 56 45 52
>b873	41 2e 58 28 29 20 3c 3c 52 00 71 0e 2c 06 8f 2e
>b883	20 56 45 52 41 2e 59 28 29 00 7d 0e 36 06 8f 2e
>b893	20 4e 45 58 54 00 8c 0e 40 06 8f 2e 20 45 4e 44
>b8a3	50 52 4f 43 00 a1 0e 4a 06 8f 2e 20 52 45 4d 4f
>b8b3	56 45 2e 4c 4f 43 41 4c 53 00 00 00
.b8bf					LBCTestEnd:

;******  Return to file: main.asm

.b8bf					EndCode:

;******  End of listing

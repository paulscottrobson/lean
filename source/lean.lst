
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -Wall -q -c -o lean.prg -L lean.lst main.asm
; Fri Nov  1 16:12:41 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm

=$0801					ProgramStart = $0801 						; where source code starts.
=$b918					UserDictionary = EndCode 					; user dictionary
=$a000					CodeMemory = $A000 							; where object code goes.
=$01					CodePage = $01 								; page for code memory.
=$063f					AssemblerStack = $063F 						; compiler stack space.
=$0640					lineBuffer = $0640	 						; current line, match encoded.
=$0680					valueBuffer = $0680 						; buffer for associated values.
=$0700					VariableMemory = $0700 						; data memory allocaed from here
=$0700					BankCode = $0700 							; bank handling code goes here.
=64					LINEBUFFSIZE = 64
=128					VALBUFFSIZE = 128

;******  Processing file: data.asm

=$9f61					ramBank = $9F61 							; RAM Memory bank register.
>0010					scanPtr:	.word ?							; BASIC scan position.
>0012					aStackPtr:	.word ? 						; compiler stack.
>0014					dictPtr:	.word ? 						; dictionary pointer
>0016					genPtr:		.word ? 						; code generation pointer
>0018					varPtr: 	.word ?							; next free variable pointer.
>001a					zTemp0:		.word ? 						; temps.
>001c					zTemp1:		.word ?
>001e					zTemp2:		.word ?
>0020					zTemp3:		.word ?
>0022					lastCreate:	.word ? 						; last created dictionary word
>0024					codePtr:	.word ? 						; code pointer
>0026					codeBank:	.byte ?							; code bank
>0027					originalSP:			.byte ? 				; 6502 stack on entry.
>0028					lastDefine:			.fill 3 				; last defined word (addr/page)
>002b					lineNumber:			.word ? 				; current line number
>002d					identStart:			.byte ? 				; start offset of current identifier
>002e					dirLowByte:			.byte ?					; values returned from search
>002f					dirHighByte:		.byte ?
>0030					dirBank:			.byte ?
>0031					dirLength:			.byte ?
>0032					valueBufferPos:		.byte ? 				; position in value buffer.
>0033					genPos: 			.byte ? 				; position in line buffer, generation.
>0034					generateVar:		.word ? 				; variables used in set value
>0036					elementData:		.fill 3 				; data from matched constant/identifier
>0039					codeBackup:			.fill 3 				; backup code pointer.
>003c					varSize:			.byte ? 				; size of current variable.
>003d					matchCount:			.byte ? 				; successful line matches (for errors)
=$8f					REM_TOKEN = $8F 							; C64 REM Token
="*"					SCM_TOP = '*'								; top of stack marker.
="P"					SCM_PROC = 'P'								; procedure marker
="R"					SCM_REPEAT = 'R'							; repeat marker
="F"					SCM_FOR = 'F' 								; for marker (8 bit)
="G"					SCM_INTFOR = 'G'							; for marker (16 bit)
="I"					SCM_IF = 'I'								; if/else/endif marker.
=$60					CPU_RETURN = $60 							; RTS opcode.
=$48					CPU_PHA = $48 								; PHA
=$68					CPU_PLA = $68 								; PLA
=$3a					CPU_DECA = $3A 								; DEC A
=$d0					CPU_BNE = $D0								; BNE
=$80					CPU_BRA = $80								; BRA
=$20					CPU_JSR = $20 								; JSR
=$da					CPU_PHX = $DA 								; PHX
=$fa					CPU_PLX = $FA 								; PLX
=$c9					CPU_CMPIM = $C9 							; CMP#
=$e0					CPU_CPXIM = $E0 							; CPX#
=$ca					CPU_DEX = $CA 								; DEX

;******  Return to file: main.asm


;******  Processing file: generated/cgconst.inc

=$53					CGEN_C_ISZERO = $53
=$63					CGEN_C_LOW = $63
=$73					CGEN_C_HIGH = $73
=$83					CGEN_C_LOWPLUS1 = $83
=$93					CGEN_C_SETDATA = $93
=$a3					CGEN_C_EXEC = $a3

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.a000					Start:
.a000	4c 06 a0	jmp $a006			jmp 	RunCompiler
.a003	4c 3e a0	jmp $a03e			jmp 	CallCodeMemory
.a006					RunCompiler:
.a006	ba		tsx				tsx 									; save SP
.a007	86 27		stx $27				stx 	originalSP
.a009	a2 05		ldx #$05			ldx 	#5 								; set up vectors.
.a00b	bd 00 a0	lda $a000,x	_RCCopy:lda 	Start,x
.a00e	95 00		sta $00,x			sta 	$00,x
.a010	ca		dex				dex
.a011	10 f8		bpl $a00b			bpl 	_RCCopy
.a013	20 45 b2	jsr $b245			jsr 	LoadBasicCode
.a016	20 81 a3	jsr $a381			jsr 	BankCopyCode 					; copy banked code to RAM space.
.a019	20 d1 a8	jsr $a8d1			jsr 	StackReset 						; reset convert stack.
.a01c	20 15 a7	jsr $a715			jsr 	VariableReset 					; reset variable memory.
.a01f	20 f6 a3	jsr $a3f6			jsr 	DictionaryReset 				; reset user dictionary
.a022	20 6a a4	jsr $a46a			jsr 	CodeReset 						; reset code output.
.a025	20 4d a0	jsr $a04d			jsr 	ScannerReset 					; reset scanner
.a028					AsmLoop:
.a028	20 50 a0	jsr $a050			jsr 	ScannerFind 					; next thing in code
.a02b	90 08		bcc $a035			bcc 	AsmEnd 							; nothing more
.a02d	20 92 a0	jsr $a092			jsr 	ProcessLineToBuffer 			; convert it.
.a030	20 de a1	jsr $a1de			jsr 	GeneratorSearch 				; check it for generators
.a033	80 f3		bra $a028			bra 	AsmLoop 						; and keep going.
.a035					AsmEnd:
.a035	a9 2a		lda #$2a			lda 	#SCM_TOP 						; check structures are done
.a037	20 0a a9	jsr $a90a			jsr 	StackCheckStructureMarker
.a03a					ReturnCaller:
.a03a	a6 27		ldx $27				ldx		originalSP 						; restore XP and exit.
.a03c	9a		txs				txs
.a03d	60		rts				rts
.a03e					CallCodeMemory:
.a03e	a5 28		lda $28				lda 	lastDefine 					; check if something defined (no error)
.a040	05 29		ora $29				ora 	lastDefine+1
.a042	05 2a		ora $2a				ora 	lastDefine+2
.a044	f0 06		beq $a04c			beq 	_NoExecute
.a046	20 81 a3	jsr $a381			jsr 	BankCopyCode 				; copy banked code to RAM space.
.a049	4c 02 07	jmp $0702			jmp 	CodeRunCode
.a04c					_NoExecute:
.a04c	60		rts				rts

;******  Processing file: lean/scanner.asm

.a04d					ScannerReset:
.a04d	64 11		stz $11				stz 	scanPtr+1 					; zero MSB means the start
.a04f	60		rts				rts
.a050					ScannerFind:
.a050	48		pha				pha 								; save registers
.a051	da		phx				phx
.a052	5a		phy				phy
.a053	a5 11		lda $11				lda 	scanPtr+1 					; reset the scanner pointer ?
.a055	d0 0a		bne $a061			bne 	_SFScanForward 				; no, scan forward from current.
.a057	a9 01		lda #$01			lda 	#(ProgramStart) & $FF
.a059	85 10		sta $10				sta 	scanPtr
.a05b	a9 08		lda #$08			lda 	#(ProgramStart) >> 8
.a05d	85 11		sta $11				sta 	scanPtr+1
.a05f	80 12		bra $a073			bra 	_SFCheck 					; check if this one is a REM.
.a061					_SFScanForward:
.a061	a0 01		ldy #$01			ldy 	#1 							; check if the offset is zero
.a063	b2 10		lda ($10)			lda 	(scanPtr)
.a065	11 10		ora ($10),y			ora 	(scanPtr),y
.a067	18		clc				clc 								; if so exit with CC.
.a068	f0 24		beq $a08e			beq 	_SFExit
.a06a	b2 10		lda ($10)			lda 	(scanPtr) 					; forward to next.
.a06c	aa		tax				tax
.a06d	b1 10		lda ($10),y			lda 	(scanPtr),y
.a06f	86 10		stx $10				stx 	scanPtr
.a071	85 11		sta $11				sta 	scanPtr+1
.a073					_SFCheck:
.a073	a0 02		ldy #$02			ldy 	#2 								; copy line number.
.a075	b1 10		lda ($10),y			lda 	(scanPtr),y
.a077	85 2b		sta $2b				sta 	lineNumber
.a079	c8		iny				iny
.a07a	b1 10		lda ($10),y			lda 	(scanPtr),y
.a07c	85 2c		sta $2c				sta 	lineNumber+1
.a07e	c8		iny				iny
.a07f	b1 10		lda ($10),y			lda 	(scanPtr),y 				; is it a "REM." line ?
.a081	c9 8f		cmp #$8f			cmp 	#REM_TOKEN
.a083	d0 dc		bne $a061			bne 	_SFScanForward
.a085	c8		iny				iny
.a086	b1 10		lda ($10),y			lda 	(scanPtr),y 				; is it followed by a '.'
.a088	c8		iny				iny
.a089	c9 2e		cmp #$2e			cmp 	#"."
.a08b	d0 d4		bne $a061			bne 	_SFScanForward
.a08d	38		sec				sec 								; found something, exit with CS.
.a08e					_SFExit:
.a08e	7a		ply				ply 								; load registers and exit.
.a08f	fa		plx				plx
.a090	68		pla				pla
.a091	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: lean/process.asm

.a092					ProcessLineToBuffer:
.a092	a0 06		ldy #$06			ldy 	#6 							; position in line
.a094	a2 00		ldx #$00			ldx 	#0 							; position in buffer
.a096	64 32		stz $32				stz 	valueBufferPos 				; reset value buffer pos
.a098	a9 ff		lda #$ff			lda 	#$FF
.a09a	8d 80 06	sta $0680			sta 	valueBuffer 				; erase value buffer (end marker $FF)
.a09d					_PLTConvert:
.a09d	b1 10		lda ($10),y			lda 	(scanPtr),y 				; next character
.a09f	f0 7a		beq $a11b			beq 	_PLTExit
.a0a1	c8		iny				iny
.a0a2	c9 20		cmp #$20			cmp 	#' ' 						; skip over spaces.
.a0a4	f0 f7		beq $a09d			beq 	_PLTConvert
.a0a6	20 7f a1	jsr $a17f			jsr 	PLTCheckCharacter 			; identifier character.
.a0a9	b0 08		bcs $a0b3			bcs 	_PLTIsIdentifier 			; it's an identifier.
.a0ab	09 80		ora #$80			ora 	#$80 						; set bit 7
.a0ad	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write out
.a0b0	e8		inx				inx
.a0b1	80 ea		bra $a09d			bra 	_PLTConvert
.a0b3					_PLTIsIdentifier:
.a0b3	86 2d		stx $2d				stx 	identStart 					; save as start of identifier.
.a0b5					_PLTGetIdentifier:
.a0b5	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out.
.a0b8	e8		inx				inx
.a0b9	b1 10		lda ($10),y			lda 	(scanPtr),y	 				; get next character
.a0bb	c8		iny				iny
.a0bc	20 7f a1	jsr $a17f			jsr 	PLTCheckCharacter 			; still identifier
.a0bf	b0 f4		bcs $a0b5			bcs 	_PLTGetIdentifier
.a0c1	88		dey				dey 								; undo last bump.
.a0c2					_PLTGotIdentifier:
.a0c2	bd 3f 06	lda $063f,x			lda 	lineBuffer-1,x 				; set bit 7 of last
.a0c5	09 80		ora #$80			ora 	#$80
.a0c7	9d 3f 06	sta $063f,x			sta 	lineBuffer-1,x
.a0ca	5a		phy				phy
.a0cb	da		phx				phx
.a0cc	20 73 a1	jsr $a173			jsr 	PLTGetAddress 				; XY <= address of identifier.
.a0cf	20 05 a4	jsr $a405			jsr 	DictionarySearch 			; is it in the dictionaries ?
.a0d2	90 0c		bcc $a0e0			bcc 	_PLTTryConstant
.a0d4	c9 50		cmp #$50			cmp 	#"P" 						; procedure, short or var ?
.a0d6	f0 4b		beq $a123			beq 	_PLTFoundIdentifier
.a0d8	c9 53		cmp #$53			cmp 	#"S"
.a0da	f0 47		beq $a123			beq 	_PLTFoundIdentifier
.a0dc	c9 49		cmp #$49			cmp 	#"I"
.a0de	f0 43		beq $a123			beq 	_PLTFoundIdentifier
.a0e0					_PLTTryConstant:
.a0e0	20 73 a1	jsr $a173			jsr 	PLTGetAddress 				; try as a constant
.a0e3	20 41 a8	jsr $a841			jsr 	StringToInt
.a0e6	b0 04		bcs $a0ec			bcs 	_PLTAttachIdentifier
.a0e8	fa		plx				plx 								; leave as it is - unknown identifier
.a0e9	7a		ply				ply
.a0ea	80 b1		bra $a09d			bra 	_PLTConvert
.a0ec					_PLTAttachIdentifier:
.a0ec	86 1a		stx $1a				stx 	zTemp0 						; save XY
.a0ee	84 1b		sty $1b				sty 	zTemp0+1
.a0f0	fa		plx				plx 								; restore current position
.a0f1	7a		ply				ply
.a0f2	b1 10		lda ($10),y			lda 	(scanPtr),y 				; next character
.a0f4	c9 2d		cmp #$2d			cmp 	#"-"
.a0f6	d0 04		bne $a0fc			bne 	_PLTNotMinus
.a0f8	20 65 a1	jsr $a165			jsr 	_PLTNegateZTemp0 			; negate zTemp0
.a0fb	c8		iny				iny 								; skip it if '-'
.a0fc					_PLTNotMinus:
.a0fc	5a		phy				phy 								; save current positions
.a0fd	da		phx				phx
.a0fe	a6 1a		ldx $1a				ldx 	zTemp0 						; restore XY number
.a100	a4 1b		ldy $1b				ldy 	zTemp0+1
.a102	a9 00		lda #$00			lda 	#0
.a104	20 a3 a1	jsr $a1a3			jsr 	ProcessRecordData 			; record associated data
.a107	a9 62		lda #$62			lda 	#"b"
.a109	c0 00		cpy #$00			cpy 	#0
.a10b	f0 02		beq $a10f			beq 	_PLTRecord
.a10d	a9 77		lda #$77			lda 	#"w"
.a10f					_PLTRecord:
.a10f	fa		plx				plx 								; restore XY position
.a110	7a		ply				ply
.a111	a6 2d		ldx $2d				ldx 	identStart 					; overwrite the position with ident start
.a113	09 80		ora #$80			ora 	#$80 						; bit 7, it's an element in its own right
.a115	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out
.a118	e8		inx				inx 								; bump the position
.a119	80 82		bra $a09d			bra		_PLTConvert 				; do the next one.
.a11b					_PLTExit:
.a11b	9e 40 06	stz $0640,x			stz 	lineBuffer,x 				; make it ASCIIZ
.a11e	e0 40		cpx #$40			cpx		#LINEBUFFSIZE 				; line too long.
.a120	b0 31		bcs $a153			bcs 	_PLTBuffer
.a122	60		rts				rts
.a123					_PLTFoundIdentifier:
.a123	48		pha				pha 								; save type.
.a124	a6 2e		ldx $2e				ldx 	dirLowByte 					; get the dictionary AXY values
.a126	a4 2f		ldy $2f				ldy 	dirHighByte
.a128	a5 30		lda $30				lda 	dirBank
.a12a	20 a3 a1	jsr $a1a3			jsr 	ProcessRecordData 			; attached to identstart
.a12d	68		pla				pla 								; get type back, which is I or S or P
.a12e	09 20		ora #$20			ora 	#$20 						; make it lower case.
.a130	c9 70		cmp #$70			cmp 	#"p"						; P goes untrammelled
.a132	f0 db		beq $a10f			beq 	_PLTRecord
.a134	c0 00		cpy #$00			cpy 	#0 							; if Y = 0, e.g. zero page, use that.
.a136	f0 d7		beq $a10f			beq 	_PLTRecord
.a138	49 05		eor #$05			eor 	#"i"^"l" 					; convert it to L
.a13a	c9 6c		cmp #$6c			cmp 	#"l"
.a13c	f0 d1		beq $a10f			beq 	_PLTRecord
.a13e	a9 63		lda #$63			lda 	#"c" 						; otherwise C
.a140	80 cd		bra $a10f			bra 	_PLTRecord
.a142					_PLTError:
.a142	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a145	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX ?",$00
>a14d	54 41 58 20 3f 00
.a153					_PLTBuffer:
.a153	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a156	4c 45 41 4e 3a 4c 49 4e				.text 	"LEAN:","LINE SIZE",$00
>a15e	45 20 53 49 5a 45 00
.a165					_PLTNegateZTemp0:
.a165	38		sec				sec 								; negate zTemp0
.a166	a9 00		lda #$00			lda 	#0
.a168	e5 1a		sbc $1a				sbc 	zTemp0
.a16a	85 1a		sta $1a				sta 	zTemp0
.a16c	a9 00		lda #$00			lda 	#0
.a16e	e5 1b		sbc $1b				sbc 	zTemp0+1
.a170	85 1b		sta $1b				sta 	zTemp0+1
.a172	60		rts				rts
.a173					PLTGetAddress:
.a173	18		clc				clc
.a174	a5 2d		lda $2d				lda 	identStart
.a176	69 40		adc #$40			adc 	#lineBuffer & $FF
.a178	aa		tax				tax
.a179	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a17b	90 01		bcc $a17e			bcc 	_PLGANoCarry
.a17d	c8		iny				iny
.a17e					_PLGANoCarry:
.a17e	60		rts				rts
.a17f					PLTCheckCharacter:
.a17f	c9 25		cmp #$25			cmp 	#'%'
.a181	f0 1c		beq $a19f			beq 	_PLCCYes
.a183	c9 5f		cmp #$5f			cmp 	#'_'
.a185	f0 18		beq $a19f			beq 	_PLCCYes
.a187	c9 24		cmp #$24			cmp 	#'$'
.a189	f0 14		beq $a19f			beq 	_PLCCYes
.a18b	c9 2e		cmp #$2e			cmp 	#'.'
.a18d	f0 10		beq $a19f			beq 	_PLCCYes
.a18f	c9 30		cmp #$30			cmp 	#'0'
.a191	90 0e		bcc $a1a1			bcc 	_PLCCNo
.a193	c9 3a		cmp #$3a			cmp 	#'9'+1
.a195	90 08		bcc $a19f			bcc 	_PLCCYes
.a197	c9 41		cmp #$41			cmp 	#'A'
.a199	90 06		bcc $a1a1			bcc 	_PLCCNo
.a19b	c9 5b		cmp #$5b			cmp 	#'Z'+1
.a19d	b0 02		bcs $a1a1			bcs 	_PLCCNo
.a19f					_PLCCYes:
.a19f	38		sec				sec
.a1a0	60		rts				rts
.a1a1					_PLCCNo:
.a1a1	18		clc				clc
.a1a2	60		rts				rts
.a1a3					ProcessRecordData:
.a1a3	48		pha				pha
.a1a4	da		phx				phx
.a1a5	5a		phy				phy
.a1a6	da		phx				phx
.a1a7	a6 32		ldx $32				ldx 	valueBufferPos 				; get current position
.a1a9	9d 83 06	sta $0683,x			sta 	valueBuffer+3,x 			; copy data to it
.a1ac	98		tya				tya
.a1ad	9d 82 06	sta $0682,x			sta 	valueBuffer+2,x
.a1b0	68		pla				pla
.a1b1	9d 81 06	sta $0681,x			sta 	valueBuffer+1,x
.a1b4	a5 2d		lda $2d				lda 	identStart
.a1b6	9d 80 06	sta $0680,x			sta 	valueBuffer+0,x
.a1b9	e8		inx				inx 								; next position
.a1ba	e8		inx				inx
.a1bb	e8		inx				inx
.a1bc	e8		inx				inx
.a1bd	86 32		stx $32				stx 	valueBufferPos 				; save
.a1bf	a9 ff		lda #$ff			lda 	#$FF 						; write end marker.
.a1c1	9d 80 06	sta $0680,x			sta 	valueBuffer,x
.a1c4	e0 80		cpx #$80			cpx 	#VALBUFFSIZE
.a1c6	b0 04		bcs $a1cc			bcs 	_PRDError
.a1c8	7a		ply				ply
.a1c9	fa		plx				plx
.a1ca	68		pla				pla
.a1cb	60		rts				rts
.a1cc					_PRDError:
.a1cc	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a1cf	4c 45 41 4e 3a 43 4f 4d				.text 	"LEAN:","COMPLEX ?",$00
>a1d7	50 4c 45 58 20 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/generate.asm

.a1de					GeneratorSearch:
.a1de	64 33		stz $33				stz 	genPos 						; reset the generator pointer
.a1e0	64 3d		stz $3d				stz 	matchCount 					; reset the match count.
.a1e2					_GSNextItem:
.a1e2	a6 33		ldx $33				ldx 	genPos 						; check end ?
.a1e4	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a1e7	f0 07		beq $a1f0			beq 	_GSExit
.a1e9	20 f1 a1	jsr $a1f1			jsr 	GenerateOne 				; do one match
.a1ec	e6 3d		inc $3d				inc 	matchCount 					; bump the count.
.a1ee	80 f2		bra $a1e2			bra 	_GSNextItem
.a1f0					_GSExit:
.a1f0	60		rts				rts
.a1f1					GenerateOne:
.a1f1	a5 33		lda $33				lda 	genPos 						; point XY to the next thing
.a1f3	18		clc				clc 								; the actual address in the line buffer.
.a1f4	69 40		adc #$40			adc 	#lineBuffer & $FF
.a1f6	aa		tax				tax
.a1f7	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a1f9	90 01		bcc $a1fc			bcc 	_GSNoCarry
.a1fb	c8		iny				iny
.a1fc					_GSNoCarry:
.a1fc	20 02 a4	jsr $a402			jsr 	DictionarySearchSystemOnly 	; dictionary search
.a1ff	b0 10		bcs $a211			bcs 	_GSFound
.a201					_GSError:
.a201	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a204	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX?",$00
>a20c	54 41 58 3f 00
.a211					_GSFound:
.a211	c9 4d		cmp #$4d			cmp 	#"M"						; check it's a match.
.a213	d0 ec		bne $a201			bne 	_GSError
.a215	a4 31		ldy $31				ldy 	dirLength 					; advance to next
.a217	a6 33		ldx $33				ldx 	genPos 						; checking for a-z.
.a219					_GSCheckData:
.a219	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a21c	29 7f		and #$7f			and 	#$7F
.a21e	c9 61		cmp #$61			cmp 	#'a'
.a220	90 08		bcc $a22a			bcc 	_GSNotLC
.a222	c9 7b		cmp #$7b			cmp 	#'z'+1
.a224	b0 04		bcs $a22a			bcs 	_GSNotLC
.a226	8a		txa				txa
.a227	20 ad a2	jsr $a2ad			jsr 	GenCopyData
.a22a					_GSNotLC:
.a22a	e8		inx				inx
.a22b	88		dey				dey
.a22c	d0 eb		bne $a219			bne 	_GSCheckData
.a22e	86 33		stx $33				stx 	genPos
.a230	a5 2e		lda $2e				lda 	dirLowByte					; copy address to genPtr
.a232	85 16		sta $16				sta 	genPtr
.a234	a5 2f		lda $2f				lda 	dirHighByte
.a236	85 17		sta $17				sta 	genPtr+1
.a238	b2 16		lda ($16)			lda 	(genPtr)					; count in A
.a23a	f0 25		beq $a261			beq 	_GSNext 					; nothing !
.a23c	aa		tax				tax 								; X is count
.a23d	a0 01		ldy #$01			ldy 	#1
.a23f					_GSGenerate:
.a23f	b1 16		lda ($16),y			lda 	(genPtr),y 					; execute something
.a241	c9 a3		cmp #$a3			cmp 	#CGEN_C_EXEC
.a243	f0 1d		beq $a262			beq 	_GSExecute
.a245	c9 93		cmp #$93			cmp 	#CGEN_C_SETDATA 			; set data ?
.a247	d0 0e		bne $a257			bne 	_GSCopy
.a249	c8		iny				iny									; copy next two bytes out.
.a24a	b1 16		lda ($16),y			lda 	(genPtr),y
.a24c	85 34		sta $34				sta 	generateVar
.a24e	c8		iny				iny
.a24f	b1 16		lda ($16),y			lda 	(genPtr),y
.a251	85 35		sta $35				sta 	generateVar+1
.a253	ca		dex				dex
.a254	ca		dex				dex
.a255	80 06		bra $a25d			bra 	_GSContinue
.a257					_GSCopy:
.a257	20 7e a2	jsr $a27e			jsr 	GenConvertByte 				; replace bytes
.a25a	20 00 07	jsr $0700			jsr 	CodeWriteByte				; write out.
.a25d					_GSContinue:
.a25d	c8		iny				iny
.a25e	ca		dex				dex
.a25f	d0 de		bne $a23f			bne 	_GSGenerate
.a261					_GSNext:
.a261	60		rts				rts
.a262					_GSExecute:
.a262	c8		iny				iny 								; grab one.
.a263	ca		dex				dex
.a264	da		phx				phx 								; save XY
.a265	5a		phy				phy
.a266	b1 16		lda ($16),y			lda 	(genPtr),y 					; read the execution ID
.a268	0a		asl a				asl 	a 							; index into table.
.a269	aa		tax				tax
.a26a	bd 67 ac	lda $ac67,x			lda 	ExecutableVectorTable,x 	; read jump vector
.a26d	85 1a		sta $1a				sta 	zTemp0
.a26f	bd 68 ac	lda $ac68,x			lda 	ExecutableVectorTable+1,x
.a272	85 1b		sta $1b				sta 	zTemp0+1
.a274	20 7b a2	jsr $a27b			jsr 	_GSCallzTemp0 				; call routine
.a277	7a		ply				ply 								; restore XY
.a278	fa		plx				plx
.a279	80 e2		bra $a25d			bra 	_GSContinue
.a27b					_GSCallzTemp0:
.a27b	6c 1a 00	jmp ($001a)			jmp 	(zTemp0)
.a27e					GenConvertByte:
.a27e	c9 63		cmp #$63			cmp 	#CGEN_C_LOW
.a280	f0 09		beq $a28b			beq 	_GCBLowByte
.a282	c9 83		cmp #$83			cmp 	#CGEN_C_LOWPLUS1
.a284	f0 08		beq $a28e			beq 	_GCBLowBytePlus1
.a286	c9 73		cmp #$73			cmp 	#CGEN_C_HIGH
.a288	f0 0a		beq $a294			beq 	_GCBHighByte
.a28a	60		rts				rts
.a28b					_GCBLowByte:
.a28b	a5 36		lda $36				lda 	elementData
.a28d	60		rts				rts
.a28e					_GCBLowBytePlus1:
.a28e	a5 36		lda $36				lda 	elementData
.a290	1a		inc a				inc 	a
.a291	f0 04		beq $a297			beq 	_GCBSystem
.a293	60		rts				rts
.a294					_GCBHighByte:
.a294	a5 37		lda $37				lda 	elementData+1
.a296	60		rts				rts
.a297					_GCBSystem:
.a297	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a29a	4c 45 41 4e 3a 57 4f 52				.text 	"LEAN:","WORD OFF PAGE",$00
>a2a2	44 20 4f 46 46 20 50 41 47 45 00
.a2ad					GenCopyData:
.a2ad	48		pha				pha
.a2ae	da		phx				phx
.a2af	5a		phy				phy
.a2b0	85 1a		sta $1a				sta 	zTemp0
.a2b2	a2 fc		ldx #$fc			ldx 	#256-4
.a2b4					_GCDLoop:
.a2b4	e8		inx				inx 								; next slot
.a2b5	e8		inx				inx
.a2b6	e8		inx				inx
.a2b7	e8		inx				inx
.a2b8	bd 80 06	lda $0680,x			lda 	valueBuffer,x 				; next in value buffer
.a2bb	c9 ff		cmp #$ff			cmp 	#$FF
.a2bd	f0 16		beq $a2d5			beq 	_GCDError 					; system ?
.a2bf	c5 1a		cmp $1a				cmp 	zTemp0 						; match.
.a2c1	d0 f1		bne $a2b4			bne 	_GCDLoop
.a2c3	a0 00		ldy #$00			ldy 	#0 							; copy assoc data back
.a2c5					_GCDCopy:
.a2c5	bd 81 06	lda $0681,x			lda 	valueBuffer+1,x
.a2c8	99 36 00	sta $0036,y			sta 	elementData,y
.a2cb	e8		inx				inx
.a2cc	c8		iny				iny
.a2cd	c0 03		cpy #$03			cpy 	#3
.a2cf	d0 f4		bne $a2c5			bne 	_GCDCopy
.a2d1	7a		ply				ply
.a2d2	fa		plx				plx
.a2d3	68		pla				pla
.a2d4	60		rts				rts
.a2d5					_GCDError:
.a2d5	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a2d8	4c 45 41 4e 3a 53 59 53				.text 	"LEAN:","SYS0?",$00
>a2e0	30 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/extract.asm

.a2e3					EGetUnknownIdentifier:
.a2e3	a6 33		ldx $33				ldx 	genPos 						; get next character
.a2e5	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2e8	29 7f		and #$7f			and 	#$7F
.a2ea	20 7f a1	jsr $a17f			jsr 	PLTCheckCharacter 			; is it an identifier ?
.a2ed	90 15		bcc $a304			bcc 	_EUIError 					; no
.a2ef	da		phx				phx 								; save start position on stack.
.a2f0					_EGetFindEnd:
.a2f0	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2f3	e8		inx				inx
.a2f4	0a		asl a				asl 	a
.a2f5	90 f9		bcc $a2f0			bcc 	_EGetFindEnd
.a2f7	86 33		stx $33				stx 	genPos 						; points to the next thing.
.a2f9	68		pla				pla 								; offset
.a2fa	a0 06		ldy #$06			ldy 	#lineBuffer >> 8 			; make address in YX
.a2fc	18		clc				clc
.a2fd	69 40		adc #$40			adc 	#lineBuffer & $FF
.a2ff	aa		tax				tax
.a300	90 01		bcc $a303			bcc 	_EGetNoCarry
.a302	c8		iny				iny
.a303					_EGetNoCarry:
.a303	60		rts				rts
.a304					_EUIError:
.a304	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a307	4c 45 41 4e 3a 49 44 45				.text 	"LEAN:","IDENTIFIER ?",$00
>a30f	4e 54 49 46 49 45 52 20 3f 00
.a319					EGetSyntaxCheck:
.a319	48		pha				pha
.a31a	da		phx				phx
.a31b	a6 33		ldx $33				ldx 	genPos 						; position of next
.a31d	5d 40 06	eor $0640,x			eor 	lineBuffer,x 				; bits 0-6 will be zero if match
.a320	29 7f		and #$7f			and 	#$7F
.a322	d0 05		bne $a329			bne 	_EGSFail 					; different
.a324	e6 33		inc $33				inc 	genPos 						; skip it and exit
.a326	fa		plx				plx
.a327	68		pla				pla
.a328	60		rts				rts
.a329					_EGSFail:
.a329	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a32c	4c 45 41 4e 3a 4d 49 53				.text 	"LEAN:","MISSING ?",$00
>a334	53 49 4e 47 20 3f 00
.a33b					EGLookNext:
.a33b	da		phx				phx
.a33c	a6 33		ldx $33				ldx 	genPos 						; position of next
.a33e	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a341	fa		plx				plx
.a342	60		rts				rts
.a343					EGSkipNext:
.a343	e6 33		inc $33				inc 	genPos
.a345	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: bank/banking.asm

.a346					BANKEDStart:
=$0700					CodeWriteByte = BankCode
=1794					CodeRunCode = Bankcode+2
.a346	80 21		bra $a369			bra 	BankedCodeWriteByte
.a348	80 00		bra $a34a			bra 	BankedCodeRun
.a34a					BankedCodeRun:
.a34a	ad 61 9f	lda $9f61			lda 	ramBank 					; save current RAM bank
.a34d	48		pha				pha
.a34e	a5 2a		lda $2a				lda 	lastDefine+2 				; set page number
.a350	8d 61 9f	sta $9f61			sta 	ramBank
.a353	a5 28		lda $28				lda 	lastDefine 					; overwrite the call address
.a355	8d 1c 07	sta $071c			sta 	_BCRCode-BANKEDStart+BankCode+1
.a358	a5 29		lda $29				lda 	lastDefine+1
.a35a	8d 1d 07	sta $071d			sta 	_BCRCode-BANKEDStart+BankCode+2
.a35d	a5 24		lda $24				lda 	codePtr						; pass in byte after code.
.a35f	a6 25		ldx $25				ldx 	codePtr+1
.a361					_BCRCode:
.a361	20 00 00	jsr $0000			jsr 	$0000 						; call the code
.a364	68		pla				pla 								; restore RAM page.
.a365	8d 61 9f	sta $9f61			sta 	ramBank
.a368	60		rts				rts
.a369					BankedCodeWriteByte:
.a369	da		phx				phx 								; save XY
.a36a	5a		phy				phy
.a36b	ae 61 9f	ldx $9f61			ldx 	ramBank  					; save old RAM Bank# in X
.a36e	a4 26		ldy $26				ldy 	codeBank 					; get code RAM bank and save code there.
.a370	8c 61 9f	sty $9f61			sty 	ramBank
.a373	92 24		sta ($24)			sta 	(codePtr) 					; save byte out
.a375	e6 24		inc $24				inc 	codePtr 					; bump pointer
.a377	d0 02		bne $a37b			bne 	_CWBNoCarry
.a379	e6 25		inc $25				inc 	codePtr+1
.a37b					_CWBNoCarry:
.a37b	8e 61 9f	stx $9f61			stx 	ramBank 					; restore page
.a37e	7a		ply				ply 								; and exit.
.a37f	fa		plx				plx
.a380	60		rts				rts
.a381					BANKEDEnd:
.a381					BankCopyCode:
.a381	48		pha				pha
.a382	da		phx				phx
.a383	a2 3b		ldx #$3b			ldx 	#BANKEDEnd-BANKEDStart
.a385					_BCCCopy:
.a385	bd 46 a3	lda $a346,x			lda 	BANKEDStart,x
.a388	9d 00 07	sta $0700,x			sta 	BankCode,x
.a38b	ca		dex				dex
.a38c	e0 ff		cpx #$ff			cpx 	#$FF
.a38e	d0 f5		bne $a385			bne 	_BCCCopy
.a390	fa		plx				plx
.a391	68		pla				pla
.a392	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/create.asm

.a393					DictionaryCreate:
.a393	86 1a		stx $1a				stx 	zTemp0 						; save identifier position
.a395	84 1b		sty $1b				sty 	zTemp0+1
.a397	a0 01		ldy #$01			ldy 	#1 							; write the type byte out.
.a399	91 14		sta ($14),y			sta 	(dictPtr),y
.a39b	a0 00		ldy #$00			ldy 	#0 							; work out length.
.a39d					_DCGetLength:
.a39d	b1 1a		lda ($1a),y			lda 	(zTemp0),y
.a39f	c8		iny				iny
.a3a0	0a		asl a				asl 	a
.a3a1	90 fa		bcc $a39d			bcc 	_DCGetLength
.a3a3	5a		phy				phy 								; save Y on stack.
.a3a4	98		tya				tya 								; save length +6 as offset
.a3a5	18		clc				clc
.a3a6	69 06		adc #$06			adc 	#6
.a3a8	92 14		sta ($14)			sta 	(dictPtr)
.a3aa	a0 02		ldy #$02			ldy 	#2 							; fill 2 to 4 with $FF
.a3ac	a9 ff		lda #$ff	_DCFill:lda 	#$FF
.a3ae	91 14		sta ($14),y			sta 	(dictPtr),y
.a3b0	c8		iny				iny
.a3b1	c0 05		cpy #$05			cpy 	#5
.a3b3	d0 f7		bne $a3ac			bne 	_DCFill
.a3b5	68		pla				pla 								; get length, store in X
.a3b6	aa		tax				tax
.a3b7	91 14		sta ($14),y			sta 	(dictPtr),y 				; write length out.
.a3b9	a0 00		ldy #$00			ldy 	#0
.a3bb					_DCCopy:
.a3bb	b1 1a		lda ($1a),y			lda 	(zTemp0),y 					; next identifier character
.a3bd	c8		iny				iny 								; save +1 on stack
.a3be	5a		phy				phy
.a3bf	c8		iny				iny 								; advance by 6 total
.a3c0	c8		iny				iny
.a3c1	c8		iny				iny
.a3c2	c8		iny				iny
.a3c3	c8		iny				iny
.a3c4	91 14		sta ($14),y			sta 	(dictPtr),y 				; write out
.a3c6	7a		ply				ply 								; restore +1
.a3c7	ca		dex				dex
.a3c8	d0 f1		bne $a3bb			bne 	_DCCopy 					; do that the required# times.
.a3ca	a5 14		lda $14				lda 	dictPtr 					; copy last created
.a3cc	85 22		sta $22				sta 	lastCreate
.a3ce	a5 15		lda $15				lda 	dictPtr+1
.a3d0	85 23		sta $23				sta 	lastCreate+1
.a3d2	18		clc				clc 								; advance dictionary pointer
.a3d3	b2 14		lda ($14)			lda 	(dictPtr)
.a3d5	65 14		adc $14				adc 	dictPtr
.a3d7	85 14		sta $14				sta 	dictPtr
.a3d9	90 02		bcc $a3dd			bcc 	_DCNoCarry
.a3db	e6 15		inc $15				inc 	dictPtr+1
.a3dd					_DCNoCarry:
.a3dd	a9 00		lda #$00			lda 	#$00 						; write end of dictionary marker
.a3df	92 14		sta ($14)			sta 	(dictPtr)
.a3e1	60		rts				rts
.a3e2					DictionarySet:
.a3e2	48		pha				pha
.a3e3	da		phx				phx
.a3e4	5a		phy				phy
.a3e5	5a		phy				phy 								; copy data out to
.a3e6	a0 04		ldy #$04			ldy 	#4 							; offset 2,3,4 => A X Y
.a3e8	91 22		sta ($22),y			sta 	(lastCreate),y
.a3ea	88		dey				dey
.a3eb	68		pla				pla
.a3ec	91 22		sta ($22),y			sta 	(lastCreate),y
.a3ee	88		dey				dey
.a3ef	8a		txa				txa
.a3f0	91 22		sta ($22),y			sta 	(lastCreate),y
.a3f2	7a		ply				ply
.a3f3	fa		plx				plx
.a3f4	68		pla				pla
.a3f5	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/search.asm

.a3f6					DictionaryReset:
.a3f6	a9 18		lda #$18			lda 	#(UserDictionary) & $FF
.a3f8	85 14		sta $14				sta 	dictPtr
.a3fa	a9 b9		lda #$b9			lda 	#(UserDictionary) >> 8
.a3fc	85 15		sta $15				sta 	dictPtr+1
.a3fe	9c 18 b9	stz $b918			stz 	UserDictionary
.a401	60		rts				rts
.a402					DictionarySearchSystemOnly:
.a402	38		sec				sec
.a403	80 01		bra $a406			bra 	DictionarySearchContinue
.a405					DictionarySearch:
.a405	18		clc				clc
.a406					DictionarySearchContinue:
.a406	da		phx				phx
.a407	5a		phy				phy
.a408	08		php				php 								; CS if user only
.a409	8a		txa				txa 								; subtract 6 so can use offset Y
.a40a	38		sec				sec
.a40b	e9 06		sbc #$06			sbc 	#6
.a40d	85 1a		sta $1a				sta 	zTemp0
.a40f	98		tya				tya
.a410	e9 00		sbc #$00			sbc 	#0
.a412	85 1b		sta $1b				sta 	zTemp0+1 					; in zTemp0
.a414	28		plp				plp
.a415	b0 09		bcs $a420			bcs 	_DSCOnly
.a417	a2 18		ldx #$18			ldx 	#UserDictionary & $FF
.a419	a0 b9		ldy #$b9			ldy 	#UserDictionary >> 8
.a41b	20 2a a4	jsr $a42a			jsr 	DSSearch
.a41e	b0 07		bcs $a427			bcs 	_DSCExit
.a420					_DSCOnly:
.a420	a2 83		ldx #$83			ldx 	#SystemDictionary & $FF
.a422	a0 ac		ldy #$ac			ldy 	#SystemDictionary >> 8
.a424	20 2a a4	jsr $a42a			jsr 	DSSearch
.a427					_DSCExit:
.a427	7a		ply				ply 								; restore YX
.a428	fa		plx				plx
.a429	60		rts				rts
.a42a					DSSearch:
.a42a	86 1c		stx $1c				stx 	zTemp1 						; save dictionary in zTemp1
.a42c	84 1d		sty $1d				sty 	zTemp1+1
.a42e					_DSLoop:
.a42e	b2 1c		lda ($1c)			lda 	(zTemp1) 					; offset 0 ?
.a430	f0 36		beq $a468			beq 	_DSExit
.a432	a0 05		ldy #$05			ldy 	#5 							; get length in X
.a434	b1 1c		lda ($1c),y			lda 	(zTemp1),y
.a436	aa		tax				tax
.a437					_DSCompare:
.a437	c8		iny				iny 								; match next ?
.a438	b1 1c		lda ($1c),y			lda 	(zTemp1),y
.a43a	d1 1a		cmp ($1a),y			cmp 	(zTemp0),y
.a43c	d0 1d		bne $a45b			bne 	_DSNext
.a43e	ca		dex				dex 								; done all
.a43f	d0 f6		bne $a437			bne 	_DSCompare
.a441	a0 05		ldy #$05			ldy 	#5 							; copy bank/address
.a443	b1 1c		lda ($1c),y			lda 	(zTemp1),y
.a445	85 31		sta $31				sta 	dirLength
.a447	88		dey				dey
.a448	b1 1c		lda ($1c),y			lda 	(zTemp1),y
.a44a	85 30		sta $30				sta 	dirBank
.a44c	88		dey				dey
.a44d	b1 1c		lda ($1c),y			lda 	(zTemp1),y
.a44f	85 2f		sta $2f				sta 	dirHighByte
.a451	88		dey				dey
.a452	b1 1c		lda ($1c),y			lda 	(zTemp1),y
.a454	85 2e		sta $2e				sta 	dirLowByte
.a456	88		dey				dey
.a457	b1 1c		lda ($1c),y			lda 	(zTemp1),y 					; return type
.a459	38		sec				sec
.a45a	60		rts				rts
.a45b					_DSNext:
.a45b	18		clc				clc 								; advance to next.
.a45c	b2 1c		lda ($1c)			lda 	(zTemp1)
.a45e	65 1c		adc $1c				adc 	zTemp1
.a460	85 1c		sta $1c				sta 	zTemp1
.a462	90 ca		bcc $a42e			bcc 	_DSLoop
.a464	e6 1d		inc $1d				inc 	zTemp1+1
.a466	80 c6		bra $a42e			bra 	_DSLoop
.a468					_DSExit:
.a468	18		clc				clc
.a469	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/code.asm

.a46a					CodeReset:
.a46a	a2 00		ldx #$00			ldx 	#CodeMemory & 255
.a46c	a0 a0		ldy #$a0			ldy 	#CodeMemory >> 8
.a46e	a9 01		lda #$01			lda 	#CodePage
.a470	80 00		bra $a472			bra 	CodeSetPointer
.a472					CodeSetPointer:
.a472	48		pha				pha 								; copy old to backup
.a473	a5 24		lda $24				lda 	codePtr
.a475	85 39		sta $39				sta 	codeBackup
.a477	a5 25		lda $25				lda 	codePtr+1
.a479	85 3a		sta $3a				sta 	codeBackup+1
.a47b	a5 26		lda $26				lda 	codeBank
.a47d	85 3b		sta $3b				sta 	codeBackup+2
.a47f	68		pla				pla
.a480	85 26		sta $26				sta 	codeBank 					; update
.a482	86 24		stx $24				stx 	codePtr
.a484	84 25		sty $25				sty 	codePtr+1
.a486	60		rts				rts
.a487					CodeRestorePointer:
.a487	a5 39		lda $39				lda 	codeBackup
.a489	85 24		sta $24				sta 	codePtr
.a48b	a5 3a		lda $3a				lda 	codeBackup+1
.a48d	85 25		sta $25				sta 	codePtr+1
.a48f	a5 3b		lda $3b				lda 	codeBackup+2
.a491	85 26		sta $26				sta 	codeBank
.a493	60		rts				rts
.a494					CodeWriteBranch:
.a494	18		clc				clc 								; borrow 1 as branch is from one on
.a495	8a		txa				txa
.a496	e5 24		sbc $24				sbc 	codePtr
.a498	20 00 07	jsr $0700			jsr 	CodeWriteByte 				; compile anyway.
.a49b	aa		tax				tax 								; actual result in X.
.a49c	98		tya				tya
.a49d	e5 25		sbc $25				sbc 	codePtr+1
.a49f	f0 14		beq $a4b5			beq 	_CWBCheckPositive 			; 00xx
.a4a1	c9 ff		cmp #$ff			cmp 	#$FF
.a4a3	f0 14		beq $a4b9			beq 	_CWBCheckNegative 			; FFxx
.a4a5					_CWBError:
.a4a5	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a4a8	4c 45 41 4e 3a 42 52 41				.text 	"LEAN:","BRANCH?",$00
>a4b0	4e 43 48 3f 00
.a4b5					_CWBCheckPositive:
.a4b5	8a		txa				txa
.a4b6	30 ed		bmi $a4a5			bmi 	_CWBError
.a4b8	60		rts				rts
.a4b9					_CWBCheckNegative:
.a4b9	8a		txa				txa
.a4ba	10 e9		bpl $a4a5			bpl 	_CWBError
.a4bc	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/error.asm

.a4bd					SyntaxError:
.a4bd	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a4c0	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX",$00
>a4c8	54 41 58 00
.a4cc					ErrorHandler:
.a4cc	fa		plx				plx 								; pull address off.
.a4cd	7a		ply				ply
.a4ce	e8		inx				inx 								; point to message
.a4cf	d0 01		bne $a4d2			bne 	_EHNoCarry
.a4d1	c8		iny				iny
.a4d2					_EHNoCarry:
.a4d2	20 2d a5	jsr $a52d			jsr 	PrintStringXY 				; print string at XY
.a4d5	a2 0d		ldx #$0d			ldx 	#_EHMessage & $FF 			; print " AT "
.a4d7	a0 a5		ldy #$a5			ldy 	#_EHMessage >> 8
.a4d9	20 2d a5	jsr $a52d			jsr 	PrintStringXY
.a4dc	a6 2b		ldx $2b				ldx 	lineNumber 					; convert line number
.a4de	a4 2c		ldy $2c				ldy 	lineNumber+1
.a4e0	20 f6 a7	jsr $a7f6			jsr 	IntToString
.a4e3	a2 40		ldx #$40			ldx 	#lineBuffer & $FF 			; print number
.a4e5	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a4e7	20 2d a5	jsr $a52d			jsr 	PrintStringXY
.a4ea	a9 3a		lda #$3a			lda 	#":"						; print match count
.a4ec	20 3e a5	jsr $a53e			jsr 	PrintCharacter
.a4ef	a6 3d		ldx $3d				ldx 	matchCount
.a4f1	a0 00		ldy #$00			ldy 	#0
.a4f3	20 f6 a7	jsr $a7f6			jsr 	IntToString
.a4f6	a2 40		ldx #$40			ldx 	#lineBuffer & $FF 			; print number
.a4f8	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a4fa	20 2d a5	jsr $a52d			jsr 	PrintStringXY
.a4fd	64 28		stz $28				stz 	lastDefine 					; disable running by zeroing last defined
.a4ff	64 29		stz $29				stz 	lastDefine+1
.a501	64 2a		stz $2a				stz 	lastDefine+2
.a503	a2 12		ldx #$12			ldx 	#_EHMessage2 & $FF 			; print LEAN info
.a505	a0 a5		ldy #$a5			ldy 	#_EHMessage2 >> 8
.a507	20 2d a5	jsr $a52d			jsr 	PrintStringXY
.a50a	4c 3a a0	jmp $a03a			jmp 	ReturnCaller 				; exit the compiler.
.a50d					_EHMessage:
>a50d	20 41 54 20 00					.text	" AT ",0
.a512					_EHMessage2:
>a512	0d 20 20 20 20 4c 45 41				.text 	13,"    LEAN V0.2 (01-NOV-19)",0
>a51a	4e 20 56 30 2e 32 20 28 30 31 2d 4e 4f 56 2d 31
>a52a	39 29 00
.a52d					PrintStringXY:
.a52d	86 1a		stx $1a				stx 	zTemp0
.a52f	84 1b		sty $1b				sty 	zTemp0+1
.a531	a0 00		ldy #$00			ldy 	#0
.a533	b1 1a		lda ($1a),y	_PSLoop:lda 	(zTemp0),y
.a535	f0 06		beq $a53d			beq 	_PSExit
.a537	20 3e a5	jsr $a53e			jsr 	PrintCharacter
.a53a	c8		iny				iny
.a53b	80 f6		bra $a533			bra 	_PSLoop
.a53d	60		rts		_PSExit:rts
.a53e					PrintCharacter:
.a53e	48		pha				pha
.a53f	da		phx				phx
.a540	5a		phy				phy
.a541	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a544	7a		ply				ply
.a545	fa		plx				plx
.a546	68		pla				pla
.a547	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/procedure.asm

.a548					Action_Procedure_Def:
.a548	20 e3 a2	jsr $a2e3			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a54b	a9 50		lda #$50			lda 	#"P"
.a54d	20 93 a3	jsr $a393			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a550	a5 26		lda $26				lda 	codeBank 					; and assign it the current PC value.
.a552	a6 24		ldx $24				ldx 	codePtr
.a554	a4 25		ldy $25				ldy 	codePtr+1
.a556	86 28		stx $28				stx 	lastDefine 					; update last defined
.a558	84 29		sty $29				sty 	lastDefine+1
.a55a	85 2a		sta $2a				sta 	lastDefine+2
.a55c	20 e2 a3	jsr $a3e2			jsr 	DictionarySet 				; set the dictionary values.
.a55f	a9 28		lda #$28			lda 	#"("
.a561	20 19 a3	jsr $a319			jsr 	EGetSyntaxCheck
.a564	a9 29		lda #$29			lda 	#")"
.a566	20 19 a3	jsr $a319			jsr 	EGetSyntaxCheck
.a569	a9 50		lda #$50			lda 	#SCM_PROC 					; put a procedure marker on the stack.
.a56b	20 ee a8	jsr $a8ee			jsr 	StackPush
.a56e	60		rts				rts
.a56f					_APError:
.a56f	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a572	4c 45 41 4e 3a 50 52 4f				.text 	"LEAN:","PROCDEF",$00
>a57a	43 44 45 46 00
.a57f					Action_EndProc:
.a57f	a9 50		lda #$50			lda 	#SCM_PROC 					; check corresponding PROC
.a581	20 0a a9	jsr $a90a			jsr 	StackCheckStructureMarker
.a584	a9 60		lda #$60			lda 	#CPU_RETURN					; write out RTS
.a586	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a589	a9 01		lda #$01			lda 	#1 							; remove from stack.
.a58b	20 37 a9	jsr $a937			jsr 	StackPopStack
.a58e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/call.asm

.a58f					Action_Call:
.a58f	a5 33		lda $33				lda 	genPos 						; get position
.a591	3a		dec a				dec 	a 							; point to the <proc>
.a592	48		pha				pha 								; save it
.a593	a9 28		lda #$28			lda 	#'('						; check (
.a595	20 19 a3	jsr $a319			jsr 	EGetSyntaxCheck
.a598	20 3b a3	jsr $a33b			jsr 	EGLookNext 					; ) next ?
.a59b	c9 a9		cmp #$a9			cmp 	#')'+$80
.a59d	f0 1a		beq $a5b9			beq 	_ACNoParameters
.a59f	a9 52		lda #$52			lda 	#"R" 	 					; do R=<something>
.a5a1	20 d2 a5	jsr $a5d2			jsr 	ACDoParameter 				; do the parameter.
.a5a4	20 43 a3	jsr $a343			jsr 	EGSkipNext 					; skip the parameter
.a5a7	20 3b a3	jsr $a33b			jsr 	EGLookNext 					; what follows
.a5aa	c9 ac		cmp #$ac			cmp 	#","+$80 					; if not comma
.a5ac	d0 0b		bne $a5b9			bne 	_ACNoParameters 			; should be end of parameters
.a5ae	20 43 a3	jsr $a343			jsr 	EGSkipNext 					; skip ,
.a5b1	a9 59		lda #$59			lda 	#"Y"						; do Y=<something>
.a5b3	20 d2 a5	jsr $a5d2			jsr 	ACDoParameter 				; do the parameter.
.a5b6	20 43 a3	jsr $a343			jsr 	EGSkipNext 					; skip parameter.
.a5b9					_ACNoParameters:
.a5b9	a9 29		lda #$29			lda 	#')' 						; check closing bracket.
.a5bb	20 19 a3	jsr $a319			jsr 	EGetSyntaxCheck
.a5be	68		pla				pla 								; restore procedure posiion.
.a5bf	20 ad a2	jsr $a2ad			jsr 	GenCopyData					; get the data
.a5c2	a9 20		lda #$20			lda 	#CPU_JSR					; output a call to it.
.a5c4	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a5c7	a5 36		lda $36				lda 	elementData
.a5c9	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a5cc	a5 37		lda $37				lda 	elementData+1
.a5ce	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a5d1	60		rts				rts
.a5d2					ACDoParameter:
.a5d2	a6 33		ldx $33				ldx 	genPos 						; save position
.a5d4	da		phx				phx
.a5d5	48		pha				pha 								; save the target register
.a5d6	bd 40 06	lda $0640,x			lda 	lineBuffer,x 				; what is there ?
.a5d9	c9 e1		cmp #$e1			cmp 	#"a"+$80 					; check a-z
.a5db	90 1a		bcc $a5f7			bcc 	_ADPError
.a5dd	c9 fb		cmp #$fb			cmp 	#"z"+$81
.a5df	b0 16		bcs $a5f7			bcs 	_ADPError
.a5e1	ca		dex				dex 								; write = before it
.a5e2	a9 bd		lda #$bd			lda 	#"="+$80
.a5e4	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a5e7	ca		dex				dex
.a5e8	68		pla				pla 								; write Y/R before that
.a5e9	09 80		ora #$80			ora 	#$80
.a5eb	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a5ee	86 33		stx $33				stx 	genPos 						; make genPos point to that.
.a5f0	20 f1 a1	jsr $a1f1			jsr 	GenerateOne 				; generate that.
.a5f3	68		pla				pla 								; restore position
.a5f4	85 33		sta $33				sta 	genPos
.a5f6	60		rts				rts
.a5f7					_ADPError:
.a5f7	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a5fa	4c 45 41 4e 3a 50 41 52				.text 	"LEAN:","PARAMETER?",$00
>a602	41 4d 45 54 45 52 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/if.asm

.a60a					Action_If:
.a60a	a5 34		lda $34				lda 	generateVar 				; branch to use.
.a60c	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a60e	20 00 07	jsr $0700			jsr 	CodeWriteByte 				; output it
.a611	20 de a8	jsr $a8de			jsr 	StackPushPC 				; push branch position on stack
.a614	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a616	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a619	a9 49		lda #$49			lda 	#SCM_IF 					; put if marker on the stack.
.a61b	20 ee a8	jsr $a8ee			jsr 	StackPush
.a61e	60		rts				rts
.a61f					Action_Else:
.a61f	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a621	20 0a a9	jsr $a90a			jsr 	StackCheckStructureMarker
.a624	a9 80		lda #$80			lda 	#CPU_BRA 					; compile branch
.a626	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a629	a5 24		lda $24				lda 	codePtr 					; push current position on the stack
.a62b	48		pha				pha
.a62c	a5 25		lda $25				lda 	codePtr+1
.a62e	48		pha				pha
.a62f	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a631	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a634	20 4f a6	jsr $a64f			jsr 	BackPatchIf 				; do the backpatch.
.a637	68		pla				pla 								; overwrite backpatch address
.a638	a0 01		ldy #$01			ldy 	#1 							; with stacked position.
.a63a	91 12		sta ($12),y			sta 	(aStackPtr),y
.a63c	68		pla				pla
.a63d	c8		iny				iny
.a63e	91 12		sta ($12),y			sta 	(aStackPtr),y
.a640	60		rts				rts
.a641					Action_Endif:
.a641	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a643	20 0a a9	jsr $a90a			jsr 	StackCheckStructureMarker
.a646	20 4f a6	jsr $a64f			jsr 	BackPatchIf 				; do the backpatch.
.a649	a9 04		lda #$04			lda 	#3+1 						; throw the stack.
.a64b	20 37 a9	jsr $a937			jsr 	StackPopStack
.a64e	60		rts				rts
.a64f					BackPatchIf:
.a64f	a5 24		lda $24					lda 	codePtr 					; save code pointer
.a651	48		pha				pha
.a652	a5 25		lda $25				lda 	codePtr+1
.a654	48		pha				pha
.a655	a0 03		ldy #$03			ldy 	#3 							; AYX = address.
.a657	b1 12		lda ($12),y			lda 	(aStackPtr),y
.a659	48		pha				pha
.a65a	88		dey				dey
.a65b	b1 12		lda ($12),y			lda 	(aStackPtr),y
.a65d	aa		tax				tax
.a65e	88		dey				dey
.a65f	b1 12		lda ($12),y			lda 	(aStackPtr),y
.a661	a8		tay				tay
.a662	68		pla				pla
.a663	20 72 a4	jsr $a472			jsr 	CodeSetPointer 				; set write position to that
.a666	7a		ply				ply 								; target address in YX
.a667	fa		plx				plx
.a668	20 94 a4	jsr $a494			jsr 	CodeWriteBranch 			; write the actual branch there
.a66b	20 87 a4	jsr $a487			jsr 	CodeRestorePointer 			; undo the set pointer.
.a66e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/repeat.asm

.a66f					Action_Repeat:
.a66f	20 de a8	jsr $a8de			jsr 	StackPushPC 					; push loop position on stack
.a672	a9 52		lda #$52			lda 	#SCM_REPEAT 					; put a repeat marker on the stack.
.a674	20 ee a8	jsr $a8ee			jsr 	StackPush
.a677	60		rts				rts
.a678					Action_Until:
.a678	a9 52		lda #$52			lda 	#SCM_REPEAT 				; check corresponding repeat
.a67a	20 0a a9	jsr $a90a			jsr 	StackCheckStructureMarker
.a67d	a5 34		lda $34				lda 	generateVar 				; branch to use.
.a67f	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a681	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a683	20 22 a9	jsr $a922			jsr 	StackCompileBranch 			; compile a branch.
.a686	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a688	20 37 a9	jsr $a937			jsr 	StackPopStack
.a68b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/for.asm

.a68c					Action_AFor:
.a68c	20 de a8	jsr $a8de			jsr 	StackPushPC 					; push loop position on stack
.a68f	a9 3a		lda #$3a			lda 	#CPU_DECA 						; counts backwards from n-1 to 0.
.a691	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a694	a9 48		lda #$48			lda 	#CPU_PHA 						; push index on stack
.a696	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a699	a9 46		lda #$46			lda 	#SCM_FOR 						; put a for marker on the stack.
.a69b	20 ee a8	jsr $a8ee			jsr 	StackPush
.a69e	60		rts				rts
.a69f					Action_RFor:
.a69f	20 de a8	jsr $a8de			jsr 	StackPushPC 					; push loop position on stack
.a6a2	a9 c9		lda #$c9			lda 	#CPU_CMPIM 						; dec XA code cmp #0
.a6a4	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6a7	a9 00		lda #$00			lda 	#0
.a6a9	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6ac	a9 d0		lda #$d0			lda 	#CPU_BNE 						; bne +1
.a6ae	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6b1	a9 01		lda #$01			lda 	#1
.a6b3	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6b6	a9 ca		lda #$ca			lda 	#CPU_DEX 						; dex
.a6b8	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6bb	a9 3a		lda #$3a			lda 	#CPU_DECA 						; dec a
.a6bd	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6c0	a9 48		lda #$48			lda 	#CPU_PHA 						; push index on stack
.a6c2	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6c5	a9 da		lda #$da			lda 	#CPU_PHX
.a6c7	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6ca	a9 47		lda #$47			lda 	#SCM_INTFOR 					; put a for marker on the stack.
.a6cc	20 ee a8	jsr $a8ee			jsr 	StackPush
.a6cf	60		rts				rts
.a6d0					Action_Next:
.a6d0	b2 12		lda ($12)			lda 	(aStackPtr) 				; check for R-Next
.a6d2	c9 47		cmp #$47			cmp 	#SCM_INTFOR
.a6d4	f0 17		beq $a6ed			beq 	_AN16Bit
.a6d6	a9 46		lda #$46			lda 	#SCM_FOR 					; check corresponding for
.a6d8	20 0a a9	jsr $a90a			jsr 	StackCheckStructureMarker
.a6db	a9 68		lda #$68			lda 	#CPU_PLA 					; pop index off stack.
.a6dd	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6e0	a9 d0		lda #$d0			lda 	#CPU_BNE 					; branch back if #0
.a6e2	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a6e4	20 22 a9	jsr $a922			jsr 	StackCompileBranch 			; compile a branch.
.a6e7	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a6e9	20 37 a9	jsr $a937			jsr 	StackPopStack
.a6ec	60		rts				rts
.a6ed					_AN16Bit:
.a6ed	a9 fa		lda #$fa			lda 	#CPU_PLX 					; pop index on stack
.a6ef	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6f2	a9 68		lda #$68			lda 	#CPU_PLA
.a6f4	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6f7	a9 d0		lda #$d0			lda 	#CPU_BNE
.a6f9	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a6fb	20 22 a9	jsr $a922			jsr 	StackCompileBranch 			; compile a branch (check LSB)
.a6fe	a9 e0		lda #$e0			lda 	#CPU_CPXIM  				; check MSB of index
.a700	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a703	a9 00		lda #$00			lda 	#0
.a705	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a708	a9 d0		lda #$d0			lda 	#CPU_BNE
.a70a	a0 01		ldy #$01			ldy 	#1
.a70c	20 22 a9	jsr $a922			jsr 	StackCompileBranch
.a70f	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a711	20 37 a9	jsr $a937			jsr 	StackPopStack
.a714	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/variables.asm

.a715					VariableReset:
.a715	a9 00		lda #$00			lda 	#(VariableMemory) & $FF
.a717	85 18		sta $18				sta 	varPtr
.a719	a9 07		lda #$07			lda 	#(VariableMemory) >> 8
.a71b	85 19		sta $19				sta 	varPtr+1
.a71d	60		rts				rts
.a71e					Action_ByteVar:
.a71e	a9 01		lda #$01			lda 	#1
.a720	80 02		bra $a724			bra 	VariableDeclare
.a722					Action_WordVar:
.a722	a9 02		lda #$02			lda 	#2
.a724					VariableDeclare:
.a724	85 3c		sta $3c				sta 	varSize 					; save variable size.
.a726					_VDLoop:
.a726	a9 53		lda #$53			lda 	#"S"						; get I or S
.a728	a6 3c		ldx $3c				ldx 	varSize
.a72a	ca		dex				dex
.a72b	f0 02		beq $a72f			beq 	_VDNotWord
.a72d	a9 49		lda #$49			lda 	#"I"
.a72f					_VDNotWord:
.a72f	48		pha				pha
.a730	20 e3 a2	jsr $a2e3			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a733	68		pla				pla
.a734	20 93 a3	jsr $a393			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a737	20 3b a3	jsr $a33b			jsr 	EGLookNext 					; what's next ?
.a73a	c9 c0		cmp #$c0			cmp 	#'@'|$80 					; if not @, use default
.a73c	d0 21		bne $a75f			bne 	_VDDefault
.a73e	20 43 a3	jsr $a343			jsr 	EGSkipNext 					; skip @
.a741	20 3b a3	jsr $a33b			jsr 	EGLookNext 					; get next
.a744	c9 e2		cmp #$e2			cmp 	#'b'|$80 					; must be b/w constant
.a746	f0 04		beq $a74c			beq 	_VDLegit
.a748	c9 f7		cmp #$f7			cmp 	#'w'|$80
.a74a	d0 34		bne $a780			bne 	_VDError
.a74c					_VDLegit:
.a74c	a5 33		lda $33				lda 	genPos 						; position
.a74e	20 ad a2	jsr $a2ad			jsr 	GenCopyData					; access data
.a751	a9 00		lda #$00			lda 	#0 		 					; set the address
.a753	a6 36		ldx $36				ldx 	elementData
.a755	a4 37		ldy $37				ldy 	elementData+1
.a757	20 e2 a3	jsr $a3e2			jsr 	DictionarySet
.a75a	20 43 a3	jsr $a343			jsr 	EGSkipNext 					; consume the constant
.a75d	80 14		bra $a773			bra 	_VDTryNext
.a75f					_VDDefault:
.a75f	a6 18		ldx $18				ldx 	varPtr 						; place at default position
.a761	a4 19		ldy $19				ldy 	varPtr+1
.a763	a9 00		lda #$00			lda 	#0
.a765	20 e2 a3	jsr $a3e2			jsr 	DictionarySet
.a768	a5 3c		lda $3c				lda 	varSize 					; get count of bytes back
.a76a	18		clc				clc
.a76b	65 18		adc $18				adc 	varPtr
.a76d	85 18		sta $18				sta 	varPtr
.a76f	90 02		bcc $a773			bcc 	_VDNoCarry
.a771	e6 19		inc $19				inc 	varPtr+1
.a773					_VDNoCarry:
.a773					_VDTryNext:
.a773	20 3b a3	jsr $a33b			jsr 	EGLookNext 					; what's next ?
.a776	c9 ac		cmp #$ac			cmp 	#","|$80 					; is it a comma
.a778	d0 05		bne $a77f			bne 	_VDExit 					; no, exit.
.a77a	20 43 a3	jsr $a343			jsr 	EGSkipNext
.a77d	80 a7		bra $a726			bra 	_VDLoop
.a77f					_VDExit:
.a77f	60		rts				rts
.a780					_VDError:
.a780	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a783	4c 45 41 4e 3a 41 44 44				.text 	"LEAN:","ADDRESS?",$00
>a78b	52 45 53 53 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/crunch.asm

.a791					Action_DictionaryCrunch:
.a791	a9 18		lda #$18			lda 	#(UserDictionary) & $FF
.a793	85 1a		sta $1a				sta 	zTemp0
.a795	a9 b9		lda #$b9			lda 	#(UserDictionary) >> 8
.a797	85 1b		sta $1b				sta 	zTemp0+1
.a799					_ADCLoop:
.a799	b2 1a		lda ($1a)			lda 	(zTemp0) 					; reached end of dictionary
.a79b	f0 58		beq $a7f5			beq 	_ADCExit
.a79d	a0 06		ldy #$06			ldy 	#6							; read first character
.a79f	b1 1a		lda ($1a),y			lda 	(zTemp0),y
.a7a1	29 7f		and #$7f			and 	#$7F 						; is it a '.' ?
.a7a3	c9 2e		cmp #$2e			cmp 	#'.'
.a7a5	d0 41		bne $a7e8			bne 	_ADCNext 					; if not, it's a global, skip to next.
.a7a7	a5 1a		lda $1a				lda 	zTemp0 						; work out copy from, into zTemp1
.a7a9	48		pha				pha
.a7aa	18		clc				clc
.a7ab	72 1a		adc ($1a)			adc 	(zTemp0)
.a7ad	85 1c		sta $1c				sta 	zTemp1
.a7af	a5 1b		lda $1b				lda 	zTemp0+1
.a7b1	48		pha				pha
.a7b2	69 00		adc #$00			adc 	#0
.a7b4	85 1d		sta $1d				sta 	zTemp1+1
.a7b6					_ADCopyOverwrite:
.a7b6	b2 1c		lda ($1c)			lda 	(zTemp1) 					; byte copy
.a7b8	92 1a		sta ($1a)			sta 	(zTemp0)
.a7ba	a5 1c		lda $1c				lda 	zTemp1 						; until the upper address = dictionary top
.a7bc	c5 14		cmp $14				cmp 	dictPtr
.a7be	d0 06		bne $a7c6			bne 	_ADCNextCopy
.a7c0	a5 1d		lda $1d				lda 	zTemp1+1
.a7c2	c5 15		cmp $15				cmp 	dictPtr+1
.a7c4	f0 0e		beq $a7d4			beq 	_ADCRemoved
.a7c6					_ADCNextCopy:
.a7c6	e6 1a		inc $1a				inc 	zTemp0
.a7c8	d0 02		bne $a7cc			bne 	_NoCarry
.a7ca	e6 1b		inc $1b				inc 	zTemp0+1
.a7cc					_NoCarry:
.a7cc	e6 1c		inc $1c				inc 	zTemp1
.a7ce	d0 02		bne $a7d2			bne 	_NoCarry
.a7d0	e6 1d		inc $1d				inc 	zTemp1+1
.a7d2					_NoCarry:
.a7d2	80 e2		bra $a7b6			bra 	_ADCopyOverwrite
.a7d4					_ADCRemoved:
.a7d4	a5 1a		lda $1a				lda 	zTemp0 						; copy from position is new top.
.a7d6	85 14		sta $14				sta 	dictPtr
.a7d8	a5 1b		lda $1b				lda 	zTemp0+1
.a7da	85 15		sta $15				sta 	dictPtr+1
.a7dc	a9 00		lda #$00			lda 	#0							; mark end as not copied in loop
.a7de	92 14		sta ($14)			sta 	(dictPtr)
.a7e0	68		pla				pla 								; restore original position.
.a7e1	85 1b		sta $1b				sta 	zTemp0+1
.a7e3	68		pla				pla
.a7e4	85 1a		sta $1a				sta 	zTemp0
.a7e6	80 b1		bra $a799			bra 	_ADCLoop 					; and continue from same position.
.a7e8					_ADCNext:
.a7e8	18		clc				clc 								; advance to next.
.a7e9	a5 1a		lda $1a				lda 	zTemp0
.a7eb	72 1a		adc ($1a)			adc 	(zTemp0)
.a7ed	85 1a		sta $1a				sta 	zTemp0
.a7ef	90 a8		bcc $a799			bcc 	_ADCLoop
.a7f1	e6 1b		inc $1b				inc 	zTemp0+1
.a7f3	80 a4		bra $a799			bra 	_ADCLoop
.a7f5					_ADCExit:
.a7f5	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/tostring.asm

.a7f6					IntToString:
.a7f6	86 1a		stx $1a				stx 	zTemp0 						; count is in zTemp0
.a7f8	84 1b		sty $1b				sty 	zTemp0+1
.a7fa	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a7fc	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a7fe					_ITSLoop:
.a7fe	64 1c		stz $1c				stz 	zTemp1 						; this is the count of subtracts.
.a800					_ITSSubtractLoop:
.a800	38		sec				sec
.a801	a5 1a		lda $1a				lda 	zTemp0 						; try to calculate
.a803	fd 39 a8	sbc $a839,x			sbc 	_ITSWords,x
.a806	48		pha				pha
.a807	a5 1b		lda $1b				lda 	zTemp0+1
.a809	fd 3a a8	sbc $a83a,x			sbc 	_ITSWords+1,x
.a80c	90 09		bcc $a817			bcc 	_ITSEndSub 					; can't subtract any more.
.a80e	85 1b		sta $1b				sta 	zTemp0+1 					; update zTemp
.a810	68		pla				pla
.a811	85 1a		sta $1a				sta 	zTemp0
.a813	e6 1c		inc $1c				inc 	zTemp1 						; bump subtract count.
.a815	80 e9		bra $a800			bra 	_ITSSubtractLoop
.a817					_ITSEndSub:
.a817	68		pla				pla 								; throw away the interim result
.a818	a5 1c		lda $1c				lda 	zTemp1 						; if the subtract count is non zero
.a81a	d0 04		bne $a820			bne 	_ITSWriteOut 				; always write it out
.a81c	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a81e	f0 06		beq $a826			beq 	_ITSNext 					; suppressing leading zeros.
.a820					_ITSWriteOut:
.a820	09 30		ora #$30			ora 	#48 						; output digit.
.a822	99 40 06	sta $0640,y			sta 	lineBuffer,y
.a825	c8		iny				iny
.a826					_ITSNext:
.a826	e8		inx				inx
.a827	e8		inx				inx
.a828	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a82a	d0 d2		bne $a7fe			bne 	_ITSLoop 					; do the new digits
.a82c	a5 1a		lda $1a				lda 	zTemp0 						; output the last digit
.a82e	09 30		ora #$30			ora 	#48
.a830	99 40 06	sta $0640,y			sta 	lineBuffer,y 				; make it ASCIIZ.
.a833	a9 00		lda #$00			lda 	#0
.a835	99 41 06	sta $0641,y			sta 	lineBuffer+1,y
.a838	60		rts				rts
.a839					_ITSWords:
>a839	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a841					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: utility/tointeger.asm

.a841					StringToInt:
.a841	86 20		stx $20				stx 	zTemp3 						; save string
.a843	84 21		sty $21				sty 	zTemp3+1
.a845	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a847	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a849	b2 20		lda ($20)			lda 	(zTemp3) 					; first character
.a84b	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a84d	f0 1b		beq $a86a			beq 	_STIConvert 				; convert from character 1, base 16.
.a84f	88		dey				dey 								; from character 0
.a850	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a852	c9 2d		cmp #$2d			cmp 	#"-"						; first char is unary minus ?
.a854	d0 14		bne $a86a			bne 	_STIConvert 				; no, convert as +ve decimal
.a856	c8		iny				iny 								; skip the minus
.a857	20 6a a8	jsr $a86a			jsr 	_STIConvert 				; convert the unsigned part.
.a85a	90 0d		bcc $a869			bcc 	_STIExit 					; failed
.a85c	8a		txa				txa 								; 1's complement YX
.a85d	49 ff		eor #$ff			eor 	#$FF
.a85f	aa		tax				tax
.a860	98		tya				tya
.a861	49 ff		eor #$ff			eor 	#$FF
.a863	a8		tay				tay
.a864	e8		inx				inx 								; +1 to make it negative
.a865	38		sec				sec
.a866	d0 01		bne $a869			bne 	_STIExit
.a868	c8		iny				iny
.a869					_STIExit:
.a869	60		rts				rts
.a86a					_STIConvert:
.a86a	86 1c		stx $1c				stx 	zTemp1 						; save base in zTemp1
.a86c	b1 20		lda ($20),y			lda 	(zTemp3),y 					; get first character
.a86e	f0 5f		beq $a8cf			beq 	_STIFail 					; if zero, then it has failed anyway.
.a870	64 1a		stz $1a				stz 	zTemp0 						; clear the result.
.a872	64 1b		stz $1b				stz 	zTemp0+1
.a874					_STILoop:
.a874	a5 1a		lda $1a				lda 	zTemp0 						; copy current to zTemp2
.a876	85 1e		sta $1e				sta 	zTemp2
.a878	a5 1b		lda $1b				lda 	zTemp0+1
.a87a	85 1f		sta $1f				sta 	zTemp2+1
.a87c	64 1a		stz $1a				stz 	zTemp0 						; clear result
.a87e	64 1b		stz $1b				stz 	zTemp0+1
.a880	a6 1c		ldx $1c				ldx 	zTemp1 						; X contains the base.
.a882					_STIMultiply:
.a882	8a		txa				txa 								; shift Y right into carry.
.a883	4a		lsr a				lsr 	a
.a884	aa		tax				tax
.a885	90 0d		bcc $a894			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a887	18		clc				clc
.a888	a5 1e		lda $1e				lda 	zTemp2 						; add zTemp2 into zTemp0
.a88a	65 1a		adc $1a				adc 	zTemp0
.a88c	85 1a		sta $1a				sta 	zTemp0
.a88e	a5 1f		lda $1f				lda 	zTemp2+1
.a890	65 1b		adc $1b				adc 	zTemp0+1
.a892	85 1b		sta $1b				sta 	zTemp0+1
.a894					_STINoAdd:
.a894	06 1e		asl $1e				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a896	26 1f		rol $1f				rol 	zTemp2+1
.a898	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a89a	d0 e6		bne $a882			bne 	_STIMultiply
.a89c	b1 20		lda ($20),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a89e	29 7f		and #$7f			and 	#$7F 						; remove End of Token bit if set
.a8a0	c9 30		cmp #$30			cmp 	#"0"
.a8a2	90 2b		bcc $a8cf			bcc 	_STIFail
.a8a4	c9 3a		cmp #$3a			cmp 	#"9"+1
.a8a6	90 0b		bcc $a8b3			bcc 	_STIOkay
.a8a8	c9 41		cmp #$41			cmp 	#"A"
.a8aa	90 23		bcc $a8cf			bcc 	_STIFail
.a8ac	c9 47		cmp #$47			cmp 	#"F"+1
.a8ae	b0 1f		bcs $a8cf			bcs 	_STIFail
.a8b0	38		sec				sec 								; hex adjust
.a8b1	e9 07		sbc #$07			sbc 	#7
.a8b3					_STIOkay:
.a8b3	38		sec				sec
.a8b4	e9 30		sbc #$30			sbc 	#48
.a8b6	c5 1c		cmp $1c				cmp 	zTemp1  					; if >= base then fail.
.a8b8	b0 15		bcs $a8cf			bcs 	_STIFail
.a8ba	d8		cld				cld
.a8bb	65 1a		adc $1a				adc 	zTemp0 						; add into the current value
.a8bd	85 1a		sta $1a				sta 	zTemp0
.a8bf	90 02		bcc $a8c3			bcc 	_STINoCarry
.a8c1	e6 1b		inc $1b				inc 	zTemp0+1
.a8c3					_STINoCarry:
.a8c3	b1 20		lda ($20),y			lda 	(zTemp3),y					; get character just done.
.a8c5	c8		iny				iny 								; point to next
.a8c6	0a		asl a				asl 	a 							; shift bit 7 into carry
.a8c7	90 ab		bcc $a874			bcc 	_STILoop 					; not reached the end.
.a8c9	a6 1a		ldx $1a				ldx 	zTemp0 						; return result
.a8cb	a4 1b		ldy $1b				ldy 	zTemp0+1
.a8cd	38		sec				sec
.a8ce	60		rts				rts
.a8cf					_STIFail:
.a8cf	18		clc				clc
.a8d0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/astack.asm

.a8d1					StackReset:
.a8d1	a9 3f		lda #$3f			lda 	#(assemblerStack) & $FF
.a8d3	85 12		sta $12				sta 	aStackPtr
.a8d5	a9 06		lda #$06			lda 	#(assemblerStack) >> 8
.a8d7	85 13		sta $13				sta 	aStackPtr+1
.a8d9	a9 2a		lda #$2a			lda 	#SCM_TOP
.a8db	92 12		sta ($12)			sta 	(aStackPtr)
.a8dd	60		rts				rts
.a8de					StackPushPC:
.a8de	a5 26		lda $26				lda 	codeBank
.a8e0	20 ee a8	jsr $a8ee			jsr 	StackPush
.a8e3	a5 24		lda $24				lda 	codePtr
.a8e5	20 ee a8	jsr $a8ee			jsr 	StackPush
.a8e8	a5 25		lda $25				lda 	codePtr+1
.a8ea	20 ee a8	jsr $a8ee			jsr 	StackPush
.a8ed	60		rts				rts
.a8ee					StackPush:
.a8ee	c6 12		dec $12				dec 	aStackPtr 					; decrement TOS pointer.
.a8f0	f0 03		beq $a8f5			beq 	_SPStack
.a8f2	92 12		sta ($12)			sta 	(aStackPtr)					; write to new TOS
.a8f4	60		rts				rts
.a8f5					_SPStack:
.a8f5	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a8f8	4c 45 41 4e 3a 52 45 54				.text 	"LEAN:","RETURN STACK",$00
>a900	55 52 4e 20 53 54 41 43 4b 00
.a90a					StackCheckStructureMarker:
.a90a	d2 12		cmp ($12)			cmp 	(aStackPtr)					; check if tos matches
.a90c	d0 01		bne $a90f			bne 	_SCSError
.a90e	60		rts				rts
.a90f					_SCSError:
.a90f	20 cc a4	jsr $a4cc			jsr 	ErrorHandler
>a912	4c 45 41 4e 3a 53 54 52				.text 	"LEAN:","STRUCTURES",$00
>a91a	55 43 54 55 52 45 53 00
.a922					StackCompileBranch:
.a922	48		pha				pha
.a923	da		phx				phx
.a924	5a		phy				phy
.a925	20 00 07	jsr $0700			jsr 	CodeWriteByte 				; write the opcode.
.a928	c8		iny				iny
.a929	b1 12		lda ($12),y			lda 	(aStackPtr),y
.a92b	aa		tax				tax
.a92c	88		dey				dey
.a92d	b1 12		lda ($12),y			lda 	(aStackPtr),y
.a92f	a8		tay				tay
.a930	20 94 a4	jsr $a494			jsr 	CodeWriteBranch 			; write a branch there.
.a933	7a		ply				ply
.a934	fa		plx				plx
.a935	68		pla				pla
.a936	60		rts				rts
.a937					StackPopStack:
.a937	18		clc				clc 								; return stack all in same page
.a938	65 12		adc $12				adc 	aStackPtr 					; so we don't carry out.
.a93a	85 12		sta $12				sta 	aStackPtr
.a93c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/system.inc

.a93d					L10000:
>a93d	04					.byte L10000_END-L10000-1
.a93e	a9 63		lda #$63		lda  #$63
.a940	a2 73		ldx #$73		ldx  #$73
.a942					L10000_END:
.a942					L10001:
>a942	09					.byte L10001_END-L10001-1
.a943	91 63		sta ($63),y		sta  ($63),y
.a945	c8		iny			iny
.a946	8a		txa			txa
.a947	91 63		sta ($63),y		sta  ($63),y
.a949	88		dey			dey
.a94a	b1 63		lda ($63),y		lda  ($63),y
.a94c					L10001_END:
.a94c					L10002:
>a94c	02					.byte L10002_END-L10002-1
.a94d	91 63		sta ($63),y		sta  ($63),y
.a94f					L10002_END:
.a94f					L10003:
>a94f	02					.byte L10003_END-L10003-1
.a950	84 63		sty $63			sty  $63
.a952					L10003_END:
.a952					L10004:
>a952	02					.byte L10004_END-L10004-1
.a953	85 63		sta $63			sta  $63
.a955					L10004_END:
.a955					L10005:
>a955	02					.byte L10005_END-L10005-1
.a956	85 63		sta $63			sta  $63
.a958					L10005_END:
.a958					L10006:
>a958	04					.byte L10006_END-L10006-1
.a959	a5 63		lda $63			lda  $63
.a95b	a2 00		ldx #$00		ldx  #0
.a95d					L10006_END:
.a95d					L10007:
>a95d	02					.byte L10007_END-L10007-1
>a95e	a3 00					.byte $a3,$00
.a960					L10007_END:
.a960					L10008:
>a960	06					.byte L10008_END-L10008-1
.a961	8d 63 73	sta $7363		sta  $7363
.a964	8e 83 73	stx $7383		stx  $7383
.a967					L10008_END:
.a967					L10009:
>a967	06					.byte L10009_END-L10009-1
.a968	ad 63 73	lda $7363		lda  $7363
.a96b	ae 83 73	ldx $7383		ldx  $7383
.a96e					L10009_END:
.a96e					L10010:
>a96e	04					.byte L10010_END-L10010-1
.a96f	85 63		sta $63			sta  $63
.a971	86 83		stx $83			stx  $83
.a973					L10010_END:
.a973					L10011:
>a973	04					.byte L10011_END-L10011-1
.a974	a5 63		lda $63			lda  $63
.a976	a6 83		ldx $83			ldx  $83
.a978					L10011_END:
.a978					L10012:
>a978	03					.byte L10012_END-L10012-1
.a979	8c 63 73	sty $7363		sty  $7363
.a97c					L10012_END:
.a97c					L10013:
>a97c	03					.byte L10013_END-L10013-1
.a97d	8d 63 73	sta $7363		sta  $7363
.a980					L10013_END:
.a980					L10014:
>a980	03					.byte L10014_END-L10014-1
.a981	8d 63 73	sta $7363		sta  $7363
.a984					L10014_END:
.a984					L10015:
>a984	05					.byte L10015_END-L10015-1
.a985	ad 63 73	lda $7363		lda  $7363
.a988	a2 00		ldx #$00		ldx  #0
.a98a					L10015_END:
.a98a					L10016:
>a98a	04					.byte L10016_END-L10016-1
.a98b	a9 63		lda #$63		lda  #$63
.a98d	a2 73		ldx #$73		ldx  #$73
.a98f					L10016_END:
.a98f					L10017:
>a98f	07					.byte L10017_END-L10017-1
.a990	8a		txa			txa
.a991	49 ff		eor #$ff		eor  #$ff
.a993	aa		tax			tax
.a994	68		pla			pla
.a995	49 ff		eor #$ff		eor  #$ff
.a997					L10017_END:
.a997					L10018:
>a997	02					.byte L10018_END-L10018-1
.a998	49 ff		eor #$ff		eor  #$ff
.a99a					L10018_END:
.a99a					L10019:
>a99a	02					.byte L10019_END-L10019-1
.a99b	a4 63		ldy $63			ldy  $63
.a99d					L10019_END:
.a99d					L10020:
>a99d	03					.byte L10020_END-L10020-1
.a99e	ac 63 73	ldy $7363		ldy  $7363
.a9a1					L10020_END:
.a9a1					L10021:
>a9a1	02					.byte L10021_END-L10021-1
.a9a2	a0 63		ldy #$63		ldy  #$63
.a9a4					L10021_END:
.a9a4					L10022:
>a9a4	01					.byte L10022_END-L10022-1
.a9a5	a8		tay			tay
.a9a6					L10022_END:
.a9a6					L10023:
>a9a6	01					.byte L10023_END-L10023-1
.a9a7	a8		tay			tay
.a9a8					L10023_END:
.a9a8					L10024:
>a9a8	01					.byte L10024_END-L10024-1
.a9a9	5a		phy			phy
.a9aa					L10024_END:
.a9aa					L10025:
>a9aa	02					.byte L10025_END-L10025-1
>a9ab	a3 01					.byte $a3,$01
.a9ad					L10025_END:
.a9ad					L10026:
>a9ad	02					.byte L10026_END-L10026-1
>a9ae	a3 02					.byte $a3,$02
.a9b0					L10026_END:
.a9b0					L10027:
>a9b0	01					.byte L10027_END-L10027-1
.a9b1	7a		ply			ply
.a9b2					L10027_END:
.a9b2					L10028:
>a9b2	03					.byte L10028_END-L10028-1
.a9b3	7a		ply			ply
.a9b4	fa		plx			plx
.a9b5	68		pla			pla
.a9b6					L10028_END:
.a9b6					L10029:
>a9b6	02					.byte L10029_END-L10029-1
.a9b7	fa		plx			plx
.a9b8	68		pla			pla
.a9b9					L10029_END:
.a9b9					L10030:
>a9b9	01					.byte L10030_END-L10030-1
.a9ba	68		pla			pla
.a9bb					L10030_END:
.a9bb					L10031:
>a9bb	08					.byte L10031_END-L10031-1
.a9bc	49 63		eor #$63		eor  #$63
.a9be	48		pha			pha
.a9bf	8a		txa			txa
.a9c0	49 73		eor #$73		eor  #$73
.a9c2	aa		tax			tax
.a9c3	68		pla			pla
.a9c4					L10031_END:
.a9c4					L10032:
>a9c4	0a					.byte L10032_END-L10032-1
.a9c5	51 63		eor ($63),y		eor  ($63),y
.a9c7	48		pha			pha
.a9c8	8a		txa			txa
.a9c9	c8		iny			iny
.a9ca	51 63		eor ($63),y		eor  ($63),y
.a9cc	88		dey			dey
.a9cd	aa		tax			tax
.a9ce	68		pla			pla
.a9cf					L10032_END:
.a9cf					L10033:
>a9cf	02					.byte L10033_END-L10033-1
.a9d0	45 63		eor $63			eor  $63
.a9d2					L10033_END:
.a9d2					L10034:
>a9d2	0a					.byte L10034_END-L10034-1
.a9d3	4d 63 73	eor $7363		eor  $7363
.a9d6	48		pha			pha
.a9d7	8a		txa			txa
.a9d8	4d 83 73	eor $7383		eor  $7383
.a9db	aa		tax			tax
.a9dc	68		pla			pla
.a9dd					L10034_END:
.a9dd					L10035:
>a9dd	08					.byte L10035_END-L10035-1
.a9de	45 63		eor $63			eor  $63
.a9e0	48		pha			pha
.a9e1	8a		txa			txa
.a9e2	45 83		eor $83			eor  $83
.a9e4	aa		tax			tax
.a9e5	68		pla			pla
.a9e6					L10035_END:
.a9e6					L10036:
>a9e6	03					.byte L10036_END-L10036-1
.a9e7	4d 63 73	eor $7363		eor  $7363
.a9ea					L10036_END:
.a9ea					L10037:
>a9ea	02					.byte L10037_END-L10037-1
.a9eb	49 63		eor #$63		eor  #$63
.a9ed					L10037_END:
.a9ed					L10038:
>a9ed	02					.byte L10038_END-L10038-1
>a9ee	a3 03					.byte $a3,$03
.a9f0					L10038_END:
.a9f0					L10039:
>a9f0	02					.byte L10039_END-L10039-1
>a9f1	a3 04					.byte $a3,$04
.a9f3					L10039_END:
.a9f3					L10040:
>a9f3	03					.byte L10040_END-L10040-1
.a9f4	48		pha			pha
.a9f5	da		phx			phx
.a9f6	5a		phy			phy
.a9f7					L10040_END:
.a9f7					L10041:
>a9f7	04					.byte L10041_END-L10041-1
.a9f8	a9 63		lda #$63		lda  #$63
.a9fa	a2 73		ldx #$73		ldx  #$73
.a9fc					L10041_END:
.a9fc					L10042:
>a9fc	07					.byte L10042_END-L10042-1
.a9fd	c8		iny			iny
.a9fe	b1 63		lda ($63),y		lda  ($63),y
.aa00	aa		tax			tax
.aa01	88		dey			dey
.aa02	b1 63		lda ($63),y		lda  ($63),y
.aa04					L10042_END:
.aa04					L10043:
>aa04	04					.byte L10043_END-L10043-1
.aa05	a5 63		lda $63			lda  $63
.aa07	a2 00		ldx #$00		ldx  #0
.aa09					L10043_END:
.aa09					L10044:
>aa09	06					.byte L10044_END-L10044-1
.aa0a	ad 63 73	lda $7363		lda  $7363
.aa0d	ae 83 73	ldx $7383		ldx  $7383
.aa10					L10044_END:
.aa10					L10045:
>aa10	04					.byte L10045_END-L10045-1
.aa11	a5 63		lda $63			lda  $63
.aa13	a6 83		ldx $83			ldx  $83
.aa15					L10045_END:
.aa15					L10046:
>aa15	05					.byte L10046_END-L10046-1
.aa16	ad 63 73	lda $7363		lda  $7363
.aa19	a2 00		ldx #$00		ldx  #0
.aa1b					L10046_END:
.aa1b					L10047:
>aa1b	04					.byte L10047_END-L10047-1
.aa1c	a9 63		lda #$63		lda  #$63
.aa1e	a2 73		ldx #$73		ldx  #$73
.aa20					L10047_END:
.aa20					L10048:
>aa20	03					.byte L10048_END-L10048-1
.aa21	98		tya			tya
.aa22	a2 00		ldx #$00		ldx  #0
.aa24					L10048_END:
.aa24					L10049:
>aa24	02					.byte L10049_END-L10049-1
.aa25	a2 00		ldx #$00		ldx  #0
.aa27					L10049_END:
.aa27					L10050:
>aa27	09					.byte L10050_END-L10050-1
.aa28	c9 00		cmp #$00		cmp #0
.aa2a	d0 02		bne $aa2e		bne *+4
.aa2c	e0 00		cpx #$00		cpx #0
>aa2e	93					.byte $93
.aa2f	f0 fe		beq $aa2f		beq *
.aa31					L10050_END:
.aa31					L10051:
>aa31	09					.byte L10051_END-L10051-1
.aa32	c9 00		cmp #$00		cmp #0
.aa34	d0 02		bne $aa38		bne *+4
.aa36	e0 00		cpx #$00		cpx #0
>aa38	93					.byte $93
.aa39	d0 fe		bne $aa39		bne *
.aa3b					L10051_END:
.aa3b					L10052:
>aa3b	08					.byte L10052_END-L10052-1
.aa3c	09 63		ora #$63		ora  #$63
.aa3e	48		pha			pha
.aa3f	8a		txa			txa
.aa40	09 73		ora #$73		ora  #$73
.aa42	aa		tax			tax
.aa43	68		pla			pla
.aa44					L10052_END:
.aa44					L10053:
>aa44	0a					.byte L10053_END-L10053-1
.aa45	11 63		ora ($63),y		ora  ($63),y
.aa47	48		pha			pha
.aa48	8a		txa			txa
.aa49	c8		iny			iny
.aa4a	11 63		ora ($63),y		ora  ($63),y
.aa4c	88		dey			dey
.aa4d	aa		tax			tax
.aa4e	68		pla			pla
.aa4f					L10053_END:
.aa4f					L10054:
>aa4f	02					.byte L10054_END-L10054-1
.aa50	05 63		ora $63			ora  $63
.aa52					L10054_END:
.aa52					L10055:
>aa52	0a					.byte L10055_END-L10055-1
.aa53	0d 63 73	ora $7363		ora  $7363
.aa56	48		pha			pha
.aa57	8a		txa			txa
.aa58	0d 83 73	ora $7383		ora  $7383
.aa5b	aa		tax			tax
.aa5c	68		pla			pla
.aa5d					L10055_END:
.aa5d					L10056:
>aa5d	08					.byte L10056_END-L10056-1
.aa5e	05 63		ora $63			ora  $63
.aa60	48		pha			pha
.aa61	8a		txa			txa
.aa62	05 83		ora $83			ora  $83
.aa64	aa		tax			tax
.aa65	68		pla			pla
.aa66					L10056_END:
.aa66					L10057:
>aa66	03					.byte L10057_END-L10057-1
.aa67	0d 63 73	ora $7363		ora  $7363
.aa6a					L10057_END:
.aa6a					L10058:
>aa6a	02					.byte L10058_END-L10058-1
.aa6b	09 63		ora #$63		ora  #$63
.aa6d					L10058_END:
.aa6d					L10059:
>aa6d	03					.byte L10059_END-L10059-1
.aa6e	48		pha			pha
.aa6f	8a		txa			txa
.aa70	fa		plx			plx
.aa71					L10059_END:
.aa71					L10060:
>aa71	02					.byte L10060_END-L10060-1
>aa72	a3 05					.byte $a3,$05
.aa74					L10060_END:
.aa74					L10061:
>aa74	09					.byte L10061_END-L10061-1
.aa75	38		sec			sec
.aa76	e9 63		sbc #$63		sbc  #$63
.aa78	48		pha			pha
.aa79	8a		txa			txa
.aa7a	e9 73		sbc #$73		sbc  #$73
.aa7c	aa		tax			tax
.aa7d	68		pla			pla
.aa7e					L10061_END:
.aa7e					L10062:
>aa7e	0b					.byte L10062_END-L10062-1
.aa7f	38		sec			sec
.aa80	f1 63		sbc ($63),y		sbc  ($63),y
.aa82	48		pha			pha
.aa83	8a		txa			txa
.aa84	c8		iny			iny
.aa85	f1 63		sbc ($63),y		sbc  ($63),y
.aa87	88		dey			dey
.aa88	aa		tax			tax
.aa89	68		pla			pla
.aa8a					L10062_END:
.aa8a					L10063:
>aa8a	06					.byte L10063_END-L10063-1
.aa8b	38		sec			sec
.aa8c	e5 63		sbc $63			sbc  $63
.aa8e	b0 01		bcs $aa91		bcs  *+3
.aa90	ca		dex			dex
.aa91					L10063_END:
.aa91					L10064:
>aa91	0b					.byte L10064_END-L10064-1
.aa92	38		sec			sec
.aa93	ed 63 73	sbc $7363		sbc  $7363
.aa96	48		pha			pha
.aa97	8a		txa			txa
.aa98	ed 83 73	sbc $7383		sbc  $7383
.aa9b	aa		tax			tax
.aa9c	68		pla			pla
.aa9d					L10064_END:
.aa9d					L10065:
>aa9d	09					.byte L10065_END-L10065-1
.aa9e	38		sec			sec
.aa9f	e5 63		sbc $63			sbc  $63
.aaa1	48		pha			pha
.aaa2	8a		txa			txa
.aaa3	e5 83		sbc $83			sbc  $83
.aaa5	aa		tax			tax
.aaa6	68		pla			pla
.aaa7					L10065_END:
.aaa7					L10066:
>aaa7	07					.byte L10066_END-L10066-1
.aaa8	38		sec			sec
.aaa9	ed 63 73	sbc $7363		sbc  $7363
.aaac	b0 01		bcs $aaaf		bcs  *+3
.aaae	ca		dex			dex
.aaaf					L10066_END:
.aaaf					L10067:
>aaaf	06					.byte L10067_END-L10067-1
.aab0	38		sec			sec
.aab1	e9 63		sbc #$63		sbc  #$63
.aab3	b0 01		bcs $aab6		bcs  *+3
.aab5	ca		dex			dex
.aab6					L10067_END:
.aab6					L10068:
>aab6	05					.byte L10068_END-L10068-1
.aab7	e0 00		cpx #$00		cpx #0
>aab9	93					.byte $93
.aaba	30 fe		bmi $aaba		bmi *
.aabc					L10068_END:
.aabc					L10069:
>aabc	02					.byte L10069_END-L10069-1
.aabd	48		pha			pha
.aabe	da		phx			phx
.aabf					L10069_END:
.aabf					L10070:
>aabf	09					.byte L10070_END-L10070-1
.aac0	18		clc			clc
.aac1	69 63		adc #$63		adc  #$63
.aac3	48		pha			pha
.aac4	8a		txa			txa
.aac5	69 73		adc #$73		adc  #$73
.aac7	aa		tax			tax
.aac8	68		pla			pla
.aac9					L10070_END:
.aac9					L10071:
>aac9	0b					.byte L10071_END-L10071-1
.aaca	18		clc			clc
.aacb	71 63		adc ($63),y		adc  ($63),y
.aacd	48		pha			pha
.aace	8a		txa			txa
.aacf	c8		iny			iny
.aad0	71 63		adc ($63),y		adc  ($63),y
.aad2	88		dey			dey
.aad3	aa		tax			tax
.aad4	68		pla			pla
.aad5					L10071_END:
.aad5					L10072:
>aad5	06					.byte L10072_END-L10072-1
.aad6	18		clc			clc
.aad7	65 63		adc $63			adc  $63
.aad9	90 01		bcc $aadc		bcc  *+3
.aadb	e8		inx			inx
.aadc					L10072_END:
.aadc					L10073:
>aadc	0b					.byte L10073_END-L10073-1
.aadd	18		clc			clc
.aade	6d 63 73	adc $7363		adc  $7363
.aae1	48		pha			pha
.aae2	8a		txa			txa
.aae3	6d 83 73	adc $7383		adc  $7383
.aae6	aa		tax			tax
.aae7	68		pla			pla
.aae8					L10073_END:
.aae8					L10074:
>aae8	09					.byte L10074_END-L10074-1
.aae9	18		clc			clc
.aaea	65 63		adc $63			adc  $63
.aaec	48		pha			pha
.aaed	8a		txa			txa
.aaee	65 83		adc $83			adc  $83
.aaf0	aa		tax			tax
.aaf1	68		pla			pla
.aaf2					L10074_END:
.aaf2					L10075:
>aaf2	07					.byte L10075_END-L10075-1
.aaf3	18		clc			clc
.aaf4	6d 63 73	adc $7363		adc  $7363
.aaf7	90 01		bcc $aafa		bcc  *+3
.aaf9	e8		inx			inx
.aafa					L10075_END:
.aafa					L10076:
>aafa	06					.byte L10076_END-L10076-1
.aafb	18		clc			clc
.aafc	69 63		adc #$63		adc  #$63
.aafe	90 01		bcc $ab01		bcc  *+3
.ab00	e8		inx			inx
.ab01					L10076_END:
.ab01					L10077:
>ab01	05					.byte L10077_END-L10077-1
.ab02	e0 00		cpx #$00		cpx #0
>ab04	93					.byte $93
.ab05	10 fe		bpl $ab05		bpl *
.ab07					L10077_END:
.ab07					L10078:
>ab07	08					.byte L10078_END-L10078-1
.ab08	29 63		and #$63		and  #$63
.ab0a	48		pha			pha
.ab0b	8a		txa			txa
.ab0c	29 73		and #$73		and  #$73
.ab0e	aa		tax			tax
.ab0f	68		pla			pla
.ab10					L10078_END:
.ab10					L10079:
>ab10	0a					.byte L10079_END-L10079-1
.ab11	31 63		and ($63),y		and  ($63),y
.ab13	48		pha			pha
.ab14	8a		txa			txa
.ab15	c8		iny			iny
.ab16	31 63		and ($63),y		and  ($63),y
.ab18	88		dey			dey
.ab19	aa		tax			tax
.ab1a	68		pla			pla
.ab1b					L10079_END:
.ab1b					L10080:
>ab1b	04					.byte L10080_END-L10080-1
.ab1c	25 63		and $63			and  $63
.ab1e	a2 00		ldx #$00		ldx  #0
.ab20					L10080_END:
.ab20					L10081:
>ab20	0a					.byte L10081_END-L10081-1
.ab21	2d 63 73	and $7363		and  $7363
.ab24	48		pha			pha
.ab25	8a		txa			txa
.ab26	2d 83 73	and $7383		and  $7383
.ab29	aa		tax			tax
.ab2a	68		pla			pla
.ab2b					L10081_END:
.ab2b					L10082:
>ab2b	08					.byte L10082_END-L10082-1
.ab2c	25 63		and $63			and  $63
.ab2e	48		pha			pha
.ab2f	8a		txa			txa
.ab30	25 83		and $83			and  $83
.ab32	aa		tax			tax
.ab33	68		pla			pla
.ab34					L10082_END:
.ab34					L10083:
>ab34	05					.byte L10083_END-L10083-1
.ab35	2d 63 73	and $7363		and  $7363
.ab38	a2 00		ldx #$00		ldx  #0
.ab3a					L10083_END:
.ab3a					L10084:
>ab3a	04					.byte L10084_END-L10084-1
.ab3b	29 63		and #$63		and  #$63
.ab3d	a2 00		ldx #$00		ldx  #0
.ab3f					L10084_END:
.ab3f					L10085:
>ab3f	02					.byte L10085_END-L10085-1
>ab40	a3 06					.byte $a3,$06
.ab42					L10085_END:
.ab42					L10086:
>ab42	02					.byte L10086_END-L10086-1
>ab43	a3 07					.byte $a3,$07
.ab45					L10086_END:
.ab45					L10087:
>ab45	02					.byte L10087_END-L10087-1
>ab46	a3 08					.byte $a3,$08
.ab48					L10087_END:
.ab48					L10088:
>ab48	02					.byte L10088_END-L10088-1
>ab49	a3 09					.byte $a3,$09
.ab4b					L10088_END:
.ab4b					L10089:
>ab4b	02					.byte L10089_END-L10089-1
>ab4c	a3 0a					.byte $a3,$0a
.ab4e					L10089_END:
.ab4e					L10090:
>ab4e	02					.byte L10090_END-L10090-1
>ab4f	a3 0b					.byte $a3,$0b
.ab51					L10090_END:
.ab51					L10091:
>ab51	03					.byte L10091_END-L10091-1
>ab52	93					.byte $93
.ab53	b0 fe		bcs $ab53		bcs  *
.ab55					L10091_END:
.ab55					L10092:
>ab55	03					.byte L10092_END-L10092-1
>ab56	93					.byte $93
.ab57	90 fe		bcc $ab57		bcc  *
.ab59					L10092_END:
.ab59					L10093:
>ab59	02					.byte L10093_END-L10093-1
>ab5a	a3 0c					.byte $a3,$0c
.ab5c					L10093_END:
.ab5c					L10094:
>ab5c	01					.byte L10094_END-L10094-1
>ab5d	ff					.byte  $ff
.ab5e					L10094_END:
.ab5e					L10095:
>ab5e	02					.byte L10095_END-L10095-1
.ab5f	51 63		eor ($63),y		eor  ($63),y
.ab61					L10095_END:
.ab61					L10096:
>ab61	02					.byte L10096_END-L10096-1
.ab62	45 63		eor $63			eor  $63
.ab64					L10096_END:
.ab64					L10097:
>ab64	03					.byte L10097_END-L10097-1
.ab65	4d 63 73	eor $7363		eor  $7363
.ab68					L10097_END:
.ab68					L10098:
>ab68	02					.byte L10098_END-L10098-1
.ab69	49 63		eor #$63		eor  #$63
.ab6b					L10098_END:
.ab6b					L10099:
>ab6b	02					.byte L10099_END-L10099-1
.ab6c	b1 63		lda ($63),y		lda  ($63),y
.ab6e					L10099_END:
.ab6e					L10100:
>ab6e	02					.byte L10100_END-L10100-1
.ab6f	a5 63		lda $63			lda  $63
.ab71					L10100_END:
.ab71					L10101:
>ab71	03					.byte L10101_END-L10101-1
.ab72	ad 63 73	lda $7363		lda  $7363
.ab75					L10101_END:
.ab75					L10102:
>ab75	02					.byte L10102_END-L10102-1
.ab76	a9 63		lda #$63		lda  #$63
.ab78					L10102_END:
.ab78					L10103:
>ab78	01					.byte L10103_END-L10103-1
.ab79	98		tya			tya
.ab7a					L10103_END:
.ab7a					L10104:
>ab7a	00					.byte L10104_END-L10104-1
.ab7b					L10104_END:
.ab7b					L10105:
>ab7b	05					.byte L10105_END-L10105-1
.ab7c	c9 00		cmp #$00		cmp #0
>ab7e	93					.byte $93
.ab7f	f0 fe		beq $ab7f		beq *
.ab81					L10105_END:
.ab81					L10106:
>ab81	05					.byte L10106_END-L10106-1
.ab82	c9 00		cmp #$00		cmp #0
>ab84	93					.byte $93
.ab85	d0 fe		bne $ab85		bne *
.ab87					L10106_END:
.ab87					L10107:
>ab87	02					.byte L10107_END-L10107-1
.ab88	11 63		ora ($63),y		ora  ($63),y
.ab8a					L10107_END:
.ab8a					L10108:
>ab8a	02					.byte L10108_END-L10108-1
.ab8b	05 63		ora $63			ora  $63
.ab8d					L10108_END:
.ab8d					L10109:
>ab8d	03					.byte L10109_END-L10109-1
.ab8e	0d 63 73	ora $7363		ora  $7363
.ab91					L10109_END:
.ab91					L10110:
>ab91	02					.byte L10110_END-L10110-1
.ab92	09 63		ora #$63		ora  #$63
.ab94					L10110_END:
.ab94					L10111:
>ab94	02					.byte L10111_END-L10111-1
>ab95	a3 0d					.byte $a3,$0d
.ab97					L10111_END:
.ab97					L10112:
>ab97	03					.byte L10112_END-L10112-1
.ab98	38		sec			sec
.ab99	f1 63		sbc ($63),y		sbc  ($63),y
.ab9b					L10112_END:
.ab9b					L10113:
>ab9b	03					.byte L10113_END-L10113-1
.ab9c	38		sec			sec
.ab9d	e5 63		sbc $63			sbc  $63
.ab9f					L10113_END:
.ab9f					L10114:
>ab9f	04					.byte L10114_END-L10114-1
.aba0	38		sec			sec
.aba1	ed 63 73	sbc $7363		sbc  $7363
.aba4					L10114_END:
.aba4					L10115:
>aba4	03					.byte L10115_END-L10115-1
.aba5	38		sec			sec
.aba6	e9 63		sbc #$63		sbc  #$63
.aba8					L10115_END:
.aba8					L10116:
>aba8	05					.byte L10116_END-L10116-1
.aba9	c9 00		cmp #$00		cmp #0
>abab	93					.byte $93
.abac	30 fe		bmi $abac		bmi *
.abae					L10116_END:
.abae					L10117:
>abae	01					.byte L10117_END-L10117-1
.abaf	48		pha			pha
.abb0					L10117_END:
.abb0					L10118:
>abb0	03					.byte L10118_END-L10118-1
.abb1	18		clc			clc
.abb2	71 63		adc ($63),y		adc  ($63),y
.abb4					L10118_END:
.abb4					L10119:
>abb4	03					.byte L10119_END-L10119-1
.abb5	18		clc			clc
.abb6	65 63		adc $63			adc  $63
.abb8					L10119_END:
.abb8					L10120:
>abb8	04					.byte L10120_END-L10120-1
.abb9	18		clc			clc
.abba	6d 63 73	adc $7363		adc  $7363
.abbd					L10120_END:
.abbd					L10121:
>abbd	03					.byte L10121_END-L10121-1
.abbe	18		clc			clc
.abbf	69 63		adc #$63		adc  #$63
.abc1					L10121_END:
.abc1					L10122:
>abc1	05					.byte L10122_END-L10122-1
.abc2	c9 00		cmp #$00		cmp #0
>abc4	93					.byte $93
.abc5	10 fe		bpl $abc5		bpl *
.abc7					L10122_END:
.abc7					L10123:
>abc7	02					.byte L10123_END-L10123-1
.abc8	31 63		and ($63),y		and  ($63),y
.abca					L10123_END:
.abca					L10124:
>abca	02					.byte L10124_END-L10124-1
.abcb	25 63		and $63			and  $63
.abcd					L10124_END:
.abcd					L10125:
>abcd	03					.byte L10125_END-L10125-1
.abce	2d 63 73	and $7363		and  $7363
.abd1					L10125_END:
.abd1					L10126:
>abd1	02					.byte L10126_END-L10126-1
.abd2	29 63		and #$63		and  #$63
.abd4					L10126_END:
.abd4					L10127:
>abd4	02					.byte L10127_END-L10127-1
.abd5	46 63		lsr $63			lsr  $63
.abd7					L10127_END:
.abd7					L10128:
>abd7	06					.byte L10128_END-L10128-1
.abd8	4e 83 73	lsr $7383		lsr  $7383
.abdb	6e 63 73	ror $7363		ror  $7363
.abde					L10128_END:
.abde					L10129:
>abde	04					.byte L10129_END-L10129-1
.abdf	46 83		lsr $83			lsr  $83
.abe1	66 63		ror $63			ror  $63
.abe3					L10129_END:
.abe3					L10130:
>abe3	03					.byte L10130_END-L10130-1
.abe4	4e 63 73	lsr $7363		lsr  $7363
.abe7					L10130_END:
.abe7					L10131:
>abe7	06					.byte L10131_END-L10131-1
.abe8	48		pha			pha
.abe9	8a		txa			txa
.abea	4a		lsr a			lsr  a
.abeb	aa		tax			tax
.abec	68		pla			pla
.abed	6a		ror a			ror  a
.abee					L10131_END:
.abee					L10132:
>abee	01					.byte L10132_END-L10132-1
.abef	4a		lsr a			lsr  a
.abf0					L10132_END:
.abf0					L10133:
>abf0	02					.byte L10133_END-L10133-1
.abf1	06 63		asl $63			asl  $63
.abf3					L10133_END:
.abf3					L10134:
>abf3	06					.byte L10134_END-L10134-1
.abf4	0e 63 73	asl $7363		asl  $7363
.abf7	2e 83 73	rol $7383		rol  $7383
.abfa					L10134_END:
.abfa					L10135:
>abfa	04					.byte L10135_END-L10135-1
.abfb	06 63		asl $63			asl  $63
.abfd	26 83		rol $83			rol  $83
.abff					L10135_END:
.abff					L10136:
>abff	03					.byte L10136_END-L10136-1
.ac00	0e 63 73	asl $7363		asl  $7363
.ac03					L10136_END:
.ac03					L10137:
>ac03	06					.byte L10137_END-L10137-1
.ac04	0a		asl a			asl  a
.ac05	48		pha			pha
.ac06	8a		txa			txa
.ac07	2a		rol a			rol  a
.ac08	aa		tax			tax
.ac09	68		pla			pla
.ac0a					L10137_END:
.ac0a					L10138:
>ac0a	01					.byte L10138_END-L10138-1
.ac0b	0a		asl a			asl  a
.ac0c					L10138_END:
.ac0c					L10139:
>ac0c	0b					.byte L10139_END-L10139-1
.ac0d	8a		txa			txa
.ac0e	49 ff		eor #$ff		eor  #$ff
.ac10	aa		tax			tax
.ac11	68		pla			pla
.ac12	49 ff		eor #$ff		eor  #$ff
.ac14	1a		inc a			inc  a
.ac15	d0 01		bne $ac18		bne  *+3
.ac17	e8		inx			inx
.ac18					L10139_END:
.ac18					L10140:
>ac18	03					.byte L10140_END-L10140-1
.ac19	49 ff		eor #$ff		eor  #$ff
.ac1b	1a		inc a			inc  a
.ac1c					L10140_END:
.ac1c					L10141:
>ac1c	02					.byte L10141_END-L10141-1
.ac1d	c6 63		dec $63			dec  $63
.ac1f					L10141_END:
.ac1f					L10142:
>ac1f	0d					.byte L10142_END-L10142-1
.ac20	48		pha			pha
.ac21	ad 63 73	lda $7363		lda  $7363
.ac24	d0 03		bne $ac29		bne  _noborrow
.ac26	ce 83 73	dec $7383		dec  $7383
.ac29					_noborrow:
.ac29	ce 63 73	dec $7363		dec  $7363
.ac2c	68		pla			pla
.ac2d					L10142_END:
.ac2d					L10143:
>ac2d	0a					.byte L10143_END-L10143-1
.ac2e	48		pha			pha
.ac2f	a5 63		lda $63			lda  $63
.ac31	d0 02		bne $ac35		bne  _noborrow
.ac33	c6 83		dec $83			dec  $83
.ac35					_noborrow:
.ac35	c6 63		dec $63			dec  $63
.ac37	68		pla			pla
.ac38					L10143_END:
.ac38					L10144:
>ac38	03					.byte L10144_END-L10144-1
.ac39	ce 63 73	dec $7363		dec  $7363
.ac3c					L10144_END:
.ac3c					L10145:
>ac3c	01					.byte L10145_END-L10145-1
.ac3d	88		dey			dey
.ac3e					L10145_END:
.ac3e					L10146:
>ac3e	06					.byte L10146_END-L10146-1
.ac3f	c9 00		cmp #$00		cmp  #0
.ac41	d0 01		bne $ac44		bne  *+3
.ac43	ca		dex			dex
.ac44	3a		dec a			dec  a
.ac45					L10146_END:
.ac45					L10147:
>ac45	01					.byte L10147_END-L10147-1
.ac46	3a		dec a			dec  a
.ac47					L10147_END:
.ac47					L10148:
>ac47	02					.byte L10148_END-L10148-1
.ac48	e6 63		inc $63			inc  $63
.ac4a					L10148_END:
.ac4a					L10149:
>ac4a	08					.byte L10149_END-L10149-1
.ac4b	ee 63 73	inc $7363		inc  $7363
.ac4e	d0 03		bne $ac53		bne  _nocarry
.ac50	ee 83 73	inc $7383		inc  $7383
.ac53					_nocarry:
.ac53					L10149_END:
.ac53					L10150:
>ac53	06					.byte L10150_END-L10150-1
.ac54	e6 63		inc $63			inc  $63
.ac56	d0 02		bne $ac5a		bne  _nocarry
.ac58	e6 83		inc $83			inc  $83
.ac5a					_nocarry:
.ac5a					L10150_END:
.ac5a					L10151:
>ac5a	03					.byte L10151_END-L10151-1
.ac5b	ee 63 73	inc $7363		inc  $7363
.ac5e					L10151_END:
.ac5e					L10152:
>ac5e	01					.byte L10152_END-L10152-1
.ac5f	c8		iny			iny
.ac60					L10152_END:
.ac60					L10153:
>ac60	04					.byte L10153_END-L10153-1
.ac61	1a		inc a			inc  a
.ac62	d0 01		bne $ac65		bne  *+3
.ac64	e8		inx			inx
.ac65					L10153_END:
.ac65					L10154:
>ac65	01					.byte L10154_END-L10154-1
.ac66	1a		inc a			inc  a
.ac67					L10154_END:
.ac67					ExecutableVectorTable:
>ac67	8f a5					.word Action_call                      ; 0
>ac69	22 a7					.word Action_wordvar                   ; 1
>ac6b	78 a6					.word Action_until                     ; 2
>ac6d	6f a6					.word Action_repeat                    ; 3
>ac6f	91 a7					.word Action_dictionarycrunch          ; 4
>ac71	9f a6					.word Action_rfor                      ; 5
>ac73	48 a5					.word Action_procedure_def             ; 6
>ac75	d0 a6					.word Action_next                      ; 7
>ac77	0a a6					.word Action_if                        ; 8
>ac79	7f a5					.word Action_endproc                   ; 9
>ac7b	41 a6					.word Action_endif                     ; 10
>ac7d	1f a6					.word Action_else                      ; 11
>ac7f	1e a7					.word Action_bytevar                   ; 12
>ac81	8c a6					.word Action_afor                      ; 13
.ac83					SystemDictionary:
>ac83	07					.byte	7
>ac84	4d					.byte	'M'
>ac85	3d a9					.word	L10000
>ac87	00					.byte	0
>ac88	01					.byte	1
>ac89	f7					.byte	$f7
>ac8a	0c					.byte	12
>ac8b	4d					.byte	'M'
>ac8c	42 a9					.word	L10001
>ac8e	00					.byte	0
>ac8f	06					.byte	6
>ac90	f3 db d9 dd bd d2			.byte	$f3,$db,$d9,$dd,$bd,$d2
>ac96	0c					.byte	12
>ac97	4d					.byte	'M'
>ac98	4c a9					.word	L10002
>ac9a	00					.byte	0
>ac9b	06					.byte	6
>ac9c	f3 db d9 dd bd c1			.byte	$f3,$db,$d9,$dd,$bd,$c1
>aca2	09					.byte	9
>aca3	4d					.byte	'M'
>aca4	4f a9					.word	L10003
>aca6	00					.byte	0
>aca7	03					.byte	3
>aca8	f3 bd d9				.byte	$f3,$bd,$d9
>acab	09					.byte	9
>acac	4d					.byte	'M'
>acad	52 a9					.word	L10004
>acaf	00					.byte	0
>acb0	03					.byte	3
>acb1	f3 bd d2				.byte	$f3,$bd,$d2
>acb4	09					.byte	9
>acb5	4d					.byte	'M'
>acb6	55 a9					.word	L10005
>acb8	00					.byte	0
>acb9	03					.byte	3
>acba	f3 bd c1				.byte	$f3,$bd,$c1
>acbd	07					.byte	7
>acbe	4d					.byte	'M'
>acbf	58 a9					.word	L10006
>acc1	00					.byte	0
>acc2	01					.byte	1
>acc3	f3					.byte	$f3
>acc4	07					.byte	7
>acc5	4d					.byte	'M'
>acc6	5d a9					.word	L10007
>acc8	00					.byte	0
>acc9	01					.byte	1
>acca	f0					.byte	$f0
>accb	09					.byte	9
>accc	4d					.byte	'M'
>accd	60 a9					.word	L10008
>accf	00					.byte	0
>acd0	03					.byte	3
>acd1	ec bd d2				.byte	$ec,$bd,$d2
>acd4	07					.byte	7
>acd5	4d					.byte	'M'
>acd6	67 a9					.word	L10009
>acd8	00					.byte	0
>acd9	01					.byte	1
>acda	ec					.byte	$ec
>acdb	09					.byte	9
>acdc	4d					.byte	'M'
>acdd	6e a9					.word	L10010
>acdf	00					.byte	0
>ace0	03					.byte	3
>ace1	e9 bd d2				.byte	$e9,$bd,$d2
>ace4	07					.byte	7
>ace5	4d					.byte	'M'
>ace6	73 a9					.word	L10011
>ace8	00					.byte	0
>ace9	01					.byte	1
>acea	e9					.byte	$e9
>aceb	09					.byte	9
>acec	4d					.byte	'M'
>aced	78 a9					.word	L10012
>acef	00					.byte	0
>acf0	03					.byte	3
>acf1	e3 bd d9				.byte	$e3,$bd,$d9
>acf4	09					.byte	9
>acf5	4d					.byte	'M'
>acf6	7c a9					.word	L10013
>acf8	00					.byte	0
>acf9	03					.byte	3
>acfa	e3 bd d2				.byte	$e3,$bd,$d2
>acfd	09					.byte	9
>acfe	4d					.byte	'M'
>acff	80 a9					.word	L10014
>ad01	00					.byte	0
>ad02	03					.byte	3
>ad03	e3 bd c1				.byte	$e3,$bd,$c1
>ad06	07					.byte	7
>ad07	4d					.byte	'M'
>ad08	84 a9					.word	L10015
>ad0a	00					.byte	0
>ad0b	01					.byte	1
>ad0c	e3					.byte	$e3
>ad0d	07					.byte	7
>ad0e	4d					.byte	'M'
>ad0f	8a a9					.word	L10016
>ad11	00					.byte	0
>ad12	01					.byte	1
>ad13	e2					.byte	$e2
>ad14	0b					.byte	11
>ad15	4d					.byte	'M'
>ad16	8f a9					.word	L10017
>ad18	00					.byte	0
>ad19	05					.byte	5
>ad1a	de 52 50 48 c1				.byte	$de,$52,$50,$48,$c1
>ad1f	08					.byte	8
>ad20	4d					.byte	'M'
>ad21	97 a9					.word	L10018
>ad23	00					.byte	0
>ad24	02					.byte	2
>ad25	de c1					.byte	$de,$c1
>ad27	09					.byte	9
>ad28	4d					.byte	'M'
>ad29	9a a9					.word	L10019
>ad2b	00					.byte	0
>ad2c	03					.byte	3
>ad2d	d9 bd f3				.byte	$d9,$bd,$f3
>ad30	09					.byte	9
>ad31	4d					.byte	'M'
>ad32	9d a9					.word	L10020
>ad34	00					.byte	0
>ad35	03					.byte	3
>ad36	d9 bd e3				.byte	$d9,$bd,$e3
>ad39	09					.byte	9
>ad3a	4d					.byte	'M'
>ad3b	a1 a9					.word	L10021
>ad3d	00					.byte	0
>ad3e	03					.byte	3
>ad3f	d9 bd e2				.byte	$d9,$bd,$e2
>ad42	09					.byte	9
>ad43	4d					.byte	'M'
>ad44	a4 a9					.word	L10022
>ad46	00					.byte	0
>ad47	03					.byte	3
>ad48	d9 bd d2				.byte	$d9,$bd,$d2
>ad4b	09					.byte	9
>ad4c	4d					.byte	'M'
>ad4d	a6 a9					.word	L10023
>ad4f	00					.byte	0
>ad50	03					.byte	3
>ad51	d9 bd c1				.byte	$d9,$bd,$c1
>ad54	0a					.byte	10
>ad55	4d					.byte	'M'
>ad56	a8 a9					.word	L10024
>ad58	00					.byte	0
>ad59	04					.byte	4
>ad5a	d9 ad be d3				.byte	$d9,$ad,$be,$d3
>ad5e	0a					.byte	10
>ad5f	4d					.byte	'M'
>ad60	aa a9					.word	L10025
>ad62	00					.byte	0
>ad63	04					.byte	4
>ad64	57 4f 52 c4				.byte	$57,$4f,$52,$c4
>ad68	0b					.byte	11
>ad69	4d					.byte	'M'
>ad6a	ad a9					.word	L10026
>ad6c	00					.byte	0
>ad6d	05					.byte	5
>ad6e	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
>ad73	0a					.byte	10
>ad74	4d					.byte	'M'
>ad75	b0 a9					.word	L10027
>ad77	00					.byte	0
>ad78	04					.byte	4
>ad79	d3 ad be d9				.byte	$d3,$ad,$be,$d9
>ad7d	0c					.byte	12
>ad7e	4d					.byte	'M'
>ad7f	b2 a9					.word	L10028
>ad81	00					.byte	0
>ad82	06					.byte	6
>ad83	d3 ad be 52 41 d9			.byte	$d3,$ad,$be,$52,$41,$d9
>ad89	0a					.byte	10
>ad8a	4d					.byte	'M'
>ad8b	b6 a9					.word	L10029
>ad8d	00					.byte	0
>ad8e	04					.byte	4
>ad8f	d3 ad be d2				.byte	$d3,$ad,$be,$d2
>ad93	0a					.byte	10
>ad94	4d					.byte	'M'
>ad95	b9 a9					.word	L10030
>ad97	00					.byte	0
>ad98	04					.byte	4
>ad99	d3 ad be c1				.byte	$d3,$ad,$be,$c1
>ad9d	09					.byte	9
>ad9e	4d					.byte	'M'
>ad9f	bb a9					.word	L10031
>ada1	00					.byte	0
>ada2	03					.byte	3
>ada3	d2 f7 f7				.byte	$d2,$f7,$f7
>ada6	0c					.byte	12
>ada7	4d					.byte	'M'
>ada8	c4 a9					.word	L10032
>adaa	00					.byte	0
>adab	06					.byte	6
>adac	d2 f3 f3 db d9 dd			.byte	$d2,$f3,$f3,$db,$d9,$dd
>adb2	09					.byte	9
>adb3	4d					.byte	'M'
>adb4	cf a9					.word	L10033
>adb6	00					.byte	0
>adb7	03					.byte	3
>adb8	d2 f3 f3				.byte	$d2,$f3,$f3
>adbb	09					.byte	9
>adbc	4d					.byte	'M'
>adbd	d2 a9					.word	L10034
>adbf	00					.byte	0
>adc0	03					.byte	3
>adc1	d2 ec ec				.byte	$d2,$ec,$ec
>adc4	09					.byte	9
>adc5	4d					.byte	'M'
>adc6	dd a9					.word	L10035
>adc8	00					.byte	0
>adc9	03					.byte	3
>adca	d2 e9 e9				.byte	$d2,$e9,$e9
>adcd	09					.byte	9
>adce	4d					.byte	'M'
>adcf	e6 a9					.word	L10036
>add1	00					.byte	0
>add2	03					.byte	3
>add3	d2 e3 e3				.byte	$d2,$e3,$e3
>add6	09					.byte	9
>add7	4d					.byte	'M'
>add8	ea a9					.word	L10037
>adda	00					.byte	0
>addb	03					.byte	3
>addc	d2 e2 e2				.byte	$d2,$e2,$e2
>addf	0c					.byte	12
>ade0	4d					.byte	'M'
>ade1	ed a9					.word	L10038
>ade3	00					.byte	0
>ade4	06					.byte	6
>ade5	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
>adeb	13					.byte	19
>adec	4d					.byte	'M'
>aded	f0 a9					.word	L10039
>adef	00					.byte	0
>adf0	0d					.byte	13
>adf1	52 45 4d 4f 56 45 2e 4c			.byte	$52,$45,$4d,$4f,$56,$45,$2e,$4c,$4f,$43,$41,$4c,$d3
>adf9	4f 43 41 4c d3
>adfe	0c					.byte	12
>adff	4d					.byte	'M'
>ae00	f3 a9					.word	L10040
>ae02	00					.byte	0
>ae03	06					.byte	6
>ae04	52 41 d9 ad be d3			.byte	$52,$41,$d9,$ad,$be,$d3
>ae0a	09					.byte	9
>ae0b	4d					.byte	'M'
>ae0c	f7 a9					.word	L10041
>ae0e	00					.byte	0
>ae0f	03					.byte	3
>ae10	d2 bd f7				.byte	$d2,$bd,$f7
>ae13	0c					.byte	12
>ae14	4d					.byte	'M'
>ae15	fc a9					.word	L10042
>ae17	00					.byte	0
>ae18	06					.byte	6
>ae19	d2 bd f3 db d9 dd			.byte	$d2,$bd,$f3,$db,$d9,$dd
>ae1f	09					.byte	9
>ae20	4d					.byte	'M'
>ae21	04 aa					.word	L10043
>ae23	00					.byte	0
>ae24	03					.byte	3
>ae25	d2 bd f3				.byte	$d2,$bd,$f3
>ae28	09					.byte	9
>ae29	4d					.byte	'M'
>ae2a	09 aa					.word	L10044
>ae2c	00					.byte	0
>ae2d	03					.byte	3
>ae2e	d2 bd ec				.byte	$d2,$bd,$ec
>ae31	09					.byte	9
>ae32	4d					.byte	'M'
>ae33	10 aa					.word	L10045
>ae35	00					.byte	0
>ae36	03					.byte	3
>ae37	d2 bd e9				.byte	$d2,$bd,$e9
>ae3a	09					.byte	9
>ae3b	4d					.byte	'M'
>ae3c	15 aa					.word	L10046
>ae3e	00					.byte	0
>ae3f	03					.byte	3
>ae40	d2 bd e3				.byte	$d2,$bd,$e3
>ae43	09					.byte	9
>ae44	4d					.byte	'M'
>ae45	1b aa					.word	L10047
>ae47	00					.byte	0
>ae48	03					.byte	3
>ae49	d2 bd e2				.byte	$d2,$bd,$e2
>ae4c	09					.byte	9
>ae4d	4d					.byte	'M'
>ae4e	20 aa					.word	L10048
>ae50	00					.byte	0
>ae51	03					.byte	3
>ae52	d2 bd d9				.byte	$d2,$bd,$d9
>ae55	09					.byte	9
>ae56	4d					.byte	'M'
>ae57	24 aa					.word	L10049
>ae59	00					.byte	0
>ae5a	03					.byte	3
>ae5b	d2 bd c1				.byte	$d2,$bd,$c1
>ae5e	09					.byte	9
>ae5f	4d					.byte	'M'
>ae60	27 aa					.word	L10050
>ae62	00					.byte	0
>ae63	03					.byte	3
>ae64	d2 bd bf				.byte	$d2,$bd,$bf
>ae67	0a					.byte	10
>ae68	4d					.byte	'M'
>ae69	31 aa					.word	L10051
>ae6b	00					.byte	0
>ae6c	04					.byte	4
>ae6d	d2 bc be bf				.byte	$d2,$bc,$be,$bf
>ae71	09					.byte	9
>ae72	4d					.byte	'M'
>ae73	3b aa					.word	L10052
>ae75	00					.byte	0
>ae76	03					.byte	3
>ae77	d2 ba f7				.byte	$d2,$ba,$f7
>ae7a	0c					.byte	12
>ae7b	4d					.byte	'M'
>ae7c	44 aa					.word	L10053
>ae7e	00					.byte	0
>ae7f	06					.byte	6
>ae80	d2 ba f3 db d9 dd			.byte	$d2,$ba,$f3,$db,$d9,$dd
>ae86	09					.byte	9
>ae87	4d					.byte	'M'
>ae88	4f aa					.word	L10054
>ae8a	00					.byte	0
>ae8b	03					.byte	3
>ae8c	d2 ba f3				.byte	$d2,$ba,$f3
>ae8f	09					.byte	9
>ae90	4d					.byte	'M'
>ae91	52 aa					.word	L10055
>ae93	00					.byte	0
>ae94	03					.byte	3
>ae95	d2 ba ec				.byte	$d2,$ba,$ec
>ae98	09					.byte	9
>ae99	4d					.byte	'M'
>ae9a	5d aa					.word	L10056
>ae9c	00					.byte	0
>ae9d	03					.byte	3
>ae9e	d2 ba e9				.byte	$d2,$ba,$e9
>aea1	09					.byte	9
>aea2	4d					.byte	'M'
>aea3	66 aa					.word	L10057
>aea5	00					.byte	0
>aea6	03					.byte	3
>aea7	d2 ba e3				.byte	$d2,$ba,$e3
>aeaa	09					.byte	9
>aeab	4d					.byte	'M'
>aeac	6a aa					.word	L10058
>aeae	00					.byte	0
>aeaf	03					.byte	3
>aeb0	d2 ba e2				.byte	$d2,$ba,$e2
>aeb3	0c					.byte	12
>aeb4	4d					.byte	'M'
>aeb5	6d aa					.word	L10059
>aeb7	00					.byte	0
>aeb8	06					.byte	6
>aeb9	52 2e 53 57 41 d0			.byte	$52,$2e,$53,$57,$41,$d0
>aebf	0b					.byte	11
>aec0	4d					.byte	'M'
>aec1	71 aa					.word	L10060
>aec3	00					.byte	0
>aec4	05					.byte	5
>aec5	52 2e 46 4f d2				.byte	$52,$2e,$46,$4f,$d2
>aeca	09					.byte	9
>aecb	4d					.byte	'M'
>aecc	74 aa					.word	L10061
>aece	00					.byte	0
>aecf	03					.byte	3
>aed0	d2 ad f7				.byte	$d2,$ad,$f7
>aed3	0c					.byte	12
>aed4	4d					.byte	'M'
>aed5	7e aa					.word	L10062
>aed7	00					.byte	0
>aed8	06					.byte	6
>aed9	d2 ad f3 db d9 dd			.byte	$d2,$ad,$f3,$db,$d9,$dd
>aedf	09					.byte	9
>aee0	4d					.byte	'M'
>aee1	8a aa					.word	L10063
>aee3	00					.byte	0
>aee4	03					.byte	3
>aee5	d2 ad f3				.byte	$d2,$ad,$f3
>aee8	09					.byte	9
>aee9	4d					.byte	'M'
>aeea	91 aa					.word	L10064
>aeec	00					.byte	0
>aeed	03					.byte	3
>aeee	d2 ad ec				.byte	$d2,$ad,$ec
>aef1	09					.byte	9
>aef2	4d					.byte	'M'
>aef3	9d aa					.word	L10065
>aef5	00					.byte	0
>aef6	03					.byte	3
>aef7	d2 ad e9				.byte	$d2,$ad,$e9
>aefa	09					.byte	9
>aefb	4d					.byte	'M'
>aefc	a7 aa					.word	L10066
>aefe	00					.byte	0
>aeff	03					.byte	3
>af00	d2 ad e3				.byte	$d2,$ad,$e3
>af03	09					.byte	9
>af04	4d					.byte	'M'
>af05	af aa					.word	L10067
>af07	00					.byte	0
>af08	03					.byte	3
>af09	d2 ad e2				.byte	$d2,$ad,$e2
>af0c	09					.byte	9
>af0d	4d					.byte	'M'
>af0e	b6 aa					.word	L10068
>af10	00					.byte	0
>af11	03					.byte	3
>af12	d2 ad bf				.byte	$d2,$ad,$bf
>af15	0a					.byte	10
>af16	4d					.byte	'M'
>af17	bc aa					.word	L10069
>af19	00					.byte	0
>af1a	04					.byte	4
>af1b	d2 ad be d3				.byte	$d2,$ad,$be,$d3
>af1f	09					.byte	9
>af20	4d					.byte	'M'
>af21	bf aa					.word	L10070
>af23	00					.byte	0
>af24	03					.byte	3
>af25	d2 ab f7				.byte	$d2,$ab,$f7
>af28	0c					.byte	12
>af29	4d					.byte	'M'
>af2a	c9 aa					.word	L10071
>af2c	00					.byte	0
>af2d	06					.byte	6
>af2e	d2 ab f3 db d9 dd			.byte	$d2,$ab,$f3,$db,$d9,$dd
>af34	09					.byte	9
>af35	4d					.byte	'M'
>af36	d5 aa					.word	L10072
>af38	00					.byte	0
>af39	03					.byte	3
>af3a	d2 ab f3				.byte	$d2,$ab,$f3
>af3d	09					.byte	9
>af3e	4d					.byte	'M'
>af3f	dc aa					.word	L10073
>af41	00					.byte	0
>af42	03					.byte	3
>af43	d2 ab ec				.byte	$d2,$ab,$ec
>af46	09					.byte	9
>af47	4d					.byte	'M'
>af48	e8 aa					.word	L10074
>af4a	00					.byte	0
>af4b	03					.byte	3
>af4c	d2 ab e9				.byte	$d2,$ab,$e9
>af4f	09					.byte	9
>af50	4d					.byte	'M'
>af51	f2 aa					.word	L10075
>af53	00					.byte	0
>af54	03					.byte	3
>af55	d2 ab e3				.byte	$d2,$ab,$e3
>af58	09					.byte	9
>af59	4d					.byte	'M'
>af5a	fa aa					.word	L10076
>af5c	00					.byte	0
>af5d	03					.byte	3
>af5e	d2 ab e2				.byte	$d2,$ab,$e2
>af61	09					.byte	9
>af62	4d					.byte	'M'
>af63	01 ab					.word	L10077
>af65	00					.byte	0
>af66	03					.byte	3
>af67	d2 ab bf				.byte	$d2,$ab,$bf
>af6a	09					.byte	9
>af6b	4d					.byte	'M'
>af6c	07 ab					.word	L10078
>af6e	00					.byte	0
>af6f	03					.byte	3
>af70	d2 a6 f7				.byte	$d2,$a6,$f7
>af73	0c					.byte	12
>af74	4d					.byte	'M'
>af75	10 ab					.word	L10079
>af77	00					.byte	0
>af78	06					.byte	6
>af79	d2 a6 f3 db d9 dd			.byte	$d2,$a6,$f3,$db,$d9,$dd
>af7f	09					.byte	9
>af80	4d					.byte	'M'
>af81	1b ab					.word	L10080
>af83	00					.byte	0
>af84	03					.byte	3
>af85	d2 a6 f3				.byte	$d2,$a6,$f3
>af88	09					.byte	9
>af89	4d					.byte	'M'
>af8a	20 ab					.word	L10081
>af8c	00					.byte	0
>af8d	03					.byte	3
>af8e	d2 a6 ec				.byte	$d2,$a6,$ec
>af91	09					.byte	9
>af92	4d					.byte	'M'
>af93	2b ab					.word	L10082
>af95	00					.byte	0
>af96	03					.byte	3
>af97	d2 a6 e9				.byte	$d2,$a6,$e9
>af9a	09					.byte	9
>af9b	4d					.byte	'M'
>af9c	34 ab					.word	L10083
>af9e	00					.byte	0
>af9f	03					.byte	3
>afa0	d2 a6 e3				.byte	$d2,$a6,$e3
>afa3	09					.byte	9
>afa4	4d					.byte	'M'
>afa5	3a ab					.word	L10084
>afa7	00					.byte	0
>afa8	03					.byte	3
>afa9	d2 a6 e2				.byte	$d2,$a6,$e2
>afac	0a					.byte	10
>afad	4d					.byte	'M'
>afae	3f ab					.word	L10085
>afb0	00					.byte	0
>afb1	04					.byte	4
>afb2	50 52 4f c3				.byte	$50,$52,$4f,$c3
>afb6	0a					.byte	10
>afb7	4d					.byte	'M'
>afb8	42 ab					.word	L10086
>afba	00					.byte	0
>afbb	04					.byte	4
>afbc	4e 45 58 d4				.byte	$4e,$45,$58,$d4
>afc0	08					.byte	8
>afc1	4d					.byte	'M'
>afc2	45 ab					.word	L10087
>afc4	00					.byte	0
>afc5	02					.byte	2
>afc6	49 c6					.byte	$49,$c6
>afc8	0d					.byte	13
>afc9	4d					.byte	'M'
>afca	48 ab					.word	L10088
>afcc	00					.byte	0
>afcd	07					.byte	7
>afce	45 4e 44 50 52 4f c3			.byte	$45,$4e,$44,$50,$52,$4f,$c3
>afd5	0b					.byte	11
>afd6	4d					.byte	'M'
>afd7	4b ab					.word	L10089
>afd9	00					.byte	0
>afda	05					.byte	5
>afdb	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
>afe0	0a					.byte	10
>afe1	4d					.byte	'M'
>afe2	4e ab					.word	L10090
>afe4	00					.byte	0
>afe5	04					.byte	4
>afe6	45 4c 53 c5				.byte	$45,$4c,$53,$c5
>afea	09					.byte	9
>afeb	4d					.byte	'M'
>afec	51 ab					.word	L10091
>afee	00					.byte	0
>afef	03					.byte	3
>aff0	43 d3 bf				.byte	$43,$d3,$bf
>aff3	09					.byte	9
>aff4	4d					.byte	'M'
>aff5	55 ab					.word	L10092
>aff7	00					.byte	0
>aff8	03					.byte	3
>aff9	43 c3 bf				.byte	$43,$c3,$bf
>affc	0a					.byte	10
>affd	4d					.byte	'M'
>affe	59 ab					.word	L10093
>b000	00					.byte	0
>b001	04					.byte	4
>b002	42 59 54 c5				.byte	$42,$59,$54,$c5
>b006	0b					.byte	11
>b007	4d					.byte	'M'
>b008	5c ab					.word	L10094
>b00a	00					.byte	0
>b00b	05					.byte	5
>b00c	42 52 45 41 cb				.byte	$42,$52,$45,$41,$cb
>b011	0c					.byte	12
>b012	4d					.byte	'M'
>b013	5e ab					.word	L10095
>b015	00					.byte	0
>b016	06					.byte	6
>b017	c1 f3 f3 db d9 dd			.byte	$c1,$f3,$f3,$db,$d9,$dd
>b01d	09					.byte	9
>b01e	4d					.byte	'M'
>b01f	61 ab					.word	L10096
>b021	00					.byte	0
>b022	03					.byte	3
>b023	c1 f3 f3				.byte	$c1,$f3,$f3
>b026	09					.byte	9
>b027	4d					.byte	'M'
>b028	64 ab					.word	L10097
>b02a	00					.byte	0
>b02b	03					.byte	3
>b02c	c1 e3 e3				.byte	$c1,$e3,$e3
>b02f	09					.byte	9
>b030	4d					.byte	'M'
>b031	68 ab					.word	L10098
>b033	00					.byte	0
>b034	03					.byte	3
>b035	c1 e2 e2				.byte	$c1,$e2,$e2
>b038	0c					.byte	12
>b039	4d					.byte	'M'
>b03a	6b ab					.word	L10099
>b03c	00					.byte	0
>b03d	06					.byte	6
>b03e	c1 bd f3 db d9 dd			.byte	$c1,$bd,$f3,$db,$d9,$dd
>b044	09					.byte	9
>b045	4d					.byte	'M'
>b046	6e ab					.word	L10100
>b048	00					.byte	0
>b049	03					.byte	3
>b04a	c1 bd f3				.byte	$c1,$bd,$f3
>b04d	09					.byte	9
>b04e	4d					.byte	'M'
>b04f	71 ab					.word	L10101
>b051	00					.byte	0
>b052	03					.byte	3
>b053	c1 bd e3				.byte	$c1,$bd,$e3
>b056	09					.byte	9
>b057	4d					.byte	'M'
>b058	75 ab					.word	L10102
>b05a	00					.byte	0
>b05b	03					.byte	3
>b05c	c1 bd e2				.byte	$c1,$bd,$e2
>b05f	09					.byte	9
>b060	4d					.byte	'M'
>b061	78 ab					.word	L10103
>b063	00					.byte	0
>b064	03					.byte	3
>b065	c1 bd d9				.byte	$c1,$bd,$d9
>b068	09					.byte	9
>b069	4d					.byte	'M'
>b06a	7a ab					.word	L10104
>b06c	00					.byte	0
>b06d	03					.byte	3
>b06e	c1 bd d2				.byte	$c1,$bd,$d2
>b071	09					.byte	9
>b072	4d					.byte	'M'
>b073	7b ab					.word	L10105
>b075	00					.byte	0
>b076	03					.byte	3
>b077	c1 bd bf				.byte	$c1,$bd,$bf
>b07a	0a					.byte	10
>b07b	4d					.byte	'M'
>b07c	81 ab					.word	L10106
>b07e	00					.byte	0
>b07f	04					.byte	4
>b080	c1 bc be bf				.byte	$c1,$bc,$be,$bf
>b084	0c					.byte	12
>b085	4d					.byte	'M'
>b086	87 ab					.word	L10107
>b088	00					.byte	0
>b089	06					.byte	6
>b08a	c1 ba f3 db d9 dd			.byte	$c1,$ba,$f3,$db,$d9,$dd
>b090	09					.byte	9
>b091	4d					.byte	'M'
>b092	8a ab					.word	L10108
>b094	00					.byte	0
>b095	03					.byte	3
>b096	c1 ba f3				.byte	$c1,$ba,$f3
>b099	09					.byte	9
>b09a	4d					.byte	'M'
>b09b	8d ab					.word	L10109
>b09d	00					.byte	0
>b09e	03					.byte	3
>b09f	c1 ba e3				.byte	$c1,$ba,$e3
>b0a2	09					.byte	9
>b0a3	4d					.byte	'M'
>b0a4	91 ab					.word	L10110
>b0a6	00					.byte	0
>b0a7	03					.byte	3
>b0a8	c1 ba e2				.byte	$c1,$ba,$e2
>b0ab	0b					.byte	11
>b0ac	4d					.byte	'M'
>b0ad	94 ab					.word	L10111
>b0af	00					.byte	0
>b0b0	05					.byte	5
>b0b1	41 2e 46 4f d2				.byte	$41,$2e,$46,$4f,$d2
>b0b6	0c					.byte	12
>b0b7	4d					.byte	'M'
>b0b8	97 ab					.word	L10112
>b0ba	00					.byte	0
>b0bb	06					.byte	6
>b0bc	c1 ad f3 db d9 dd			.byte	$c1,$ad,$f3,$db,$d9,$dd
>b0c2	09					.byte	9
>b0c3	4d					.byte	'M'
>b0c4	9b ab					.word	L10113
>b0c6	00					.byte	0
>b0c7	03					.byte	3
>b0c8	c1 ad f3				.byte	$c1,$ad,$f3
>b0cb	09					.byte	9
>b0cc	4d					.byte	'M'
>b0cd	9f ab					.word	L10114
>b0cf	00					.byte	0
>b0d0	03					.byte	3
>b0d1	c1 ad e3				.byte	$c1,$ad,$e3
>b0d4	09					.byte	9
>b0d5	4d					.byte	'M'
>b0d6	a4 ab					.word	L10115
>b0d8	00					.byte	0
>b0d9	03					.byte	3
>b0da	c1 ad e2				.byte	$c1,$ad,$e2
>b0dd	09					.byte	9
>b0de	4d					.byte	'M'
>b0df	a8 ab					.word	L10116
>b0e1	00					.byte	0
>b0e2	03					.byte	3
>b0e3	c1 ad bf				.byte	$c1,$ad,$bf
>b0e6	0a					.byte	10
>b0e7	4d					.byte	'M'
>b0e8	ae ab					.word	L10117
>b0ea	00					.byte	0
>b0eb	04					.byte	4
>b0ec	c1 ad be d3				.byte	$c1,$ad,$be,$d3
>b0f0	0c					.byte	12
>b0f1	4d					.byte	'M'
>b0f2	b0 ab					.word	L10118
>b0f4	00					.byte	0
>b0f5	06					.byte	6
>b0f6	c1 ab f3 db d9 dd			.byte	$c1,$ab,$f3,$db,$d9,$dd
>b0fc	09					.byte	9
>b0fd	4d					.byte	'M'
>b0fe	b4 ab					.word	L10119
>b100	00					.byte	0
>b101	03					.byte	3
>b102	c1 ab f3				.byte	$c1,$ab,$f3
>b105	09					.byte	9
>b106	4d					.byte	'M'
>b107	b8 ab					.word	L10120
>b109	00					.byte	0
>b10a	03					.byte	3
>b10b	c1 ab e3				.byte	$c1,$ab,$e3
>b10e	09					.byte	9
>b10f	4d					.byte	'M'
>b110	bd ab					.word	L10121
>b112	00					.byte	0
>b113	03					.byte	3
>b114	c1 ab e2				.byte	$c1,$ab,$e2
>b117	09					.byte	9
>b118	4d					.byte	'M'
>b119	c1 ab					.word	L10122
>b11b	00					.byte	0
>b11c	03					.byte	3
>b11d	c1 ab bf				.byte	$c1,$ab,$bf
>b120	0c					.byte	12
>b121	4d					.byte	'M'
>b122	c7 ab					.word	L10123
>b124	00					.byte	0
>b125	06					.byte	6
>b126	c1 a6 f3 db d9 dd			.byte	$c1,$a6,$f3,$db,$d9,$dd
>b12c	09					.byte	9
>b12d	4d					.byte	'M'
>b12e	ca ab					.word	L10124
>b130	00					.byte	0
>b131	03					.byte	3
>b132	c1 a6 f3				.byte	$c1,$a6,$f3
>b135	09					.byte	9
>b136	4d					.byte	'M'
>b137	cd ab					.word	L10125
>b139	00					.byte	0
>b13a	03					.byte	3
>b13b	c1 a6 e3				.byte	$c1,$a6,$e3
>b13e	09					.byte	9
>b13f	4d					.byte	'M'
>b140	d1 ab					.word	L10126
>b142	00					.byte	0
>b143	03					.byte	3
>b144	c1 a6 e2				.byte	$c1,$a6,$e2
>b147	09					.byte	9
>b148	4d					.byte	'M'
>b149	d4 ab					.word	L10127
>b14b	00					.byte	0
>b14c	03					.byte	3
>b14d	be be f3				.byte	$be,$be,$f3
>b150	09					.byte	9
>b151	4d					.byte	'M'
>b152	d7 ab					.word	L10128
>b154	00					.byte	0
>b155	03					.byte	3
>b156	be be ec				.byte	$be,$be,$ec
>b159	09					.byte	9
>b15a	4d					.byte	'M'
>b15b	de ab					.word	L10129
>b15d	00					.byte	0
>b15e	03					.byte	3
>b15f	be be e9				.byte	$be,$be,$e9
>b162	09					.byte	9
>b163	4d					.byte	'M'
>b164	e3 ab					.word	L10130
>b166	00					.byte	0
>b167	03					.byte	3
>b168	be be e3				.byte	$be,$be,$e3
>b16b	09					.byte	9
>b16c	4d					.byte	'M'
>b16d	e7 ab					.word	L10131
>b16f	00					.byte	0
>b170	03					.byte	3
>b171	be be d2				.byte	$be,$be,$d2
>b174	09					.byte	9
>b175	4d					.byte	'M'
>b176	ee ab					.word	L10132
>b178	00					.byte	0
>b179	03					.byte	3
>b17a	be be c1				.byte	$be,$be,$c1
>b17d	09					.byte	9
>b17e	4d					.byte	'M'
>b17f	f0 ab					.word	L10133
>b181	00					.byte	0
>b182	03					.byte	3
>b183	bc bc f3				.byte	$bc,$bc,$f3
>b186	09					.byte	9
>b187	4d					.byte	'M'
>b188	f3 ab					.word	L10134
>b18a	00					.byte	0
>b18b	03					.byte	3
>b18c	bc bc ec				.byte	$bc,$bc,$ec
>b18f	09					.byte	9
>b190	4d					.byte	'M'
>b191	fa ab					.word	L10135
>b193	00					.byte	0
>b194	03					.byte	3
>b195	bc bc e9				.byte	$bc,$bc,$e9
>b198	09					.byte	9
>b199	4d					.byte	'M'
>b19a	ff ab					.word	L10136
>b19c	00					.byte	0
>b19d	03					.byte	3
>b19e	bc bc e3				.byte	$bc,$bc,$e3
>b1a1	09					.byte	9
>b1a2	4d					.byte	'M'
>b1a3	03 ac					.word	L10137
>b1a5	00					.byte	0
>b1a6	03					.byte	3
>b1a7	bc bc d2				.byte	$bc,$bc,$d2
>b1aa	09					.byte	9
>b1ab	4d					.byte	'M'
>b1ac	0a ac					.word	L10138
>b1ae	00					.byte	0
>b1af	03					.byte	3
>b1b0	bc bc c1				.byte	$bc,$bc,$c1
>b1b3	0b					.byte	11
>b1b4	4d					.byte	'M'
>b1b5	0c ac					.word	L10139
>b1b7	00					.byte	0
>b1b8	05					.byte	5
>b1b9	ad 52 50 48 c1				.byte	$ad,$52,$50,$48,$c1
>b1be	08					.byte	8
>b1bf	4d					.byte	'M'
>b1c0	18 ac					.word	L10140
>b1c2	00					.byte	0
>b1c3	02					.byte	2
>b1c4	ad c1					.byte	$ad,$c1
>b1c6	09					.byte	9
>b1c7	4d					.byte	'M'
>b1c8	1c ac					.word	L10141
>b1ca	00					.byte	0
>b1cb	03					.byte	3
>b1cc	ad ad f3				.byte	$ad,$ad,$f3
>b1cf	09					.byte	9
>b1d0	4d					.byte	'M'
>b1d1	1f ac					.word	L10142
>b1d3	00					.byte	0
>b1d4	03					.byte	3
>b1d5	ad ad ec				.byte	$ad,$ad,$ec
>b1d8	09					.byte	9
>b1d9	4d					.byte	'M'
>b1da	2d ac					.word	L10143
>b1dc	00					.byte	0
>b1dd	03					.byte	3
>b1de	ad ad e9				.byte	$ad,$ad,$e9
>b1e1	09					.byte	9
>b1e2	4d					.byte	'M'
>b1e3	38 ac					.word	L10144
>b1e5	00					.byte	0
>b1e6	03					.byte	3
>b1e7	ad ad e3				.byte	$ad,$ad,$e3
>b1ea	09					.byte	9
>b1eb	4d					.byte	'M'
>b1ec	3c ac					.word	L10145
>b1ee	00					.byte	0
>b1ef	03					.byte	3
>b1f0	ad ad d9				.byte	$ad,$ad,$d9
>b1f3	09					.byte	9
>b1f4	4d					.byte	'M'
>b1f5	3e ac					.word	L10146
>b1f7	00					.byte	0
>b1f8	03					.byte	3
>b1f9	ad ad d2				.byte	$ad,$ad,$d2
>b1fc	09					.byte	9
>b1fd	4d					.byte	'M'
>b1fe	45 ac					.word	L10147
>b200	00					.byte	0
>b201	03					.byte	3
>b202	ad ad c1				.byte	$ad,$ad,$c1
>b205	09					.byte	9
>b206	4d					.byte	'M'
>b207	47 ac					.word	L10148
>b209	00					.byte	0
>b20a	03					.byte	3
>b20b	ab ab f3				.byte	$ab,$ab,$f3
>b20e	09					.byte	9
>b20f	4d					.byte	'M'
>b210	4a ac					.word	L10149
>b212	00					.byte	0
>b213	03					.byte	3
>b214	ab ab ec				.byte	$ab,$ab,$ec
>b217	09					.byte	9
>b218	4d					.byte	'M'
>b219	53 ac					.word	L10150
>b21b	00					.byte	0
>b21c	03					.byte	3
>b21d	ab ab e9				.byte	$ab,$ab,$e9
>b220	09					.byte	9
>b221	4d					.byte	'M'
>b222	5a ac					.word	L10151
>b224	00					.byte	0
>b225	03					.byte	3
>b226	ab ab e3				.byte	$ab,$ab,$e3
>b229	09					.byte	9
>b22a	4d					.byte	'M'
>b22b	5e ac					.word	L10152
>b22d	00					.byte	0
>b22e	03					.byte	3
>b22f	ab ab d9				.byte	$ab,$ab,$d9
>b232	09					.byte	9
>b233	4d					.byte	'M'
>b234	60 ac					.word	L10153
>b236	00					.byte	0
>b237	03					.byte	3
>b238	ab ab d2				.byte	$ab,$ab,$d2
>b23b	09					.byte	9
>b23c	4d					.byte	'M'
>b23d	65 ac					.word	L10154
>b23f	00					.byte	0
>b240	03					.byte	3
>b241	ab ab c1				.byte	$ab,$ab,$c1
>b244	00					.byte	$00

;******  Return to file: main.asm


;******  Processing file: utility/loadcode.asm

.b245					LoadBasicCode:
.b245	a9 74		lda #$74			lda 	#(LBCTest) & $FF
.b247	85 1a		sta $1a				sta 	zTemp0
.b249	a9 b2		lda #$b2			lda 	#(LBCTest) >> 8
.b24b	85 1b		sta $1b				sta 	zTemp0+1
.b24d	a9 01		lda #$01			lda 	#($801) & $FF
.b24f	85 1c		sta $1c				sta 	zTemp1
.b251	a9 08		lda #$08			lda 	#($801) >> 8
.b253	85 1d		sta $1d				sta 	zTemp1+1
.b255					_LBCCopy:
.b255	a0 02		ldy #$02			ldy 	#2							; skip over the loading address
.b257	b1 1a		lda ($1a),y			lda 	(zTemp0),y 					; skips first two bytes :)
.b259	92 1c		sta ($1c)			sta 	(zTemp1)
.b25b	e6 1a		inc $1a				inc 	zTemp0
.b25d	d0 02		bne $b261			bne 	_NoCarry
.b25f	e6 1b		inc $1b				inc 	zTemp0+1
.b261					_NoCarry:
.b261	e6 1c		inc $1c				inc 	zTemp1
.b263	d0 02		bne $b267			bne 	_NoCarry
.b265	e6 1d		inc $1d				inc 	zTemp1+1
.b267					_NoCarry:
.b267	a5 1a		lda $1a				lda 	zTemp0
.b269	c9 18		cmp #$18			cmp 	#LBCTestEnd & $FF
.b26b	d0 e8		bne $b255			bne 	_LBCCopy
.b26d	a5 1b		lda $1b				lda 	zTemp0+1
.b26f	c9 b9		cmp #$b9			cmp 	#LBCTestEnd >> 8
.b271	d0 e2		bne $b255			bne 	_LBCCopy
.b273	60		rts				rts
.b274					LBCTest:
>b274	01 08 0c 08 e8 03 99 c7				.binary 	"../generated/test.prg"
>b27c	28 31 34 29 00 17 08 f2 03 9e 34 30 39 36 30 00
>b28c	32 08 fc 03 8f 2e 20 57 4f 52 44 20 56 45 52 41
>b29c	2e 4c 4f 57 40 24 39 46 32 30 00 4e 08 06 04 8f
>b2ac	2e 20 42 59 54 45 20 56 45 52 41 2e 48 49 47 48
>b2bc	40 24 39 46 32 32 00 6a 08 10 04 8f 2e 20 42 59
>b2cc	54 45 20 56 45 52 41 2e 44 41 54 41 40 24 39 46
>b2dc	32 33 00 83 08 1a 04 8f 2e 20 57 4f 52 44 20 2e
>b2ec	53 50 52 49 54 45 2e 42 41 53 45 00 9c 08 24 04
>b2fc	8f 2e 20 42 59 54 45 20 2e 53 50 52 49 54 45 2e
>b30c	4d 4f 44 45 00 b3 08 2e 04 8f 2e 20 50 52 4f 43
>b31c	20 56 45 52 41 2e 53 45 54 28 29 00 c7 08 38 04
>b32c	8f 2e 20 56 45 52 41 2e 4c 4f 57 20 3d 20 52 00
>b33c	ea 08 42 04 8f 2e 20 41 3d 59 20 41 26 24 30 46
>b34c	20 41 3a 24 31 30 20 56 45 52 41 2e 48 49 47 48
>b35c	3d 41 00 f9 08 4c 04 8f 2e 20 45 4e 44 50 52 4f
>b36c	43 00 14 09 56 04 8f 2e 20 50 52 4f 43 20 56 45
>b37c	52 41 2e 50 41 4c 45 54 54 45 28 29 00 22 09 60
>b38c	04 8f 2e 20 52 41 59 2d 3e 53 00 4f 09 6a 04 8f
>b39c	2e 20 52 2d 3e 53 20 52 3d 59 20 3c 3c 52 20 52
>b3ac	3a 24 31 30 30 30 20 59 3d 24 30 46 20 56 45 52
>b3bc	41 2e 53 45 54 28 29 00 7a 09 74 04 8f 2e 20 53
>b3cc	2d 3e 52 20 56 45 52 41 2e 44 41 54 41 3d 41 20
>b3dc	52 2e 53 57 41 50 20 56 45 52 41 2e 44 41 54 41
>b3ec	3d 41 00 88 09 7e 04 8f 2e 20 53 2d 3e 52 41 59
>b3fc	00 97 09 88 04 8f 2e 20 45 4e 44 50 52 4f 43 00
>b40c	b9 09 92 04 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b41c	2e 53 50 52 49 54 45 53 2e 45 4e 41 42 4c 45 28
>b42c	29 00 16 0a 9c 04 8f 2e 20 52 41 59 2d 3e 53 20
>b43c	2e 53 50 52 49 54 45 2e 4d 4f 44 45 3d 59 20 52
>b44c	3c 3e 3f 20 49 46 20 31 20 45 4e 44 49 46 20 41
>b45c	2d 3e 53 20 56 45 52 41 2e 53 45 54 28 24 34 30
>b46c	30 30 2c 24 46 29 20 53 2d 3e 41 20 56 45 52 41
>b47c	2e 44 41 54 41 3d 41 20 53 2d 3e 52 41 59 00 25
>b48c	0a a6 04 8f 2e 20 45 4e 44 50 52 4f 43 00 3f 0a
>b49c	b0 04 8f 2e 20 50 52 4f 43 20 56 45 52 41 2e 53
>b4ac	45 4c 45 43 54 28 29 00 7d 0a ba 04 8f 2e 20 52
>b4bc	41 59 2d 3e 53 20 52 26 24 37 46 20 3c 3c 41 20
>b4cc	3c 3c 52 20 3c 3c 52 20 52 3a 24 35 30 30 30 20
>b4dc	2e 53 50 52 49 54 45 2e 42 41 53 45 3d 52 20 53
>b4ec	2d 3e 52 41 59 00 8c 0a c4 04 8f 2e 20 45 4e 44
>b4fc	50 52 4f 43 00 a7 0a ce 04 8f 2e 20 50 52 4f 43
>b50c	20 2e 56 45 52 41 2e 41 43 43 45 53 53 28 29 00
>b51c	d8 0a d8 04 8f 2e 20 59 2d 3e 53 20 52 2b 2e 53
>b52c	50 52 49 54 45 2e 42 41 53 45 20 59 3d 24 30 46
>b53c	20 56 45 52 41 2e 53 45 54 28 29 20 53 2d 3e 59
>b54c	00 e7 0a e2 04 8f 2e 20 45 4e 44 50 52 4f 43 00
>b55c	fc 0a ec 04 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b56c	2e 58 28 29 00 4a 0b f6 04 8f 2e 20 52 41 59 2d
>b57c	3e 53 20 52 2d 3e 53 20 2e 56 45 52 41 2e 41 43
>b58c	43 45 53 53 28 32 29 20 53 2d 3e 52 20 56 45 52
>b59c	41 2e 44 41 54 41 3d 41 20 52 2e 53 57 41 50 20
>b5ac	56 45 52 41 2e 44 41 54 41 3d 41 20 53 2d 3e 52
>b5bc	41 59 00 59 0b 00 05 8f 2e 20 45 4e 44 50 52 4f
>b5cc	43 00 6e 0b 0a 05 8f 2e 20 50 52 4f 43 20 56 45
>b5dc	52 41 2e 59 28 29 00 bc 0b 14 05 8f 2e 20 52 41
>b5ec	59 2d 3e 53 20 52 2d 3e 53 20 2e 56 45 52 41 2e
>b5fc	41 43 43 45 53 53 28 34 29 20 53 2d 3e 52 20 56
>b60c	45 52 41 2e 44 41 54 41 3d 41 20 52 2e 53 57 41
>b61c	50 20 56 45 52 41 2e 44 41 54 41 3d 41 20 53 2d
>b62c	3e 52 41 59 00 cb 0b 1e 05 8f 2e 20 45 4e 44 50
>b63c	52 4f 43 00 e5 0b 28 05 8f 2e 20 50 52 4f 43 20
>b64c	56 45 52 41 2e 43 52 45 41 54 45 28 29 00 f3 0b
>b65c	32 05 8f 2e 20 52 41 59 2d 3e 53 00 0f 0c 3c 05
>b66c	8f 2e 20 3c 3c 41 20 3c 3c 41 20 3c 3c 41 20 3c
>b67c	3c 41 20 41 2d 3e 53 00 4a 0c 46 05 8f 2e 20 2e
>b68c	56 45 52 41 2e 41 43 43 45 53 53 28 36 29 20 41
>b69c	20 3d 20 31 32 20 56 45 52 41 2e 44 41 54 41 3d
>b6ac	41 20 53 2d 3e 41 20 56 45 52 41 2e 44 41 54 41
>b6bc	3d 41 00 58 0c 50 05 8f 2e 20 53 2d 3e 52 41 59
>b6cc	00 67 0c 5a 05 8f 2e 20 45 4e 44 50 52 4f 43 00
>b6dc	82 0c 64 05 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b6ec	2e 47 52 41 50 48 49 43 28 29 00 90 0c 6e 05 8f
>b6fc	2e 20 52 41 59 2d 3e 53 00 b5 0c 78 05 8f 2e 20
>b70c	3e 3e 52 20 52 2d 3e 53 20 52 2d 3e 53 20 2e 56
>b71c	45 52 41 2e 41 43 43 45 53 53 28 30 29 00 cd 0c
>b72c	82 05 8f 2e 20 53 2d 3e 52 20 56 45 52 41 2e 44
>b73c	41 54 41 3d 41 00 01 0d 8c 05 8f 2e 20 53 2d 3e
>b74c	52 20 52 2e 53 57 41 50 20 41 26 24 30 46 20 41
>b75c	2b 2e 53 50 52 49 54 45 2e 4d 4f 44 45 20 56 45
>b76c	52 41 2e 44 41 54 41 3d 41 00 0f 0d 96 05 8f 2e
>b77c	20 53 2d 3e 52 41 59 00 1e 0d a0 05 8f 2e 20 45
>b78c	4e 44 50 52 4f 43 00 31 0d aa 05 8f 2e 20 50 52
>b79c	4f 43 20 4d 41 49 4e 28 29 00 4d 0d b4 05 8f 2e
>b7ac	20 56 45 52 41 2e 50 41 4c 45 54 54 45 28 24 46
>b7bc	38 30 2c 31 29 00 69 0d be 05 8f 2e 20 56 45 52
>b7cc	41 2e 50 41 4c 45 54 54 45 28 24 30 30 30 2c 36
>b7dc	29 00 8b 0d c8 05 8f 2e 20 56 45 52 41 2e 53 50
>b7ec	52 49 54 45 53 2e 45 4e 41 42 4c 45 28 31 2c 24
>b7fc	30 30 29 00 a6 0d d2 05 8f 2e 20 56 45 52 41 2e
>b80c	53 45 54 28 24 34 30 30 30 2c 24 30 31 29 00 d1
>b81c	0d dc 05 8f 2e 20 34 30 39 36 20 52 2e 46 4f 52
>b82c	20 3e 3e 41 20 3e 3e 41 20 56 45 52 41 2e 44 41
>b83c	54 41 3d 41 20 4e 45 58 54 00 e1 0d e6 05 8f 2e
>b84c	20 31 32 20 41 2e 46 4f 52 00 ed 0d f0 05 8f 2e
>b85c	20 52 2d 3e 53 00 02 0e fa 05 8f 2e 20 56 45 52
>b86c	41 2e 53 45 4c 45 43 54 28 29 00 1a 0e 04 06 8f
>b87c	2e 20 56 45 52 41 2e 43 52 45 41 54 45 28 24 30
>b88c	41 29 00 35 0e 0e 06 8f 2e 20 56 45 52 41 2e 47
>b89c	52 41 50 48 49 43 28 24 31 34 30 30 29 00 4d 0e
>b8ac	18 06 8f 2e 20 53 2d 3e 52 20 3c 3c 52 20 3c 3c
>b8bc	52 20 3c 3c 52 00 61 0e 22 06 8f 2e 20 56 45 52
>b8cc	41 2e 58 28 29 20 3c 3c 52 00 71 0e 2c 06 8f 2e
>b8dc	20 56 45 52 41 2e 59 28 29 00 7d 0e 36 06 8f 2e
>b8ec	20 4e 45 58 54 00 8c 0e 40 06 8f 2e 20 45 4e 44
>b8fc	50 52 4f 43 00 a1 0e 4a 06 8f 2e 20 52 45 4d 4f
>b90c	56 45 2e 4c 4f 43 41 4c 53 00 00 00
.b918					LBCTestEnd:

;******  Return to file: main.asm

.b918					EndCode:

;******  End of listing


; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -Wall -q -c -o lean.prg -L lean.lst main.asm
; Fri Nov  1 09:08:50 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$0801					ProgramStart = $0801 						; where source code starts.
=$b800					UserDictionary = $B800 						; user dictionary
=$bc00					CodeMemory = $BC00 							; where object code goes.
=$063f					AssemblerStack = $063F 						; compiler stack space.
=$0700					VariableMemory = $0700
=64					LINEBUFFSIZE = 64
=128					VALBUFFSIZE = 128
=$0640					lineBuffer = $0640	 						; current line, match encoded.
=$0680					valueBuffer = $0680 						; buffer for associated values.
>0000					scanPtr:	.word ?							; BASIC scan position.
>0002					aStackPtr:	.word ? 						; compiler stack.
>0004					dictPtr:	.word ? 						; dictionary pointer
>0006					genPtr:		.word ? 						; code generation pointer
>0008					varPtr: 	.word ?							; next free variable pointer.
>000a					zTemp0:		.word ? 						; temps.
>000c					zTemp1:		.word ?
>000e					zTemp2:		.word ?
>0010					zTemp3:		.word ?
>0012					lastCreate:	.word ? 						; last created dictionary word
>0014					codePtr:	.word ? 						; code pointer
>0016					codeBank:	.byte ?							; code bank
>0017					originalSP:			.byte ? 				; 6502 stack on entry.
>0018					lastDefine:			.word ? 				; last defined word.
>001a					lineNumber:			.word ? 				; current line number
>001c					identStart:			.byte ? 				; start offset of current identifier
>001d					dirLowByte:			.byte ?					; values returned from search
>001e					dirHighByte:		.byte ?
>001f					dirBank:			.byte ?
>0020					dirLength:			.byte ?
>0021					valueBufferPos:		.byte ? 				; position in value buffer.
>0022					genPos: 			.byte ? 				; position in line buffer, generation.
>0023					generateVar:		.word ? 				; variables used in set value
>0025					elementData:		.fill 3 				; data from matched constant/identifier
>0028					codeBackup:			.fill 3 				; backup code pointer.
>002b					varSize:			.byte ? 				; size of current variable.
=$8f					REM_TOKEN = $8F 							; C64 REM Token
="*"					SCM_TOP = '*'								; top of stack marker.
="P"					SCM_PROC = 'P'								; procedure marker
="R"					SCM_REPEAT = 'R'							; repeat marker
="F"					SCM_FOR = 'F' 								; for marker
="I"					SCM_IF = 'I'								; if/else/endif marker.
=$60					CPU_RETURN = $60 							; RTS opcode.
=$48					CPU_PHA = $48 								; PHA
=$68					CPU_PLA = $68 								; PLA
=$3a					CPU_DECA = $3A 								; DEC A
=$d0					CPU_BNE = $D0								; BNE
=$80					CPU_BRA = $80								; BRA
=$20					CPU_JSR = $20 								; JSR

;******  Return to file: main.asm


;******  Processing file: generated/cgconst.inc

=$53					CGEN_C_ISZERO = $53
=$63					CGEN_C_LOW = $63
=$73					CGEN_C_HIGH = $73
=$83					CGEN_C_LOWPLUS1 = $83
=$93					CGEN_C_SETDATA = $93
=$a3					CGEN_C_EXEC = $a3

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.a000	ba		tsx				tsx 									; save SP
.a001	86 17		stx $17				stx 	originalSP
.a003	20 7a af	jsr $af7a			jsr 	LoadBasicCode
.a006	20 0f a8	jsr $a80f			jsr 	StackReset 						; reset convert stack.
.a009	20 4c a6	jsr $a64c			jsr 	VariableReset 					; reset variable memory.
.a00c	20 95 a3	jsr $a395			jsr 	DictionaryReset 				; reset user dictionary
.a00f	20 09 a4	jsr $a409			jsr 	CodeReset 						; reset code output.
.a012	20 3d a0	jsr $a03d			jsr 	ScannerReset 					; reset scanner
.a015					AsmLoop:
.a015	20 40 a0	jsr $a040			jsr 	ScannerFind 					; next thing in code
.a018	90 08		bcc $a022			bcc 	AsmEnd 							; nothing more
.a01a	20 82 a0	jsr $a082			jsr 	ProcessLineToBuffer 			; convert it.
.a01d	20 ce a1	jsr $a1ce			jsr 	GeneratorSearch 				; check it for generators
.a020	80 f3		bra $a015			bra 	AsmLoop 						; and keep going.
.a022					AsmEnd:
.a022	a9 2a		lda #$2a			lda 	#SCM_TOP 						; check structures are done
.a024	20 48 a8	jsr $a848			jsr 	StackCheckStructureMarker
.a027	20 2e a0	jsr $a02e			jsr 	CallCodeMemory
.a02a					ReturnCaller:
.a02a	a6 17		ldx $17				ldx		originalSP 						; restore XP and exit.
.a02c	9a		txs				txs
.a02d	60		rts				rts
.a02e					CallCodeMemory:
.a02e	a5 18		lda $18				lda 	lastDefine
.a030	05 19		ora $19				ora 	lastDefine+1
.a032	f0 08		beq $a03c			beq 	_NoExecute
.a034	a5 14		lda $14				lda 	codePtr							; pass in byte after code.
.a036	a6 15		ldx $15				ldx 	codePtr+1
>a038	ff						.byte 	$FF
.a039	6c 18 00	jmp ($0018)			jmp 	(lastDefine)					; call last definition.
.a03c					_NoExecute:
.a03c	60		rts				rts

;******  Processing file: lean/scanner.asm

.a03d					ScannerReset:
.a03d	64 01		stz $01				stz 	scanPtr+1 					; zero MSB means the start
.a03f	60		rts				rts
.a040					ScannerFind:
.a040	48		pha				pha 								; save registers
.a041	da		phx				phx
.a042	5a		phy				phy
.a043	a5 01		lda $01				lda 	scanPtr+1 					; reset the scanner pointer ?
.a045	d0 0a		bne $a051			bne 	_SFScanForward 				; no, scan forward from current.
.a047	a9 01		lda #$01			lda 	#(ProgramStart) & $FF
.a049	85 00		sta $00				sta 	scanPtr
.a04b	a9 08		lda #$08			lda 	#(ProgramStart) >> 8
.a04d	85 01		sta $01				sta 	scanPtr+1
.a04f	80 12		bra $a063			bra 	_SFCheck 					; check if this one is a REM.
.a051					_SFScanForward:
.a051	a0 01		ldy #$01			ldy 	#1 							; check if the offset is zero
.a053	b2 00		lda ($00)			lda 	(scanPtr)
.a055	11 00		ora ($00),y			ora 	(scanPtr),y
.a057	18		clc				clc 								; if so exit with CC.
.a058	f0 24		beq $a07e			beq 	_SFExit
.a05a	b2 00		lda ($00)			lda 	(scanPtr) 					; forward to next.
.a05c	aa		tax				tax
.a05d	b1 00		lda ($00),y			lda 	(scanPtr),y
.a05f	86 00		stx $00				stx 	scanPtr
.a061	85 01		sta $01				sta 	scanPtr+1
.a063					_SFCheck:
.a063	a0 02		ldy #$02			ldy 	#2 								; copy line number.
.a065	b1 00		lda ($00),y			lda 	(scanPtr),y
.a067	85 1a		sta $1a				sta 	lineNumber
.a069	c8		iny				iny
.a06a	b1 00		lda ($00),y			lda 	(scanPtr),y
.a06c	85 1b		sta $1b				sta 	lineNumber+1
.a06e	c8		iny				iny
.a06f	b1 00		lda ($00),y			lda 	(scanPtr),y 				; is it a "REM." line ?
.a071	c9 8f		cmp #$8f			cmp 	#REM_TOKEN
.a073	d0 dc		bne $a051			bne 	_SFScanForward
.a075	c8		iny				iny
.a076	b1 00		lda ($00),y			lda 	(scanPtr),y 				; is it followed by a '.'
.a078	c8		iny				iny
.a079	c9 2e		cmp #$2e			cmp 	#"."
.a07b	d0 d4		bne $a051			bne 	_SFScanForward
.a07d	38		sec				sec 								; found something, exit with CS.
.a07e					_SFExit:
.a07e	7a		ply				ply 								; load registers and exit.
.a07f	fa		plx				plx
.a080	68		pla				pla
.a081	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: lean/process.asm

.a082					ProcessLineToBuffer:
.a082	a0 06		ldy #$06			ldy 	#6 							; position in line
.a084	a2 00		ldx #$00			ldx 	#0 							; position in buffer
.a086	64 21		stz $21				stz 	valueBufferPos 				; reset value buffer pos
.a088	a9 ff		lda #$ff			lda 	#$FF
.a08a	8d 80 06	sta $0680			sta 	valueBuffer 				; erase value buffer (end marker $FF)
.a08d					_PLTConvert:
.a08d	b1 00		lda ($00),y			lda 	(scanPtr),y 				; next character
.a08f	f0 7a		beq $a10b			beq 	_PLTExit
.a091	c8		iny				iny
.a092	c9 20		cmp #$20			cmp 	#' ' 						; skip over spaces.
.a094	f0 f7		beq $a08d			beq 	_PLTConvert
.a096	20 6f a1	jsr $a16f			jsr 	PLTCheckCharacter 			; identifier character.
.a099	b0 08		bcs $a0a3			bcs 	_PLTIsIdentifier 			; it's an identifier.
.a09b	09 80		ora #$80			ora 	#$80 						; set bit 7
.a09d	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write out
.a0a0	e8		inx				inx
.a0a1	80 ea		bra $a08d			bra 	_PLTConvert
.a0a3					_PLTIsIdentifier:
.a0a3	86 1c		stx $1c				stx 	identStart 					; save as start of identifier.
.a0a5					_PLTGetIdentifier:
.a0a5	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out.
.a0a8	e8		inx				inx
.a0a9	b1 00		lda ($00),y			lda 	(scanPtr),y	 				; get next character
.a0ab	c8		iny				iny
.a0ac	20 6f a1	jsr $a16f			jsr 	PLTCheckCharacter 			; still identifier
.a0af	b0 f4		bcs $a0a5			bcs 	_PLTGetIdentifier
.a0b1	88		dey				dey 								; undo last bump.
.a0b2					_PLTGotIdentifier:
.a0b2	bd 3f 06	lda $063f,x			lda 	lineBuffer-1,x 				; set bit 7 of last
.a0b5	09 80		ora #$80			ora 	#$80
.a0b7	9d 3f 06	sta $063f,x			sta 	lineBuffer-1,x
.a0ba	5a		phy				phy
.a0bb	da		phx				phx
.a0bc	20 63 a1	jsr $a163			jsr 	PLTGetAddress 				; XY <= address of identifier.
.a0bf	20 a4 a3	jsr $a3a4			jsr 	DictionarySearch 			; is it in the dictionaries ?
.a0c2	90 0c		bcc $a0d0			bcc 	_PLTTryConstant
.a0c4	c9 50		cmp #$50			cmp 	#"P" 						; procedure, short or var ?
.a0c6	f0 4b		beq $a113			beq 	_PLTFoundIdentifier
.a0c8	c9 53		cmp #$53			cmp 	#"S"
.a0ca	f0 47		beq $a113			beq 	_PLTFoundIdentifier
.a0cc	c9 49		cmp #$49			cmp 	#"I"
.a0ce	f0 43		beq $a113			beq 	_PLTFoundIdentifier
.a0d0					_PLTTryConstant:
.a0d0	20 63 a1	jsr $a163			jsr 	PLTGetAddress 				; try as a constant
.a0d3	20 7f a7	jsr $a77f			jsr 	StringToInt
.a0d6	b0 04		bcs $a0dc			bcs 	_PLTAttachIdentifier
.a0d8	fa		plx				plx 								; leave as it is - unknown identifier
.a0d9	7a		ply				ply
.a0da	80 b1		bra $a08d			bra 	_PLTConvert
.a0dc					_PLTAttachIdentifier:
.a0dc	86 0a		stx $0a				stx 	zTemp0 						; save XY
.a0de	84 0b		sty $0b				sty 	zTemp0+1
.a0e0	fa		plx				plx 								; restore current position
.a0e1	7a		ply				ply
.a0e2	b1 00		lda ($00),y			lda 	(scanPtr),y 				; next character
.a0e4	c9 2d		cmp #$2d			cmp 	#"-"
.a0e6	d0 04		bne $a0ec			bne 	_PLTNotMinus
.a0e8	20 55 a1	jsr $a155			jsr 	_PLTNegateZTemp0 			; negate zTemp0
.a0eb	c8		iny				iny 								; skip it if '-'
.a0ec					_PLTNotMinus:
.a0ec	5a		phy				phy 								; save current positions
.a0ed	da		phx				phx
.a0ee	a6 0a		ldx $0a				ldx 	zTemp0 						; restore XY number
.a0f0	a4 0b		ldy $0b				ldy 	zTemp0+1
.a0f2	a9 00		lda #$00			lda 	#0
.a0f4	20 93 a1	jsr $a193			jsr 	ProcessRecordData 			; record associated data
.a0f7	a9 62		lda #$62			lda 	#"b"
.a0f9	c0 00		cpy #$00			cpy 	#0
.a0fb	f0 02		beq $a0ff			beq 	_PLTRecord
.a0fd	a9 77		lda #$77			lda 	#"w"
.a0ff					_PLTRecord:
.a0ff	fa		plx				plx 								; restore XY position
.a100	7a		ply				ply
.a101	a6 1c		ldx $1c				ldx 	identStart 					; overwrite the position with ident start
.a103	09 80		ora #$80			ora 	#$80 						; bit 7, it's an element in its own right
.a105	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out
.a108	e8		inx				inx 								; bump the position
.a109	80 82		bra $a08d			bra		_PLTConvert 				; do the next one.
.a10b					_PLTExit:
.a10b	9e 40 06	stz $0640,x			stz 	lineBuffer,x 				; make it ASCIIZ
.a10e	e0 40		cpx #$40			cpx		#LINEBUFFSIZE 				; line too long.
.a110	b0 31		bcs $a143			bcs 	_PLTBuffer
.a112	60		rts				rts
.a113					_PLTFoundIdentifier:
.a113	48		pha				pha 								; save type.
.a114	a6 1d		ldx $1d				ldx 	dirLowByte 					; get the dictionary AXY values
.a116	a4 1e		ldy $1e				ldy 	dirHighByte
.a118	a5 1f		lda $1f				lda 	dirBank
.a11a	20 93 a1	jsr $a193			jsr 	ProcessRecordData 			; attached to identstart
.a11d	68		pla				pla 								; get type back, which is I or S or P
.a11e	09 20		ora #$20			ora 	#$20 						; make it lower case.
.a120	c9 70		cmp #$70			cmp 	#"p"						; P goes untrammelled
.a122	f0 db		beq $a0ff			beq 	_PLTRecord
.a124	c0 00		cpy #$00			cpy 	#0 							; if Y = 0, e.g. zero page, use that.
.a126	f0 d7		beq $a0ff			beq 	_PLTRecord
.a128	49 05		eor #$05			eor 	#"i"^"l" 					; convert it to L
.a12a	c9 6c		cmp #$6c			cmp 	#"l"
.a12c	f0 d1		beq $a0ff			beq 	_PLTRecord
.a12e	a9 63		lda #$63			lda 	#"c" 						; otherwise C
.a130	80 cd		bra $a0ff			bra 	_PLTRecord
.a132					_PLTError:
.a132	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a135	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX ?",$00
>a13d	54 41 58 20 3f 00
.a143					_PLTBuffer:
.a143	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a146	4c 45 41 4e 3a 4c 49 4e				.text 	"LEAN:","LINE SIZE",$00
>a14e	45 20 53 49 5a 45 00
.a155					_PLTNegateZTemp0:
.a155	38		sec				sec 								; negate zTemp0
.a156	a9 00		lda #$00			lda 	#0
.a158	e5 0a		sbc $0a				sbc 	zTemp0
.a15a	85 0a		sta $0a				sta 	zTemp0
.a15c	a9 00		lda #$00			lda 	#0
.a15e	e5 0b		sbc $0b				sbc 	zTemp0+1
.a160	85 0b		sta $0b				sta 	zTemp0+1
.a162	60		rts				rts
.a163					PLTGetAddress:
.a163	18		clc				clc
.a164	a5 1c		lda $1c				lda 	identStart
.a166	69 40		adc #$40			adc 	#lineBuffer & $FF
.a168	aa		tax				tax
.a169	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a16b	90 01		bcc $a16e			bcc 	_PLGANoCarry
.a16d	c8		iny				iny
.a16e					_PLGANoCarry:
.a16e	60		rts				rts
.a16f					PLTCheckCharacter:
.a16f	c9 25		cmp #$25			cmp 	#'%'
.a171	f0 1c		beq $a18f			beq 	_PLCCYes
.a173	c9 5f		cmp #$5f			cmp 	#'_'
.a175	f0 18		beq $a18f			beq 	_PLCCYes
.a177	c9 24		cmp #$24			cmp 	#'$'
.a179	f0 14		beq $a18f			beq 	_PLCCYes
.a17b	c9 2e		cmp #$2e			cmp 	#'.'
.a17d	f0 10		beq $a18f			beq 	_PLCCYes
.a17f	c9 30		cmp #$30			cmp 	#'0'
.a181	90 0e		bcc $a191			bcc 	_PLCCNo
.a183	c9 3a		cmp #$3a			cmp 	#'9'+1
.a185	90 08		bcc $a18f			bcc 	_PLCCYes
.a187	c9 41		cmp #$41			cmp 	#'A'
.a189	90 06		bcc $a191			bcc 	_PLCCNo
.a18b	c9 5b		cmp #$5b			cmp 	#'Z'+1
.a18d	b0 02		bcs $a191			bcs 	_PLCCNo
.a18f					_PLCCYes:
.a18f	38		sec				sec
.a190	60		rts				rts
.a191					_PLCCNo:
.a191	18		clc				clc
.a192	60		rts				rts
.a193					ProcessRecordData:
.a193	48		pha				pha
.a194	da		phx				phx
.a195	5a		phy				phy
.a196	da		phx				phx
.a197	a6 21		ldx $21				ldx 	valueBufferPos 				; get current position
.a199	9d 83 06	sta $0683,x			sta 	valueBuffer+3,x 			; copy data to it
.a19c	98		tya				tya
.a19d	9d 82 06	sta $0682,x			sta 	valueBuffer+2,x
.a1a0	68		pla				pla
.a1a1	9d 81 06	sta $0681,x			sta 	valueBuffer+1,x
.a1a4	a5 1c		lda $1c				lda 	identStart
.a1a6	9d 80 06	sta $0680,x			sta 	valueBuffer+0,x
.a1a9	e8		inx				inx 								; next position
.a1aa	e8		inx				inx
.a1ab	e8		inx				inx
.a1ac	e8		inx				inx
.a1ad	86 21		stx $21				stx 	valueBufferPos 				; save
.a1af	a9 ff		lda #$ff			lda 	#$FF 						; write end marker.
.a1b1	9d 80 06	sta $0680,x			sta 	valueBuffer,x
.a1b4	e0 80		cpx #$80			cpx 	#VALBUFFSIZE
.a1b6	b0 04		bcs $a1bc			bcs 	_PRDError
.a1b8	7a		ply				ply
.a1b9	fa		plx				plx
.a1ba	68		pla				pla
.a1bb	60		rts				rts
.a1bc					_PRDError:
.a1bc	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a1bf	4c 45 41 4e 3a 43 4f 4d				.text 	"LEAN:","COMPLEX ?",$00
>a1c7	50 4c 45 58 20 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/generate.asm

.a1ce					GeneratorSearch:
.a1ce	64 22		stz $22				stz 	genPos 						; reset the generator pointer
.a1d0					_GSNextItem:
.a1d0	a6 22		ldx $22				ldx 	genPos
.a1d2	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a1d5	f0 05		beq $a1dc			beq 	_GSExit
.a1d7	20 dd a1	jsr $a1dd			jsr 	GenerateOne
.a1da	80 f4		bra $a1d0			bra 	_GSNextItem
.a1dc					_GSExit:
.a1dc	60		rts				rts
.a1dd					GenerateOne:
.a1dd	a5 22		lda $22				lda 	genPos 						; point XY to the next thing
.a1df	18		clc				clc 								; the actual address in the line buffer.
.a1e0	69 40		adc #$40			adc 	#lineBuffer & $FF
.a1e2	aa		tax				tax
.a1e3	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a1e5	90 01		bcc $a1e8			bcc 	_GSNoCarry
.a1e7	c8		iny				iny
.a1e8					_GSNoCarry:
.a1e8	20 a1 a3	jsr $a3a1			jsr 	DictionarySearchSystemOnly 	; dictionary search
.a1eb	b0 10		bcs $a1fd			bcs 	_GSFound
.a1ed					_GSError:
.a1ed	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a1f0	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX?",$00
>a1f8	54 41 58 3f 00
.a1fd					_GSFound:
.a1fd	c9 4d		cmp #$4d			cmp 	#"M"						; check it's a match.
.a1ff	d0 ec		bne $a1ed			bne 	_GSError
.a201	a4 20		ldy $20				ldy 	dirLength 					; advance to next
.a203	a6 22		ldx $22				ldx 	genPos 						; checking for a-z.
.a205					_GSCheckData:
.a205	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a208	29 7f		and #$7f			and 	#$7F
.a20a	c9 61		cmp #$61			cmp 	#'a'
.a20c	90 08		bcc $a216			bcc 	_GSNotLC
.a20e	c9 7b		cmp #$7b			cmp 	#'z'+1
.a210	b0 04		bcs $a216			bcs 	_GSNotLC
.a212	8a		txa				txa
.a213	20 99 a2	jsr $a299			jsr 	GenCopyData
.a216					_GSNotLC:
.a216	e8		inx				inx
.a217	88		dey				dey
.a218	d0 eb		bne $a205			bne 	_GSCheckData
.a21a	86 22		stx $22				stx 	genPos
.a21c	a5 1d		lda $1d				lda 	dirLowByte					; copy address to genPtr
.a21e	85 06		sta $06				sta 	genPtr
.a220	a5 1e		lda $1e				lda 	dirHighByte
.a222	85 07		sta $07				sta 	genPtr+1
.a224	b2 06		lda ($06)			lda 	(genPtr)					; count in A
.a226	f0 25		beq $a24d			beq 	_GSNext 					; nothing !
.a228	aa		tax				tax 								; X is count
.a229	a0 01		ldy #$01			ldy 	#1
.a22b					_GSGenerate:
.a22b	b1 06		lda ($06),y			lda 	(genPtr),y 					; execute something
.a22d	c9 a3		cmp #$a3			cmp 	#CGEN_C_EXEC
.a22f	f0 1d		beq $a24e			beq 	_GSExecute
.a231	c9 93		cmp #$93			cmp 	#CGEN_C_SETDATA 			; set data ?
.a233	d0 0e		bne $a243			bne 	_GSCopy
.a235	c8		iny				iny									; copy next two bytes out.
.a236	b1 06		lda ($06),y			lda 	(genPtr),y
.a238	85 23		sta $23				sta 	generateVar
.a23a	c8		iny				iny
.a23b	b1 06		lda ($06),y			lda 	(genPtr),y
.a23d	85 24		sta $24				sta 	generateVar+1
.a23f	ca		dex				dex
.a240	ca		dex				dex
.a241	80 06		bra $a249			bra 	_GSContinue
.a243					_GSCopy:
.a243	20 6a a2	jsr $a26a			jsr 	GenConvertByte 				; replace bytes
.a246	20 33 a4	jsr $a433			jsr 	CodeWriteByte				; write out.
.a249					_GSContinue:
.a249	c8		iny				iny
.a24a	ca		dex				dex
.a24b	d0 de		bne $a22b			bne 	_GSGenerate
.a24d					_GSNext:
.a24d	60		rts				rts
.a24e					_GSExecute:
.a24e	c8		iny				iny 								; grab one.
.a24f	ca		dex				dex
.a250	da		phx				phx 								; save XY
.a251	5a		phy				phy
.a252	b1 06		lda ($06),y			lda 	(genPtr),y 					; read the execution ID
.a254	0a		asl a				asl 	a 							; index into table.
.a255	aa		tax				tax
.a256	bd de aa	lda $aade,x			lda 	ExecutableVectorTable,x 	; read jump vector
.a259	85 0a		sta $0a				sta 	zTemp0
.a25b	bd df aa	lda $aadf,x			lda 	ExecutableVectorTable+1,x
.a25e	85 0b		sta $0b				sta 	zTemp0+1
.a260	20 67 a2	jsr $a267			jsr 	_GSCallzTemp0 				; call routine
.a263	7a		ply				ply 								; restore XY
.a264	fa		plx				plx
.a265	80 e2		bra $a249			bra 	_GSContinue
.a267					_GSCallzTemp0:
.a267	6c 0a 00	jmp ($000a)			jmp 	(zTemp0)
.a26a					GenConvertByte:
.a26a	c9 63		cmp #$63			cmp 	#CGEN_C_LOW
.a26c	f0 09		beq $a277			beq 	_GCBLowByte
.a26e	c9 83		cmp #$83			cmp 	#CGEN_C_LOWPLUS1
.a270	f0 08		beq $a27a			beq 	_GCBLowBytePlus1
.a272	c9 73		cmp #$73			cmp 	#CGEN_C_HIGH
.a274	f0 0a		beq $a280			beq 	_GCBHighByte
.a276	60		rts				rts
.a277					_GCBLowByte:
.a277	a5 25		lda $25				lda 	elementData
.a279	60		rts				rts
.a27a					_GCBLowBytePlus1:
.a27a	a5 25		lda $25				lda 	elementData
.a27c	1a		inc a				inc 	a
.a27d	f0 04		beq $a283			beq 	_GCBSystem
.a27f	60		rts				rts
.a280					_GCBHighByte:
.a280	a5 26		lda $26				lda 	elementData+1
.a282	60		rts				rts
.a283					_GCBSystem:
.a283	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a286	4c 45 41 4e 3a 57 4f 52				.text 	"LEAN:","WORD OFF PAGE",$00
>a28e	44 20 4f 46 46 20 50 41 47 45 00
.a299					GenCopyData:
.a299	48		pha				pha
.a29a	da		phx				phx
.a29b	5a		phy				phy
.a29c	85 0a		sta $0a				sta 	zTemp0
.a29e	a2 fc		ldx #$fc			ldx 	#256-4
.a2a0					_GCDLoop:
.a2a0	e8		inx				inx 								; next slot
.a2a1	e8		inx				inx
.a2a2	e8		inx				inx
.a2a3	e8		inx				inx
.a2a4	bd 80 06	lda $0680,x			lda 	valueBuffer,x 				; next in value buffer
.a2a7	c9 ff		cmp #$ff			cmp 	#$FF
.a2a9	f0 16		beq $a2c1			beq 	_GCDError 					; system ?
.a2ab	c5 0a		cmp $0a				cmp 	zTemp0 						; match.
.a2ad	d0 f1		bne $a2a0			bne 	_GCDLoop
.a2af	a0 00		ldy #$00			ldy 	#0 							; copy assoc data back
.a2b1					_GCDCopy:
.a2b1	bd 81 06	lda $0681,x			lda 	valueBuffer+1,x
.a2b4	99 25 00	sta $0025,y			sta 	elementData,y
.a2b7	e8		inx				inx
.a2b8	c8		iny				iny
.a2b9	c0 03		cpy #$03			cpy 	#3
.a2bb	d0 f4		bne $a2b1			bne 	_GCDCopy
.a2bd	7a		ply				ply
.a2be	fa		plx				plx
.a2bf	68		pla				pla
.a2c0	60		rts				rts
.a2c1					_GCDError:
.a2c1	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a2c4	4c 45 41 4e 3a 53 59 53				.text 	"LEAN:","SYS0?",$00
>a2cc	30 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/extract.asm

.a2cf					EGetUnknownIdentifier:
.a2cf	a6 22		ldx $22				ldx 	genPos 						; get next character
.a2d1	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2d4	29 7f		and #$7f			and 	#$7F
.a2d6	20 6f a1	jsr $a16f			jsr 	PLTCheckCharacter 			; is it an identifier ?
.a2d9	90 15		bcc $a2f0			bcc 	_EUIError 					; no
.a2db	da		phx				phx 								; save start position on stack.
.a2dc					_EGetFindEnd:
.a2dc	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2df	e8		inx				inx
.a2e0	0a		asl a				asl 	a
.a2e1	90 f9		bcc $a2dc			bcc 	_EGetFindEnd
.a2e3	86 22		stx $22				stx 	genPos 						; points to the next thing.
.a2e5	68		pla				pla 								; offset
.a2e6	a0 06		ldy #$06			ldy 	#lineBuffer >> 8 			; make address in YX
.a2e8	18		clc				clc
.a2e9	69 40		adc #$40			adc 	#lineBuffer & $FF
.a2eb	aa		tax				tax
.a2ec	90 01		bcc $a2ef			bcc 	_EGetNoCarry
.a2ee	c8		iny				iny
.a2ef					_EGetNoCarry:
.a2ef	60		rts				rts
.a2f0					_EUIError:
.a2f0	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a2f3	4c 45 41 4e 3a 49 44 45				.text 	"LEAN:","IDENTIFIER ?",$00
>a2fb	4e 54 49 46 49 45 52 20 3f 00
.a305					EGetSyntaxCheck:
.a305	48		pha				pha
.a306	da		phx				phx
.a307	a6 22		ldx $22				ldx 	genPos 						; position of next
.a309	5d 40 06	eor $0640,x			eor 	lineBuffer,x 				; bits 0-6 will be zero if match
.a30c	29 7f		and #$7f			and 	#$7F
.a30e	d0 05		bne $a315			bne 	_EGSFail 					; different
.a310	e6 22		inc $22				inc 	genPos 						; skip it and exit
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					_EGSFail:
.a315	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a318	4c 45 41 4e 3a 4d 49 53				.text 	"LEAN:","MISSING ?",$00
>a320	53 49 4e 47 20 3f 00
.a327					EGLookNext:
.a327	da		phx				phx
.a328	a6 22		ldx $22				ldx 	genPos 						; position of next
.a32a	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a32d	fa		plx				plx
.a32e	60		rts				rts
.a32f					EGSkipNext:
.a32f	e6 22		inc $22				inc 	genPos
.a331	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/create.asm

.a332					DictionaryCreate:
.a332	86 0a		stx $0a				stx 	zTemp0 						; save identifier position
.a334	84 0b		sty $0b				sty 	zTemp0+1
.a336	a0 01		ldy #$01			ldy 	#1 							; write the type byte out.
.a338	91 04		sta ($04),y			sta 	(dictPtr),y
.a33a	a0 00		ldy #$00			ldy 	#0 							; work out length.
.a33c					_DCGetLength:
.a33c	b1 0a		lda ($0a),y			lda 	(zTemp0),y
.a33e	c8		iny				iny
.a33f	0a		asl a				asl 	a
.a340	90 fa		bcc $a33c			bcc 	_DCGetLength
.a342	5a		phy				phy 								; save Y on stack.
.a343	98		tya				tya 								; save length +6 as offset
.a344	18		clc				clc
.a345	69 06		adc #$06			adc 	#6
.a347	92 04		sta ($04)			sta 	(dictPtr)
.a349	a0 02		ldy #$02			ldy 	#2 							; fill 2 to 4 with $FF
.a34b	a9 ff		lda #$ff	_DCFill:lda 	#$FF
.a34d	91 04		sta ($04),y			sta 	(dictPtr),y
.a34f	c8		iny				iny
.a350	c0 05		cpy #$05			cpy 	#5
.a352	d0 f7		bne $a34b			bne 	_DCFill
.a354	68		pla				pla 								; get length, store in X
.a355	aa		tax				tax
.a356	91 04		sta ($04),y			sta 	(dictPtr),y 				; write length out.
.a358	a0 00		ldy #$00			ldy 	#0
.a35a					_DCCopy:
.a35a	b1 0a		lda ($0a),y			lda 	(zTemp0),y 					; next identifier character
.a35c	c8		iny				iny 								; save +1 on stack
.a35d	5a		phy				phy
.a35e	c8		iny				iny 								; advance by 6 total
.a35f	c8		iny				iny
.a360	c8		iny				iny
.a361	c8		iny				iny
.a362	c8		iny				iny
.a363	91 04		sta ($04),y			sta 	(dictPtr),y 				; write out
.a365	7a		ply				ply 								; restore +1
.a366	ca		dex				dex
.a367	d0 f1		bne $a35a			bne 	_DCCopy 					; do that the required# times.
.a369	a5 04		lda $04				lda 	dictPtr 					; copy last created
.a36b	85 12		sta $12				sta 	lastCreate
.a36d	a5 05		lda $05				lda 	dictPtr+1
.a36f	85 13		sta $13				sta 	lastCreate+1
.a371	18		clc				clc 								; advance dictionary pointer
.a372	b2 04		lda ($04)			lda 	(dictPtr)
.a374	65 04		adc $04				adc 	dictPtr
.a376	85 04		sta $04				sta 	dictPtr
.a378	90 02		bcc $a37c			bcc 	_DCNoCarry
.a37a	e6 05		inc $05				inc 	dictPtr+1
.a37c					_DCNoCarry:
.a37c	a9 00		lda #$00			lda 	#$00 						; write end of dictionary marker
.a37e	92 04		sta ($04)			sta 	(dictPtr)
.a380	60		rts				rts
.a381					DictionarySet:
.a381	48		pha				pha
.a382	da		phx				phx
.a383	5a		phy				phy
.a384	5a		phy				phy 								; copy data out to
.a385	a0 04		ldy #$04			ldy 	#4 							; offset 2,3,4 => A X Y
.a387	91 12		sta ($12),y			sta 	(lastCreate),y
.a389	88		dey				dey
.a38a	68		pla				pla
.a38b	91 12		sta ($12),y			sta 	(lastCreate),y
.a38d	88		dey				dey
.a38e	8a		txa				txa
.a38f	91 12		sta ($12),y			sta 	(lastCreate),y
.a391	7a		ply				ply
.a392	fa		plx				plx
.a393	68		pla				pla
.a394	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/search.asm

.a395					DictionaryReset:
.a395	a9 00		lda #$00			lda 	#(UserDictionary) & $FF
.a397	85 04		sta $04				sta 	dictPtr
.a399	a9 b8		lda #$b8			lda 	#(UserDictionary) >> 8
.a39b	85 05		sta $05				sta 	dictPtr+1
.a39d	9c 00 b8	stz $b800			stz 	UserDictionary
.a3a0	60		rts				rts
.a3a1					DictionarySearchSystemOnly:
.a3a1	38		sec				sec
.a3a2	80 01		bra $a3a5			bra 	DictionarySearchContinue
.a3a4					DictionarySearch:
.a3a4	18		clc				clc
.a3a5					DictionarySearchContinue:
.a3a5	da		phx				phx
.a3a6	5a		phy				phy
.a3a7	08		php				php 								; CS if user only
.a3a8	8a		txa				txa 								; subtract 6 so can use offset Y
.a3a9	38		sec				sec
.a3aa	e9 06		sbc #$06			sbc 	#6
.a3ac	85 0a		sta $0a				sta 	zTemp0
.a3ae	98		tya				tya
.a3af	e9 00		sbc #$00			sbc 	#0
.a3b1	85 0b		sta $0b				sta 	zTemp0+1 					; in zTemp0
.a3b3	28		plp				plp
.a3b4	b0 09		bcs $a3bf			bcs 	_DSCOnly
.a3b6	a2 00		ldx #$00			ldx 	#UserDictionary & $FF
.a3b8	a0 b8		ldy #$b8			ldy 	#UserDictionary >> 8
.a3ba	20 c9 a3	jsr $a3c9			jsr 	DSSearch
.a3bd	b0 07		bcs $a3c6			bcs 	_DSCExit
.a3bf					_DSCOnly:
.a3bf	a2 f8		ldx #$f8			ldx 	#SystemDictionary & $FF
.a3c1	a0 aa		ldy #$aa			ldy 	#SystemDictionary >> 8
.a3c3	20 c9 a3	jsr $a3c9			jsr 	DSSearch
.a3c6					_DSCExit:
.a3c6	7a		ply				ply 								; restore YX
.a3c7	fa		plx				plx
.a3c8	60		rts				rts
.a3c9					DSSearch:
.a3c9	86 0c		stx $0c				stx 	zTemp1 						; save dictionary in zTemp1
.a3cb	84 0d		sty $0d				sty 	zTemp1+1
.a3cd					_DSLoop:
.a3cd	b2 0c		lda ($0c)			lda 	(zTemp1) 					; offset 0 ?
.a3cf	f0 36		beq $a407			beq 	_DSExit
.a3d1	a0 05		ldy #$05			ldy 	#5 							; get length in X
.a3d3	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3d5	aa		tax				tax
.a3d6					_DSCompare:
.a3d6	c8		iny				iny 								; match next ?
.a3d7	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3d9	d1 0a		cmp ($0a),y			cmp 	(zTemp0),y
.a3db	d0 1d		bne $a3fa			bne 	_DSNext
.a3dd	ca		dex				dex 								; done all
.a3de	d0 f6		bne $a3d6			bne 	_DSCompare
.a3e0	a0 05		ldy #$05			ldy 	#5 							; copy bank/address
.a3e2	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3e4	85 20		sta $20				sta 	dirLength
.a3e6	88		dey				dey
.a3e7	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3e9	85 1f		sta $1f				sta 	dirBank
.a3eb	88		dey				dey
.a3ec	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3ee	85 1e		sta $1e				sta 	dirHighByte
.a3f0	88		dey				dey
.a3f1	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a3f3	85 1d		sta $1d				sta 	dirLowByte
.a3f5	88		dey				dey
.a3f6	b1 0c		lda ($0c),y			lda 	(zTemp1),y 					; return type
.a3f8	38		sec				sec
.a3f9	60		rts				rts
.a3fa					_DSNext:
.a3fa	18		clc				clc 								; advance to next.
.a3fb	b2 0c		lda ($0c)			lda 	(zTemp1)
.a3fd	65 0c		adc $0c				adc 	zTemp1
.a3ff	85 0c		sta $0c				sta 	zTemp1
.a401	90 ca		bcc $a3cd			bcc 	_DSLoop
.a403	e6 0d		inc $0d				inc 	zTemp1+1
.a405	80 c6		bra $a3cd			bra 	_DSLoop
.a407					_DSExit:
.a407	18		clc				clc
.a408	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/code.asm

.a409					CodeReset:
.a409	a2 00		ldx #$00			ldx 	#CodeMemory & 255
.a40b	a0 bc		ldy #$bc			ldy 	#CodeMemory >> 8
.a40d	a9 00		lda #$00			lda 	#0
.a40f	80 00		bra $a411			bra 	CodeSetPointer
.a411					CodeSetPointer:
.a411	48		pha				pha 								; copy old to backup
.a412	a5 14		lda $14				lda 	codePtr
.a414	85 28		sta $28				sta 	codeBackup
.a416	a5 15		lda $15				lda 	codePtr+1
.a418	85 29		sta $29				sta 	codeBackup+1
.a41a	a5 16		lda $16				lda 	codeBank
.a41c	85 2a		sta $2a				sta 	codeBackup+2
.a41e	68		pla				pla
.a41f	85 16		sta $16				sta 	codeBank 					; update
.a421	86 14		stx $14				stx 	codePtr
.a423	84 15		sty $15				sty 	codePtr+1
.a425	60		rts				rts
.a426					CodeRestorePointer:
.a426	a5 28		lda $28				lda 	codeBackup
.a428	85 14		sta $14				sta 	codePtr
.a42a	a5 29		lda $29				lda 	codeBackup+1
.a42c	85 15		sta $15				sta 	codePtr+1
.a42e	a5 2a		lda $2a				lda 	codeBackup+2
.a430	85 16		sta $16				sta 	codeBank
.a432	60		rts				rts
.a433					CodeWriteByte:
.a433	92 14		sta ($14)			sta 	(codePtr)
.a435	e6 14		inc $14				inc 	codePtr
.a437	d0 02		bne $a43b			bne 	_CWBNoCarry
.a439	e6 15		inc $15				inc 	codePtr+1
.a43b					_CWBNoCarry:
.a43b	60		rts				rts
.a43c					CodeWriteBranch:
.a43c	18		clc				clc 								; borrow 1 as branch is from one on
.a43d	8a		txa				txa
.a43e	e5 14		sbc $14				sbc 	codePtr
.a440	20 33 a4	jsr $a433			jsr 	CodeWriteByte 				; compile anyway.
.a443	aa		tax				tax 								; actual result in X.
.a444	98		tya				tya
.a445	e5 15		sbc $15				sbc 	codePtr+1
.a447	f0 14		beq $a45d			beq 	_CWBCheckPositive 			; 00xx
.a449	c9 ff		cmp #$ff			cmp 	#$FF
.a44b	f0 14		beq $a461			beq 	_CWBCheckNegative 			; FFxx
.a44d					_CWBError:
.a44d	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a450	4c 45 41 4e 3a 42 52 41				.text 	"LEAN:","BRANCH?",$00
>a458	4e 43 48 3f 00
.a45d					_CWBCheckPositive:
.a45d	8a		txa				txa
.a45e	30 ed		bmi $a44d			bmi 	_CWBError
.a460	60		rts				rts
.a461					_CWBCheckNegative:
.a461	8a		txa				txa
.a462	10 e9		bpl $a44d			bpl 	_CWBError
.a464	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/error.asm

.a465					SyntaxError:
.a465	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a468	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX",$00
>a470	54 41 58 00
.a474					ErrorHandler:
.a474	fa		plx				plx 								; pull address off.
.a475	7a		ply				ply
.a476	e8		inx				inx 								; point to message
.a477	d0 01		bne $a47a			bne 	_EHNoCarry
.a479	c8		iny				iny
.a47a					_EHNoCarry:
.a47a	20 c0 a4	jsr $a4c0			jsr 	PrintStringXY 				; print string at XY
.a47d	a2 a0		ldx #$a0			ldx 	#_EHMessage & $FF 			; print " AT "
.a47f	a0 a4		ldy #$a4			ldy 	#_EHMessage >> 8
.a481	20 c0 a4	jsr $a4c0			jsr 	PrintStringXY
.a484	a6 1a		ldx $1a				ldx 	lineNumber 					; convert line number
.a486	a4 1b		ldy $1b				ldy 	lineNumber+1
.a488	20 34 a7	jsr $a734			jsr 	IntToString
.a48b	a2 40		ldx #$40			ldx 	#lineBuffer & $FF 			; print number
.a48d	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a48f	20 c0 a4	jsr $a4c0			jsr 	PrintStringXY
.a492	64 18		stz $18				stz 	lastDefine 					; disable running by zeroing last defined
.a494	64 19		stz $19				stz 	lastDefine+1
.a496	a2 a5		ldx #$a5			ldx 	#_EHMessage2 & $FF 			; print " AT "
.a498	a0 a4		ldy #$a4			ldy 	#_EHMessage2 >> 8
.a49a	20 c0 a4	jsr $a4c0			jsr 	PrintStringXY
.a49d	4c 2a a0	jmp $a02a			jmp 	ReturnCaller 				; exit the compiler.
.a4a0					_EHMessage:
>a4a0	20 41 54 20 00					.text	" AT ",0
.a4a5					_EHMessage2:
>a4a5	0d 20 20 20 20 4c 45 41				.text 	13,"    LEAN V0.1 (27-OCT-19)",0
>a4ad	4e 20 56 30 2e 31 20 28 32 37 2d 4f 43 54 2d 31
>a4bd	39 29 00
.a4c0					PrintStringXY:
.a4c0	86 0a		stx $0a				stx 	zTemp0
.a4c2	84 0b		sty $0b				sty 	zTemp0+1
.a4c4	a0 00		ldy #$00			ldy 	#0
.a4c6	b1 0a		lda ($0a),y	_PSLoop:lda 	(zTemp0),y
.a4c8	f0 06		beq $a4d0			beq 	_PSExit
.a4ca	20 d1 a4	jsr $a4d1			jsr 	PrintCharacter
.a4cd	c8		iny				iny
.a4ce	80 f6		bra $a4c6			bra 	_PSLoop
.a4d0	60		rts		_PSExit:rts
.a4d1					PrintCharacter:
.a4d1	48		pha				pha
.a4d2	da		phx				phx
.a4d3	5a		phy				phy
.a4d4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a4d7	7a		ply				ply
.a4d8	fa		plx				plx
.a4d9	68		pla				pla
.a4da	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/procedure.asm

.a4db					Action_Procedure_Def:
.a4db	20 cf a2	jsr $a2cf			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a4de	a9 50		lda #$50			lda 	#"P"
.a4e0	20 32 a3	jsr $a332			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a4e3	a5 16		lda $16				lda 	codeBank 					; and assign it the current PC value.
.a4e5	a6 14		ldx $14				ldx 	codePtr
.a4e7	a4 15		ldy $15				ldy 	codePtr+1
.a4e9	86 18		stx $18				stx 	lastDefine 					; update last defined
.a4eb	84 19		sty $19				sty 	lastDefine+1
.a4ed	20 81 a3	jsr $a381			jsr 	DictionarySet 				; set the dictionary values.
.a4f0	a9 28		lda #$28			lda 	#"("
.a4f2	20 05 a3	jsr $a305			jsr 	EGetSyntaxCheck
.a4f5	a9 29		lda #$29			lda 	#")"
.a4f7	20 05 a3	jsr $a305			jsr 	EGetSyntaxCheck
.a4fa	a9 50		lda #$50			lda 	#SCM_PROC 					; put a procedure marker on the stack.
.a4fc	20 2c a8	jsr $a82c			jsr 	StackPush
.a4ff	60		rts				rts
.a500					_APError:
.a500	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a503	4c 45 41 4e 3a 50 52 4f				.text 	"LEAN:","PROCDEF",$00
>a50b	43 44 45 46 00
.a510					Action_EndProc:
.a510	a9 50		lda #$50			lda 	#SCM_PROC 					; check corresponding PROC
.a512	20 48 a8	jsr $a848			jsr 	StackCheckStructureMarker
.a515	a9 60		lda #$60			lda 	#CPU_RETURN					; write out RTS
.a517	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a51a	a9 01		lda #$01			lda 	#1 							; remove from stack.
.a51c	20 75 a8	jsr $a875			jsr 	StackPopStack
.a51f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/call.asm

.a520					Action_Call:
.a520	a5 22		lda $22				lda 	genPos 						; get position
.a522	3a		dec a				dec 	a 							; point to the <proc>
.a523	48		pha				pha 								; save it
.a524	a9 28		lda #$28			lda 	#'('						; check (
.a526	20 05 a3	jsr $a305			jsr 	EGetSyntaxCheck
.a529	20 27 a3	jsr $a327			jsr 	EGLookNext 					; ) next ?
.a52c	c9 a9		cmp #$a9			cmp 	#')'+$80
.a52e	f0 1a		beq $a54a			beq 	_ACNoParameters
.a530	a9 52		lda #$52			lda 	#"R" 	 					; do R=<something>
.a532	20 63 a5	jsr $a563			jsr 	ACDoParameter 				; do the parameter.
.a535	20 2f a3	jsr $a32f			jsr 	EGSkipNext 					; skip the parameter
.a538	20 27 a3	jsr $a327			jsr 	EGLookNext 					; what follows
.a53b	c9 ac		cmp #$ac			cmp 	#","+$80 					; if not comma
.a53d	d0 0b		bne $a54a			bne 	_ACNoParameters 			; should be end of parameters
.a53f	20 2f a3	jsr $a32f			jsr 	EGSkipNext 					; skip ,
.a542	a9 59		lda #$59			lda 	#"Y"						; do Y=<something>
.a544	20 63 a5	jsr $a563			jsr 	ACDoParameter 				; do the parameter.
.a547	20 2f a3	jsr $a32f			jsr 	EGSkipNext 					; skip parameter.
.a54a					_ACNoParameters:
.a54a	a9 29		lda #$29			lda 	#')' 						; check closing bracket.
.a54c	20 05 a3	jsr $a305			jsr 	EGetSyntaxCheck
.a54f	68		pla				pla 								; restore procedure posiion.
.a550	20 99 a2	jsr $a299			jsr 	GenCopyData					; get the data
.a553	a9 20		lda #$20			lda 	#CPU_JSR					; output a call to it.
.a555	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a558	a5 25		lda $25				lda 	elementData
.a55a	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a55d	a5 26		lda $26				lda 	elementData+1
.a55f	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a562	60		rts				rts
.a563					ACDoParameter:
.a563	a6 22		ldx $22				ldx 	genPos 						; save position
.a565	da		phx				phx
.a566	48		pha				pha 								; save the target register
.a567	bd 40 06	lda $0640,x			lda 	lineBuffer,x 				; what is there ?
.a56a	c9 e1		cmp #$e1			cmp 	#"a"+$80 					; check a-z
.a56c	90 1a		bcc $a588			bcc 	_ADPError
.a56e	c9 fb		cmp #$fb			cmp 	#"z"+$81
.a570	b0 16		bcs $a588			bcs 	_ADPError
.a572	ca		dex				dex 								; write = before it
.a573	a9 bd		lda #$bd			lda 	#"="+$80
.a575	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a578	ca		dex				dex
.a579	68		pla				pla 								; write Y/R before that
.a57a	09 80		ora #$80			ora 	#$80
.a57c	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a57f	86 22		stx $22				stx 	genPos 						; make genPos point to that.
.a581	20 dd a1	jsr $a1dd			jsr 	GenerateOne 				; generate that.
.a584	68		pla				pla 								; restore position
.a585	85 22		sta $22				sta 	genPos
.a587	60		rts				rts
.a588					_ADPError:
.a588	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a58b	4c 45 41 4e 3a 50 41 52				.text 	"LEAN:","PARAMETER?",$00
>a593	41 4d 45 54 45 52 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/if.asm

.a59b					Action_If:
.a59b	a5 23		lda $23				lda 	generateVar 				; branch to use.
.a59d	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a59f	20 33 a4	jsr $a433			jsr 	CodeWriteByte 				; output it
.a5a2	20 1c a8	jsr $a81c			jsr 	StackPushPC 				; push branch position on stack
.a5a5	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a5a7	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a5aa	a9 49		lda #$49			lda 	#SCM_IF 					; put if marker on the stack.
.a5ac	20 2c a8	jsr $a82c			jsr 	StackPush
.a5af	60		rts				rts
.a5b0					Action_Else:
.a5b0	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a5b2	20 48 a8	jsr $a848			jsr 	StackCheckStructureMarker
.a5b5	a9 80		lda #$80			lda 	#CPU_BRA 					; compile branch
.a5b7	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a5ba	a5 14		lda $14				lda 	codePtr 					; push current position on the stack
.a5bc	48		pha				pha
.a5bd	a5 15		lda $15				lda 	codePtr+1
.a5bf	48		pha				pha
.a5c0	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a5c2	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a5c5	20 e0 a5	jsr $a5e0			jsr 	BackPatchIf 				; do the backpatch.
.a5c8	68		pla				pla 								; overwrite backpatch address
.a5c9	a0 01		ldy #$01			ldy 	#1 							; with stacked position.
.a5cb	91 02		sta ($02),y			sta 	(aStackPtr),y
.a5cd	68		pla				pla
.a5ce	c8		iny				iny
.a5cf	91 02		sta ($02),y			sta 	(aStackPtr),y
.a5d1	60		rts				rts
.a5d2					Action_Endif:
.a5d2	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a5d4	20 48 a8	jsr $a848			jsr 	StackCheckStructureMarker
.a5d7	20 e0 a5	jsr $a5e0			jsr 	BackPatchIf 				; do the backpatch.
.a5da	a9 04		lda #$04			lda 	#3+1 						; throw the stack.
.a5dc	20 75 a8	jsr $a875			jsr 	StackPopStack
.a5df	60		rts				rts
.a5e0					BackPatchIf:
.a5e0	a5 14		lda $14					lda 	codePtr 					; save code pointer
.a5e2	48		pha				pha
.a5e3	a5 15		lda $15				lda 	codePtr+1
.a5e5	48		pha				pha
.a5e6	a0 03		ldy #$03			ldy 	#3 							; AYX = address.
.a5e8	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a5ea	48		pha				pha
.a5eb	88		dey				dey
.a5ec	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a5ee	aa		tax				tax
.a5ef	88		dey				dey
.a5f0	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a5f2	a8		tay				tay
.a5f3	68		pla				pla
.a5f4	20 11 a4	jsr $a411			jsr 	CodeSetPointer 				; set write position to that
.a5f7	7a		ply				ply 								; target address in YX
.a5f8	fa		plx				plx
.a5f9	20 3c a4	jsr $a43c			jsr 	CodeWriteBranch 			; write the actual branch there
.a5fc	20 26 a4	jsr $a426			jsr 	CodeRestorePointer 			; undo the set pointer.
.a5ff	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/repeat.asm

.a600					Action_Repeat:
.a600	20 1c a8	jsr $a81c			jsr 	StackPushPC 					; push loop position on stack
.a603	a9 52		lda #$52			lda 	#SCM_REPEAT 					; put a repeat marker on the stack.
.a605	20 2c a8	jsr $a82c			jsr 	StackPush
.a608	60		rts				rts
.a609					Action_Until:
.a609	a9 52		lda #$52			lda 	#SCM_REPEAT 				; check corresponding repeat
.a60b	20 48 a8	jsr $a848			jsr 	StackCheckStructureMarker
.a60e	a5 23		lda $23				lda 	generateVar 				; branch to use.
.a610	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a612	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a614	20 60 a8	jsr $a860			jsr 	StackCompileBranch 			; compile a branch.
.a617	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a619	20 75 a8	jsr $a875			jsr 	StackPopStack
.a61c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/for.asm

.a61d					Action_AFor:
.a61d	20 1c a8	jsr $a81c			jsr 	StackPushPC 					; push loop position on stack
.a620	a9 48		lda #$48			lda 	#CPU_PHA 						; push index on stack
.a622	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a625	a9 3a		lda #$3a			lda 	#CPU_DECA 						; counts backwards from n-1 to 0.
.a627	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a62a	a9 46		lda #$46			lda 	#SCM_FOR 						; put a for marker on the stack.
.a62c	20 2c a8	jsr $a82c			jsr 	StackPush
.a62f	60		rts				rts
.a630					Action_Next:
.a630	a9 46		lda #$46			lda 	#SCM_FOR 					; check corresponding for
.a632	20 48 a8	jsr $a848			jsr 	StackCheckStructureMarker
.a635	a9 68		lda #$68			lda 	#CPU_PLA 					; pop index off stack and decrement
.a637	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a63a	a9 3a		lda #$3a			lda 	#CPU_DECA
.a63c	20 33 a4	jsr $a433			jsr 	CodeWriteByte
.a63f	a9 d0		lda #$d0			lda 	#CPU_BNE 					; branch back if #0
.a641	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a643	20 60 a8	jsr $a860			jsr 	StackCompileBranch 			; compile a branch.
.a646	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a648	20 75 a8	jsr $a875			jsr 	StackPopStack
.a64b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/variables.asm

.a64c					VariableReset:
.a64c	a9 00		lda #$00			lda 	#(VariableMemory) & $FF
.a64e	85 08		sta $08				sta 	varPtr
.a650	a9 07		lda #$07			lda 	#(VariableMemory) >> 8
.a652	85 09		sta $09				sta 	varPtr+1
.a654	60		rts				rts
.a655					Action_ByteVar:
.a655	a9 01		lda #$01			lda 	#1
.a657	80 02		bra $a65b			bra 	VariableDeclare
.a659					Action_WordVar:
.a659	a9 02		lda #$02			lda 	#2
.a65b					VariableDeclare:
.a65b	85 2b		sta $2b				sta 	varSize 					; save variable size.
.a65d					_VDLoop:
.a65d	a9 53		lda #$53			lda 	#"S"						; get I or S
.a65f	a6 2b		ldx $2b				ldx 	varSize
.a661	ca		dex				dex
.a662	f0 02		beq $a666			beq 	_VDNotWord
.a664	a9 49		lda #$49			lda 	#"I"
.a666					_VDNotWord:
.a666	48		pha				pha
.a667	20 cf a2	jsr $a2cf			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a66a	68		pla				pla
.a66b	20 32 a3	jsr $a332			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a66e	20 27 a3	jsr $a327			jsr 	EGLookNext 					; what's next ?
.a671	c9 c0		cmp #$c0			cmp 	#'@'|$80 					; if not @, use default
.a673	d0 21		bne $a696			bne 	_VDDefault
.a675	20 2f a3	jsr $a32f			jsr 	EGSkipNext 					; skip @
.a678	20 27 a3	jsr $a327			jsr 	EGLookNext 					; get next
.a67b	c9 e2		cmp #$e2			cmp 	#'b'|$80 					; must be b/w constant
.a67d	f0 04		beq $a683			beq 	_VDLegit
.a67f	c9 f7		cmp #$f7			cmp 	#'w'|$80
.a681	d0 34		bne $a6b7			bne 	_VDError
.a683					_VDLegit:
.a683	a5 22		lda $22				lda 	genPos 						; position
.a685	20 99 a2	jsr $a299			jsr 	GenCopyData					; access data
.a688	a9 00		lda #$00			lda 	#0 		 					; set the address
.a68a	a6 25		ldx $25				ldx 	elementData
.a68c	a4 26		ldy $26				ldy 	elementData+1
.a68e	20 81 a3	jsr $a381			jsr 	DictionarySet
.a691	20 2f a3	jsr $a32f			jsr 	EGSkipNext 					; consume the constant
.a694	80 14		bra $a6aa			bra 	_VDTryNext
.a696					_VDDefault:
.a696	a6 08		ldx $08				ldx 	varPtr 						; place at default position
.a698	a4 09		ldy $09				ldy 	varPtr+1
.a69a	a9 00		lda #$00			lda 	#0
.a69c	20 81 a3	jsr $a381			jsr 	DictionarySet
.a69f	a5 2b		lda $2b				lda 	varSize 					; get count of bytes back
.a6a1	18		clc				clc
.a6a2	65 08		adc $08				adc 	varPtr
.a6a4	85 08		sta $08				sta 	varPtr
.a6a6	90 02		bcc $a6aa			bcc 	_VDNoCarry
.a6a8	e6 09		inc $09				inc 	varPtr+1
.a6aa					_VDNoCarry:
.a6aa					_VDTryNext:
.a6aa	20 27 a3	jsr $a327			jsr 	EGLookNext 					; what's next ?
.a6ad	c9 ac		cmp #$ac			cmp 	#","|$80 					; is it a comma
.a6af	d0 05		bne $a6b6			bne 	_VDExit 					; no, exit.
.a6b1	20 2f a3	jsr $a32f			jsr 	EGSkipNext
.a6b4	80 a7		bra $a65d			bra 	_VDLoop
.a6b6					_VDExit:
.a6b6	60		rts				rts
.a6b7					_VDError:
.a6b7	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a6ba	4c 45 41 4e 3a 41 44 44				.text 	"LEAN:","ADDRESS?",$00
>a6c2	52 45 53 53 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/crunch.asm

.a6c8					Action_DictionaryCrunch:
.a6c8	a9 00		lda #$00			lda 	#(UserDictionary) & $FF
.a6ca	85 0a		sta $0a				sta 	zTemp0
.a6cc	a9 b8		lda #$b8			lda 	#(UserDictionary) >> 8
.a6ce	85 0b		sta $0b				sta 	zTemp0+1
.a6d0					_ADCLoop:
.a6d0	b2 0a		lda ($0a)			lda 	(zTemp0) 					; reached end of dictionary
.a6d2	f0 5f		beq $a733			beq 	_ADCExit
.a6d4	a0 05		ldy #$05			ldy 	#5 							; length into X.
.a6d6	b1 0a		lda ($0a),y			lda 	(zTemp0),y
.a6d8	aa		tax				tax
.a6d9					_ADCCheck:
.a6d9	c8		iny				iny 								; get next.
.a6da	b1 0a		lda ($0a),y			lda 	(zTemp0),y
.a6dc	29 7f		and #$7f			and 	#$7F 						; is it a '.' ?
.a6de	c9 2e		cmp #$2e			cmp 	#'.'
.a6e0	f0 44		beq $a726			beq 	_ADCNext 					; if so, it's a global, skip to next.
.a6e2	ca		dex				dex
.a6e3	d0 f4		bne $a6d9			bne 	_ADCCheck 					; checked the whole identifier.
.a6e5	a5 0a		lda $0a				lda 	zTemp0 						; work out copy from, into zTemp1
.a6e7	48		pha				pha
.a6e8	18		clc				clc
.a6e9	72 0a		adc ($0a)			adc 	(zTemp0)
.a6eb	85 0c		sta $0c				sta 	zTemp1
.a6ed	a5 0b		lda $0b				lda 	zTemp0+1
.a6ef	48		pha				pha
.a6f0	69 00		adc #$00			adc 	#0
.a6f2	85 0d		sta $0d				sta 	zTemp1+1
.a6f4					_ADCopyOverwrite:
.a6f4	b2 0c		lda ($0c)			lda 	(zTemp1) 					; byte copy
.a6f6	92 0a		sta ($0a)			sta 	(zTemp0)
.a6f8	a5 0c		lda $0c				lda 	zTemp1 						; until the upper address = dictionary top
.a6fa	c5 04		cmp $04				cmp 	dictPtr
.a6fc	d0 06		bne $a704			bne 	_ADCNextCopy
.a6fe	a5 0d		lda $0d				lda 	zTemp1+1
.a700	c5 05		cmp $05				cmp 	dictPtr+1
.a702	f0 0e		beq $a712			beq 	_ADCRemoved
.a704					_ADCNextCopy:
.a704	e6 0a		inc $0a				inc 	zTemp0
.a706	d0 02		bne $a70a			bne 	_NoCarry
.a708	e6 0b		inc $0b				inc 	zTemp0+1
.a70a					_NoCarry:
.a70a	e6 0c		inc $0c				inc 	zTemp1
.a70c	d0 02		bne $a710			bne 	_NoCarry
.a70e	e6 0d		inc $0d				inc 	zTemp1+1
.a710					_NoCarry:
.a710	80 e2		bra $a6f4			bra 	_ADCopyOverwrite
.a712					_ADCRemoved:
.a712	a5 0a		lda $0a				lda 	zTemp0 						; copy from position is new top.
.a714	85 04		sta $04				sta 	dictPtr
.a716	a5 0b		lda $0b				lda 	zTemp0+1
.a718	85 05		sta $05				sta 	dictPtr+1
.a71a	a9 00		lda #$00			lda 	#0							; mark end as not copied in loop
.a71c	92 04		sta ($04)			sta 	(dictPtr)
.a71e	68		pla				pla 								; restore original position.
.a71f	85 0b		sta $0b				sta 	zTemp0+1
.a721	68		pla				pla
.a722	85 0a		sta $0a				sta 	zTemp0
.a724	80 aa		bra $a6d0			bra 	_ADCLoop 					; and continue from same position.
.a726					_ADCNext:
.a726	18		clc				clc 								; advance to next.
.a727	a5 0a		lda $0a				lda 	zTemp0
.a729	72 0a		adc ($0a)			adc 	(zTemp0)
.a72b	85 0a		sta $0a				sta 	zTemp0
.a72d	90 a1		bcc $a6d0			bcc 	_ADCLoop
.a72f	e6 0b		inc $0b				inc 	zTemp0+1
.a731	80 9d		bra $a6d0			bra 	_ADCLoop
.a733					_ADCExit:
.a733	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/tostring.asm

.a734					IntToString:
.a734	86 0a		stx $0a				stx 	zTemp0 						; count is in zTemp0
.a736	84 0b		sty $0b				sty 	zTemp0+1
.a738	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a73a	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a73c					_ITSLoop:
.a73c	64 0c		stz $0c				stz 	zTemp1 						; this is the count of subtracts.
.a73e					_ITSSubtractLoop:
.a73e	38		sec				sec
.a73f	a5 0a		lda $0a				lda 	zTemp0 						; try to calculate
.a741	fd 77 a7	sbc $a777,x			sbc 	_ITSWords,x
.a744	48		pha				pha
.a745	a5 0b		lda $0b				lda 	zTemp0+1
.a747	fd 78 a7	sbc $a778,x			sbc 	_ITSWords+1,x
.a74a	90 09		bcc $a755			bcc 	_ITSEndSub 					; can't subtract any more.
.a74c	85 0b		sta $0b				sta 	zTemp0+1 					; update zTemp
.a74e	68		pla				pla
.a74f	85 0a		sta $0a				sta 	zTemp0
.a751	e6 0c		inc $0c				inc 	zTemp1 						; bump subtract count.
.a753	80 e9		bra $a73e			bra 	_ITSSubtractLoop
.a755					_ITSEndSub:
.a755	68		pla				pla 								; throw away the interim result
.a756	a5 0c		lda $0c				lda 	zTemp1 						; if the subtract count is non zero
.a758	d0 04		bne $a75e			bne 	_ITSWriteOut 				; always write it out
.a75a	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a75c	f0 06		beq $a764			beq 	_ITSNext 					; suppressing leading zeros.
.a75e					_ITSWriteOut:
.a75e	09 30		ora #$30			ora 	#48 						; output digit.
.a760	99 40 06	sta $0640,y			sta 	lineBuffer,y
.a763	c8		iny				iny
.a764					_ITSNext:
.a764	e8		inx				inx
.a765	e8		inx				inx
.a766	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a768	d0 d2		bne $a73c			bne 	_ITSLoop 					; do the new digits
.a76a	a5 0a		lda $0a				lda 	zTemp0 						; output the last digit
.a76c	09 30		ora #$30			ora 	#48
.a76e	99 40 06	sta $0640,y			sta 	lineBuffer,y 				; make it ASCIIZ.
.a771	a9 00		lda #$00			lda 	#0
.a773	99 41 06	sta $0641,y			sta 	lineBuffer+1,y
.a776	60		rts				rts
.a777					_ITSWords:
>a777	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a77f					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: utility/tointeger.asm

.a77f					StringToInt:
.a77f	86 10		stx $10				stx 	zTemp3 						; save string
.a781	84 11		sty $11				sty 	zTemp3+1
.a783	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a785	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a787	b2 10		lda ($10)			lda 	(zTemp3) 					; first character
.a789	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a78b	f0 1b		beq $a7a8			beq 	_STIConvert 				; convert from character 1, base 16.
.a78d	88		dey				dey 								; from character 0
.a78e	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a790	c9 2d		cmp #$2d			cmp 	#"-"						; first char is unary minus ?
.a792	d0 14		bne $a7a8			bne 	_STIConvert 				; no, convert as +ve decimal
.a794	c8		iny				iny 								; skip the minus
.a795	20 a8 a7	jsr $a7a8			jsr 	_STIConvert 				; convert the unsigned part.
.a798	90 0d		bcc $a7a7			bcc 	_STIExit 					; failed
.a79a	8a		txa				txa 								; 1's complement YX
.a79b	49 ff		eor #$ff			eor 	#$FF
.a79d	aa		tax				tax
.a79e	98		tya				tya
.a79f	49 ff		eor #$ff			eor 	#$FF
.a7a1	a8		tay				tay
.a7a2	e8		inx				inx 								; +1 to make it negative
.a7a3	38		sec				sec
.a7a4	d0 01		bne $a7a7			bne 	_STIExit
.a7a6	c8		iny				iny
.a7a7					_STIExit:
.a7a7	60		rts				rts
.a7a8					_STIConvert:
.a7a8	86 0c		stx $0c				stx 	zTemp1 						; save base in zTemp1
.a7aa	b1 10		lda ($10),y			lda 	(zTemp3),y 					; get first character
.a7ac	f0 5f		beq $a80d			beq 	_STIFail 					; if zero, then it has failed anyway.
.a7ae	64 0a		stz $0a				stz 	zTemp0 						; clear the result.
.a7b0	64 0b		stz $0b				stz 	zTemp0+1
.a7b2					_STILoop:
.a7b2	a5 0a		lda $0a				lda 	zTemp0 						; copy current to zTemp2
.a7b4	85 0e		sta $0e				sta 	zTemp2
.a7b6	a5 0b		lda $0b				lda 	zTemp0+1
.a7b8	85 0f		sta $0f				sta 	zTemp2+1
.a7ba	64 0a		stz $0a				stz 	zTemp0 						; clear result
.a7bc	64 0b		stz $0b				stz 	zTemp0+1
.a7be	a6 0c		ldx $0c				ldx 	zTemp1 						; X contains the base.
.a7c0					_STIMultiply:
.a7c0	8a		txa				txa 								; shift Y right into carry.
.a7c1	4a		lsr a				lsr 	a
.a7c2	aa		tax				tax
.a7c3	90 0d		bcc $a7d2			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a7c5	18		clc				clc
.a7c6	a5 0e		lda $0e				lda 	zTemp2 						; add zTemp2 into zTemp0
.a7c8	65 0a		adc $0a				adc 	zTemp0
.a7ca	85 0a		sta $0a				sta 	zTemp0
.a7cc	a5 0f		lda $0f				lda 	zTemp2+1
.a7ce	65 0b		adc $0b				adc 	zTemp0+1
.a7d0	85 0b		sta $0b				sta 	zTemp0+1
.a7d2					_STINoAdd:
.a7d2	06 0e		asl $0e				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a7d4	26 0f		rol $0f				rol 	zTemp2+1
.a7d6	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a7d8	d0 e6		bne $a7c0			bne 	_STIMultiply
.a7da	b1 10		lda ($10),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a7dc	29 7f		and #$7f			and 	#$7F 						; remove End of Token bit if set
.a7de	c9 30		cmp #$30			cmp 	#"0"
.a7e0	90 2b		bcc $a80d			bcc 	_STIFail
.a7e2	c9 3a		cmp #$3a			cmp 	#"9"+1
.a7e4	90 0b		bcc $a7f1			bcc 	_STIOkay
.a7e6	c9 41		cmp #$41			cmp 	#"A"
.a7e8	90 23		bcc $a80d			bcc 	_STIFail
.a7ea	c9 47		cmp #$47			cmp 	#"F"+1
.a7ec	b0 1f		bcs $a80d			bcs 	_STIFail
.a7ee	38		sec				sec 								; hex adjust
.a7ef	e9 07		sbc #$07			sbc 	#7
.a7f1					_STIOkay:
.a7f1	38		sec				sec
.a7f2	e9 30		sbc #$30			sbc 	#48
.a7f4	c5 0c		cmp $0c				cmp 	zTemp1  					; if >= base then fail.
.a7f6	b0 15		bcs $a80d			bcs 	_STIFail
.a7f8	d8		cld				cld
.a7f9	65 0a		adc $0a				adc 	zTemp0 						; add into the current value
.a7fb	85 0a		sta $0a				sta 	zTemp0
.a7fd	90 02		bcc $a801			bcc 	_STINoCarry
.a7ff	e6 0b		inc $0b				inc 	zTemp0+1
.a801					_STINoCarry:
.a801	b1 10		lda ($10),y			lda 	(zTemp3),y					; get character just done.
.a803	c8		iny				iny 								; point to next
.a804	0a		asl a				asl 	a 							; shift bit 7 into carry
.a805	90 ab		bcc $a7b2			bcc 	_STILoop 					; not reached the end.
.a807	a6 0a		ldx $0a				ldx 	zTemp0 						; return result
.a809	a4 0b		ldy $0b				ldy 	zTemp0+1
.a80b	38		sec				sec
.a80c	60		rts				rts
.a80d					_STIFail:
.a80d	18		clc				clc
.a80e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/astack.asm

.a80f					StackReset:
.a80f	a9 3f		lda #$3f			lda 	#(assemblerStack) & $FF
.a811	85 02		sta $02				sta 	aStackPtr
.a813	a9 06		lda #$06			lda 	#(assemblerStack) >> 8
.a815	85 03		sta $03				sta 	aStackPtr+1
.a817	a9 2a		lda #$2a			lda 	#SCM_TOP
.a819	92 02		sta ($02)			sta 	(aStackPtr)
.a81b	60		rts				rts
.a81c					StackPushPC:
.a81c	a5 16		lda $16				lda 	codeBank
.a81e	20 2c a8	jsr $a82c			jsr 	StackPush
.a821	a5 14		lda $14				lda 	codePtr
.a823	20 2c a8	jsr $a82c			jsr 	StackPush
.a826	a5 15		lda $15				lda 	codePtr+1
.a828	20 2c a8	jsr $a82c			jsr 	StackPush
.a82b	60		rts				rts
.a82c					StackPush:
.a82c	c6 02		dec $02				dec 	aStackPtr 					; decrement TOS pointer.
.a82e	f0 03		beq $a833			beq 	_SPStack
.a830	92 02		sta ($02)			sta 	(aStackPtr)					; write to new TOS
.a832	60		rts				rts
.a833					_SPStack:
.a833	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a836	4c 45 41 4e 3a 52 45 54				.text 	"LEAN:","RETURN STACK",$00
>a83e	55 52 4e 20 53 54 41 43 4b 00
.a848					StackCheckStructureMarker:
.a848	d2 02		cmp ($02)			cmp 	(aStackPtr)					; check if tos matches
.a84a	d0 01		bne $a84d			bne 	_SCSError
.a84c	60		rts				rts
.a84d					_SCSError:
.a84d	20 74 a4	jsr $a474			jsr 	ErrorHandler
>a850	4c 45 41 4e 3a 53 54 52				.text 	"LEAN:","STRUCTURES",$00
>a858	55 43 54 55 52 45 53 00
.a860					StackCompileBranch:
.a860	48		pha				pha
.a861	da		phx				phx
.a862	5a		phy				phy
.a863	20 33 a4	jsr $a433			jsr 	CodeWriteByte 				; write the opcode.
.a866	c8		iny				iny
.a867	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a869	aa		tax				tax
.a86a	88		dey				dey
.a86b	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a86d	a8		tay				tay
.a86e	20 3c a4	jsr $a43c			jsr 	CodeWriteBranch 			; write a branch there.
.a871	7a		ply				ply
.a872	fa		plx				plx
.a873	68		pla				pla
.a874	60		rts				rts
.a875					StackPopStack:
.a875	18		clc				clc 								; return stack all in same page
.a876	65 02		adc $02				adc 	aStackPtr 					; so we don't carry out.
.a878	85 02		sta $02				sta 	aStackPtr
.a87a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/system.inc

.a87b					L10000:
>a87b	09					.byte L10000_END-L10000-1
.a87c	91 63		sta ($63),y		sta  ($63),y
.a87e	c8		iny			iny
.a87f	8a		txa			txa
.a880	91 63		sta ($63),y		sta  ($63),y
.a882	88		dey			dey
.a883	b1 63		lda ($63),y		lda  ($63),y
.a885					L10000_END:
.a885					L10001:
>a885	02					.byte L10001_END-L10001-1
.a886	91 63		sta ($63),y		sta  ($63),y
.a888					L10001_END:
.a888					L10002:
>a888	02					.byte L10002_END-L10002-1
.a889	84 63		sty $63			sty  $63
.a88b					L10002_END:
.a88b					L10003:
>a88b	02					.byte L10003_END-L10003-1
.a88c	85 63		sta $63			sta  $63
.a88e					L10003_END:
.a88e					L10004:
>a88e	02					.byte L10004_END-L10004-1
.a88f	85 63		sta $63			sta  $63
.a891					L10004_END:
.a891					L10005:
>a891	02					.byte L10005_END-L10005-1
>a892	a3 00					.byte $a3,$00
.a894					L10005_END:
.a894					L10006:
>a894	06					.byte L10006_END-L10006-1
.a895	8d 63 73	sta $7363		sta  $7363
.a898	8e 83 73	stx $7383		stx  $7383
.a89b					L10006_END:
.a89b					L10007:
>a89b	04					.byte L10007_END-L10007-1
.a89c	85 63		sta $63			sta  $63
.a89e	86 83		stx $83			stx  $83
.a8a0					L10007_END:
.a8a0					L10008:
>a8a0	03					.byte L10008_END-L10008-1
.a8a1	8c 63 73	sty $7363		sty  $7363
.a8a4					L10008_END:
.a8a4					L10009:
>a8a4	03					.byte L10009_END-L10009-1
.a8a5	8d 63 73	sta $7363		sta  $7363
.a8a8					L10009_END:
.a8a8					L10010:
>a8a8	03					.byte L10010_END-L10010-1
.a8a9	8d 63 73	sta $7363		sta  $7363
.a8ac					L10010_END:
.a8ac					L10011:
>a8ac	07					.byte L10011_END-L10011-1
.a8ad	8a		txa			txa
.a8ae	49 ff		eor #$ff		eor  #$ff
.a8b0	aa		tax			tax
.a8b1	68		pla			pla
.a8b2	49 ff		eor #$ff		eor  #$ff
.a8b4					L10011_END:
.a8b4					L10012:
>a8b4	02					.byte L10012_END-L10012-1
.a8b5	49 ff		eor #$ff		eor  #$ff
.a8b7					L10012_END:
.a8b7					L10013:
>a8b7	01					.byte L10013_END-L10013-1
.a8b8	5a		phy			phy
.a8b9					L10013_END:
.a8b9					L10014:
>a8b9	02					.byte L10014_END-L10014-1
.a8ba	a4 63		ldy $63			ldy  $63
.a8bc					L10014_END:
.a8bc					L10015:
>a8bc	03					.byte L10015_END-L10015-1
.a8bd	ac 63 73	ldy $7363		ldy  $7363
.a8c0					L10015_END:
.a8c0					L10016:
>a8c0	02					.byte L10016_END-L10016-1
.a8c1	a0 63		ldy #$63		ldy  #$63
.a8c3					L10016_END:
.a8c3					L10017:
>a8c3	01					.byte L10017_END-L10017-1
.a8c4	a8		tay			tay
.a8c5					L10017_END:
.a8c5					L10018:
>a8c5	01					.byte L10018_END-L10018-1
.a8c6	a8		tay			tay
.a8c7					L10018_END:
.a8c7					L10019:
>a8c7	02					.byte L10019_END-L10019-1
>a8c8	a3 01					.byte $a3,$01
.a8ca					L10019_END:
.a8ca					L10020:
>a8ca	02					.byte L10020_END-L10020-1
>a8cb	a3 02					.byte $a3,$02
.a8cd					L10020_END:
.a8cd					L10021:
>a8cd	01					.byte L10021_END-L10021-1
.a8ce	7a		ply			ply
.a8cf					L10021_END:
.a8cf					L10022:
>a8cf	03					.byte L10022_END-L10022-1
.a8d0	7a		ply			ply
.a8d1	fa		plx			plx
.a8d2	68		pla			pla
.a8d3					L10022_END:
.a8d3					L10023:
>a8d3	02					.byte L10023_END-L10023-1
.a8d4	fa		plx			plx
.a8d5	68		pla			pla
.a8d6					L10023_END:
.a8d6					L10024:
>a8d6	01					.byte L10024_END-L10024-1
.a8d7	68		pla			pla
.a8d8					L10024_END:
.a8d8					L10025:
>a8d8	08					.byte L10025_END-L10025-1
.a8d9	49 63		eor #$63		eor  #$63
.a8db	48		pha			pha
.a8dc	8a		txa			txa
.a8dd	49 73		eor #$73		eor  #$73
.a8df	aa		tax			tax
.a8e0	68		pla			pla
.a8e1					L10025_END:
.a8e1					L10026:
>a8e1	0a					.byte L10026_END-L10026-1
.a8e2	51 63		eor ($63),y		eor  ($63),y
.a8e4	48		pha			pha
.a8e5	8a		txa			txa
.a8e6	c8		iny			iny
.a8e7	51 63		eor ($63),y		eor  ($63),y
.a8e9	88		dey			dey
.a8ea	aa		tax			tax
.a8eb	68		pla			pla
.a8ec					L10026_END:
.a8ec					L10027:
>a8ec	02					.byte L10027_END-L10027-1
.a8ed	45 63		eor $63			eor  $63
.a8ef					L10027_END:
.a8ef					L10028:
>a8ef	0a					.byte L10028_END-L10028-1
.a8f0	4d 63 73	eor $7363		eor  $7363
.a8f3	48		pha			pha
.a8f4	8a		txa			txa
.a8f5	4d 83 73	eor $7383		eor  $7383
.a8f8	aa		tax			tax
.a8f9	68		pla			pla
.a8fa					L10028_END:
.a8fa					L10029:
>a8fa	08					.byte L10029_END-L10029-1
.a8fb	45 63		eor $63			eor  $63
.a8fd	48		pha			pha
.a8fe	8a		txa			txa
.a8ff	45 83		eor $83			eor  $83
.a901	aa		tax			tax
.a902	68		pla			pla
.a903					L10029_END:
.a903					L10030:
>a903	03					.byte L10030_END-L10030-1
.a904	4d 63 73	eor $7363		eor  $7363
.a907					L10030_END:
.a907					L10031:
>a907	02					.byte L10031_END-L10031-1
.a908	49 63		eor #$63		eor  #$63
.a90a					L10031_END:
.a90a					L10032:
>a90a	02					.byte L10032_END-L10032-1
>a90b	a3 03					.byte $a3,$03
.a90d					L10032_END:
.a90d					L10033:
>a90d	02					.byte L10033_END-L10033-1
>a90e	a3 04					.byte $a3,$04
.a910					L10033_END:
.a910					L10034:
>a910	03					.byte L10034_END-L10034-1
.a911	48		pha			pha
.a912	da		phx			phx
.a913	5a		phy			phy
.a914					L10034_END:
.a914					L10035:
>a914	02					.byte L10035_END-L10035-1
.a915	48		pha			pha
.a916	da		phx			phx
.a917					L10035_END:
.a917					L10036:
>a917	04					.byte L10036_END-L10036-1
.a918	a9 63		lda #$63		lda  #$63
.a91a	a2 73		ldx #$73		ldx  #$73
.a91c					L10036_END:
.a91c					L10037:
>a91c	07					.byte L10037_END-L10037-1
.a91d	c8		iny			iny
.a91e	b1 63		lda ($63),y		lda  ($63),y
.a920	aa		tax			tax
.a921	88		dey			dey
.a922	b1 63		lda ($63),y		lda  ($63),y
.a924					L10037_END:
.a924					L10038:
>a924	04					.byte L10038_END-L10038-1
.a925	a5 63		lda $63			lda  $63
.a927	a2 00		ldx #$00		ldx  #0
.a929					L10038_END:
.a929					L10039:
>a929	06					.byte L10039_END-L10039-1
.a92a	ad 63 73	lda $7363		lda  $7363
.a92d	ae 83 73	ldx $7383		ldx  $7383
.a930					L10039_END:
.a930					L10040:
>a930	04					.byte L10040_END-L10040-1
.a931	a5 63		lda $63			lda  $63
.a933	a6 83		ldx $83			ldx  $83
.a935					L10040_END:
.a935					L10041:
>a935	05					.byte L10041_END-L10041-1
.a936	ad 63 73	lda $7363		lda  $7363
.a939	a2 00		ldx #$00		ldx  #0
.a93b					L10041_END:
.a93b					L10042:
>a93b	04					.byte L10042_END-L10042-1
.a93c	a9 63		lda #$63		lda  #$63
.a93e	a2 73		ldx #$73		ldx  #$73
.a940					L10042_END:
.a940					L10043:
>a940	03					.byte L10043_END-L10043-1
.a941	98		tya			tya
.a942	a2 00		ldx #$00		ldx  #0
.a944					L10043_END:
.a944					L10044:
>a944	02					.byte L10044_END-L10044-1
.a945	a2 00		ldx #$00		ldx  #0
.a947					L10044_END:
.a947					L10045:
>a947	08					.byte L10045_END-L10045-1
.a948	09 63		ora #$63		ora  #$63
.a94a	48		pha			pha
.a94b	8a		txa			txa
.a94c	09 73		ora #$73		ora  #$73
.a94e	aa		tax			tax
.a94f	68		pla			pla
.a950					L10045_END:
.a950					L10046:
>a950	0a					.byte L10046_END-L10046-1
.a951	11 63		ora ($63),y		ora  ($63),y
.a953	48		pha			pha
.a954	8a		txa			txa
.a955	c8		iny			iny
.a956	11 63		ora ($63),y		ora  ($63),y
.a958	88		dey			dey
.a959	aa		tax			tax
.a95a	68		pla			pla
.a95b					L10046_END:
.a95b					L10047:
>a95b	02					.byte L10047_END-L10047-1
.a95c	05 63		ora $63			ora  $63
.a95e					L10047_END:
.a95e					L10048:
>a95e	0a					.byte L10048_END-L10048-1
.a95f	0d 63 73	ora $7363		ora  $7363
.a962	48		pha			pha
.a963	8a		txa			txa
.a964	0d 83 73	ora $7383		ora  $7383
.a967	aa		tax			tax
.a968	68		pla			pla
.a969					L10048_END:
.a969					L10049:
>a969	08					.byte L10049_END-L10049-1
.a96a	05 63		ora $63			ora  $63
.a96c	48		pha			pha
.a96d	8a		txa			txa
.a96e	05 83		ora $83			ora  $83
.a970	aa		tax			tax
.a971	68		pla			pla
.a972					L10049_END:
.a972					L10050:
>a972	03					.byte L10050_END-L10050-1
.a973	0d 63 73	ora $7363		ora  $7363
.a976					L10050_END:
.a976					L10051:
>a976	02					.byte L10051_END-L10051-1
.a977	09 63		ora #$63		ora  #$63
.a979					L10051_END:
.a979					L10052:
>a979	09					.byte L10052_END-L10052-1
.a97a	38		sec			sec
.a97b	e9 63		sbc #$63		sbc  #$63
.a97d	48		pha			pha
.a97e	8a		txa			txa
.a97f	e9 73		sbc #$73		sbc  #$73
.a981	aa		tax			tax
.a982	68		pla			pla
.a983					L10052_END:
.a983					L10053:
>a983	0b					.byte L10053_END-L10053-1
.a984	38		sec			sec
.a985	f1 63		sbc ($63),y		sbc  ($63),y
.a987	48		pha			pha
.a988	8a		txa			txa
.a989	c8		iny			iny
.a98a	f1 63		sbc ($63),y		sbc  ($63),y
.a98c	88		dey			dey
.a98d	aa		tax			tax
.a98e	68		pla			pla
.a98f					L10053_END:
.a98f					L10054:
>a98f	06					.byte L10054_END-L10054-1
.a990	38		sec			sec
.a991	e5 63		sbc $63			sbc  $63
.a993	b0 01		bcs $a996		bcs  *+3
.a995	ca		dex			dex
.a996					L10054_END:
.a996					L10055:
>a996	0b					.byte L10055_END-L10055-1
.a997	38		sec			sec
.a998	ed 63 73	sbc $7363		sbc  $7363
.a99b	48		pha			pha
.a99c	8a		txa			txa
.a99d	ed 83 73	sbc $7383		sbc  $7383
.a9a0	aa		tax			tax
.a9a1	68		pla			pla
.a9a2					L10055_END:
.a9a2					L10056:
>a9a2	09					.byte L10056_END-L10056-1
.a9a3	38		sec			sec
.a9a4	e5 63		sbc $63			sbc  $63
.a9a6	48		pha			pha
.a9a7	8a		txa			txa
.a9a8	e5 83		sbc $83			sbc  $83
.a9aa	aa		tax			tax
.a9ab	68		pla			pla
.a9ac					L10056_END:
.a9ac					L10057:
>a9ac	07					.byte L10057_END-L10057-1
.a9ad	38		sec			sec
.a9ae	ed 63 73	sbc $7363		sbc  $7363
.a9b1	b0 01		bcs $a9b4		bcs  *+3
.a9b3	ca		dex			dex
.a9b4					L10057_END:
.a9b4					L10058:
>a9b4	06					.byte L10058_END-L10058-1
.a9b5	38		sec			sec
.a9b6	e9 63		sbc #$63		sbc  #$63
.a9b8	b0 01		bcs $a9bb		bcs  *+3
.a9ba	ca		dex			dex
.a9bb					L10058_END:
.a9bb					L10059:
>a9bb	09					.byte L10059_END-L10059-1
.a9bc	18		clc			clc
.a9bd	69 63		adc #$63		adc  #$63
.a9bf	48		pha			pha
.a9c0	8a		txa			txa
.a9c1	69 73		adc #$73		adc  #$73
.a9c3	aa		tax			tax
.a9c4	68		pla			pla
.a9c5					L10059_END:
.a9c5					L10060:
>a9c5	0b					.byte L10060_END-L10060-1
.a9c6	18		clc			clc
.a9c7	71 63		adc ($63),y		adc  ($63),y
.a9c9	48		pha			pha
.a9ca	8a		txa			txa
.a9cb	c8		iny			iny
.a9cc	71 63		adc ($63),y		adc  ($63),y
.a9ce	88		dey			dey
.a9cf	aa		tax			tax
.a9d0	68		pla			pla
.a9d1					L10060_END:
.a9d1					L10061:
>a9d1	06					.byte L10061_END-L10061-1
.a9d2	18		clc			clc
.a9d3	65 63		adc $63			adc  $63
.a9d5	90 01		bcc $a9d8		bcc  *+3
.a9d7	e8		inx			inx
.a9d8					L10061_END:
.a9d8					L10062:
>a9d8	0b					.byte L10062_END-L10062-1
.a9d9	18		clc			clc
.a9da	6d 63 73	adc $7363		adc  $7363
.a9dd	48		pha			pha
.a9de	8a		txa			txa
.a9df	6d 83 73	adc $7383		adc  $7383
.a9e2	aa		tax			tax
.a9e3	68		pla			pla
.a9e4					L10062_END:
.a9e4					L10063:
>a9e4	09					.byte L10063_END-L10063-1
.a9e5	18		clc			clc
.a9e6	65 63		adc $63			adc  $63
.a9e8	48		pha			pha
.a9e9	8a		txa			txa
.a9ea	65 83		adc $83			adc  $83
.a9ec	aa		tax			tax
.a9ed	68		pla			pla
.a9ee					L10063_END:
.a9ee					L10064:
>a9ee	07					.byte L10064_END-L10064-1
.a9ef	18		clc			clc
.a9f0	6d 63 73	adc $7363		adc  $7363
.a9f3	90 01		bcc $a9f6		bcc  *+3
.a9f5	e8		inx			inx
.a9f6					L10064_END:
.a9f6					L10065:
>a9f6	06					.byte L10065_END-L10065-1
.a9f7	18		clc			clc
.a9f8	69 63		adc #$63		adc  #$63
.a9fa	90 01		bcc $a9fd		bcc  *+3
.a9fc	e8		inx			inx
.a9fd					L10065_END:
.a9fd					L10066:
>a9fd	08					.byte L10066_END-L10066-1
.a9fe	29 63		and #$63		and  #$63
.aa00	48		pha			pha
.aa01	8a		txa			txa
.aa02	29 73		and #$73		and  #$73
.aa04	aa		tax			tax
.aa05	68		pla			pla
.aa06					L10066_END:
.aa06					L10067:
>aa06	0a					.byte L10067_END-L10067-1
.aa07	31 63		and ($63),y		and  ($63),y
.aa09	48		pha			pha
.aa0a	8a		txa			txa
.aa0b	c8		iny			iny
.aa0c	31 63		and ($63),y		and  ($63),y
.aa0e	88		dey			dey
.aa0f	aa		tax			tax
.aa10	68		pla			pla
.aa11					L10067_END:
.aa11					L10068:
>aa11	04					.byte L10068_END-L10068-1
.aa12	25 63		and $63			and  $63
.aa14	a2 00		ldx #$00		ldx  #0
.aa16					L10068_END:
.aa16					L10069:
>aa16	0a					.byte L10069_END-L10069-1
.aa17	2d 63 73	and $7363		and  $7363
.aa1a	48		pha			pha
.aa1b	8a		txa			txa
.aa1c	2d 83 73	and $7383		and  $7383
.aa1f	aa		tax			tax
.aa20	68		pla			pla
.aa21					L10069_END:
.aa21					L10070:
>aa21	08					.byte L10070_END-L10070-1
.aa22	25 63		and $63			and  $63
.aa24	48		pha			pha
.aa25	8a		txa			txa
.aa26	25 83		and $83			and  $83
.aa28	aa		tax			tax
.aa29	68		pla			pla
.aa2a					L10070_END:
.aa2a					L10071:
>aa2a	05					.byte L10071_END-L10071-1
.aa2b	2d 63 73	and $7363		and  $7363
.aa2e	a2 00		ldx #$00		ldx  #0
.aa30					L10071_END:
.aa30					L10072:
>aa30	04					.byte L10072_END-L10072-1
.aa31	29 63		and #$63		and  #$63
.aa33	a2 00		ldx #$00		ldx  #0
.aa35					L10072_END:
.aa35					L10073:
>aa35	02					.byte L10073_END-L10073-1
>aa36	a3 05					.byte $a3,$05
.aa38					L10073_END:
.aa38					L10074:
>aa38	02					.byte L10074_END-L10074-1
>aa39	a3 06					.byte $a3,$06
.aa3b					L10074_END:
.aa3b					L10075:
>aa3b	02					.byte L10075_END-L10075-1
>aa3c	a3 07					.byte $a3,$07
.aa3e					L10075_END:
.aa3e					L10076:
>aa3e	02					.byte L10076_END-L10076-1
>aa3f	a3 08					.byte $a3,$08
.aa41					L10076_END:
.aa41					L10077:
>aa41	02					.byte L10077_END-L10077-1
>aa42	a3 09					.byte $a3,$09
.aa44					L10077_END:
.aa44					L10078:
>aa44	02					.byte L10078_END-L10078-1
>aa45	a3 0a					.byte $a3,$0a
.aa47					L10078_END:
.aa47					L10079:
>aa47	02					.byte L10079_END-L10079-1
>aa48	a3 0b					.byte $a3,$0b
.aa4a					L10079_END:
.aa4a					L10080:
>aa4a	02					.byte L10080_END-L10080-1
.aa4b	51 63		eor ($63),y		eor  ($63),y
.aa4d					L10080_END:
.aa4d					L10081:
>aa4d	02					.byte L10081_END-L10081-1
.aa4e	45 63		eor $63			eor  $63
.aa50					L10081_END:
.aa50					L10082:
>aa50	03					.byte L10082_END-L10082-1
.aa51	4d 63 73	eor $7363		eor  $7363
.aa54					L10082_END:
.aa54					L10083:
>aa54	02					.byte L10083_END-L10083-1
.aa55	49 63		eor #$63		eor  #$63
.aa57					L10083_END:
.aa57					L10084:
>aa57	01					.byte L10084_END-L10084-1
.aa58	48		pha			pha
.aa59					L10084_END:
.aa59					L10085:
>aa59	02					.byte L10085_END-L10085-1
.aa5a	b1 63		lda ($63),y		lda  ($63),y
.aa5c					L10085_END:
.aa5c					L10086:
>aa5c	02					.byte L10086_END-L10086-1
.aa5d	a5 63		lda $63			lda  $63
.aa5f					L10086_END:
.aa5f					L10087:
>aa5f	03					.byte L10087_END-L10087-1
.aa60	ad 63 73	lda $7363		lda  $7363
.aa63					L10087_END:
.aa63					L10088:
>aa63	02					.byte L10088_END-L10088-1
.aa64	a9 63		lda #$63		lda  #$63
.aa66					L10088_END:
.aa66					L10089:
>aa66	01					.byte L10089_END-L10089-1
.aa67	98		tya			tya
.aa68					L10089_END:
.aa68					L10090:
>aa68	00					.byte L10090_END-L10090-1
.aa69					L10090_END:
.aa69					L10091:
>aa69	02					.byte L10091_END-L10091-1
.aa6a	11 63		ora ($63),y		ora  ($63),y
.aa6c					L10091_END:
.aa6c					L10092:
>aa6c	02					.byte L10092_END-L10092-1
.aa6d	05 63		ora $63			ora  $63
.aa6f					L10092_END:
.aa6f					L10093:
>aa6f	03					.byte L10093_END-L10093-1
.aa70	0d 63 73	ora $7363		ora  $7363
.aa73					L10093_END:
.aa73					L10094:
>aa73	02					.byte L10094_END-L10094-1
.aa74	09 63		ora #$63		ora  #$63
.aa76					L10094_END:
.aa76					L10095:
>aa76	02					.byte L10095_END-L10095-1
>aa77	a3 0c					.byte $a3,$0c
.aa79					L10095_END:
.aa79					L10096:
>aa79	03					.byte L10096_END-L10096-1
.aa7a	38		sec			sec
.aa7b	f1 63		sbc ($63),y		sbc  ($63),y
.aa7d					L10096_END:
.aa7d					L10097:
>aa7d	03					.byte L10097_END-L10097-1
.aa7e	38		sec			sec
.aa7f	e5 63		sbc $63			sbc  $63
.aa81					L10097_END:
.aa81					L10098:
>aa81	04					.byte L10098_END-L10098-1
.aa82	38		sec			sec
.aa83	ed 63 73	sbc $7363		sbc  $7363
.aa86					L10098_END:
.aa86					L10099:
>aa86	03					.byte L10099_END-L10099-1
.aa87	38		sec			sec
.aa88	e9 63		sbc #$63		sbc  #$63
.aa8a					L10099_END:
.aa8a					L10100:
>aa8a	03					.byte L10100_END-L10100-1
.aa8b	18		clc			clc
.aa8c	71 63		adc ($63),y		adc  ($63),y
.aa8e					L10100_END:
.aa8e					L10101:
>aa8e	03					.byte L10101_END-L10101-1
.aa8f	18		clc			clc
.aa90	65 63		adc $63			adc  $63
.aa92					L10101_END:
.aa92					L10102:
>aa92	04					.byte L10102_END-L10102-1
.aa93	18		clc			clc
.aa94	6d 63 73	adc $7363		adc  $7363
.aa97					L10102_END:
.aa97					L10103:
>aa97	03					.byte L10103_END-L10103-1
.aa98	18		clc			clc
.aa99	69 63		adc #$63		adc  #$63
.aa9b					L10103_END:
.aa9b					L10104:
>aa9b	02					.byte L10104_END-L10104-1
.aa9c	31 63		and ($63),y		and  ($63),y
.aa9e					L10104_END:
.aa9e					L10105:
>aa9e	02					.byte L10105_END-L10105-1
.aa9f	25 63		and $63			and  $63
.aaa1					L10105_END:
.aaa1					L10106:
>aaa1	03					.byte L10106_END-L10106-1
.aaa2	2d 63 73	and $7363		and  $7363
.aaa5					L10106_END:
.aaa5					L10107:
>aaa5	02					.byte L10107_END-L10107-1
.aaa6	29 63		and #$63		and  #$63
.aaa8					L10107_END:
.aaa8					L10108:
>aaa8	06					.byte L10108_END-L10108-1
.aaa9	48		pha			pha
.aaaa	8a		txa			txa
.aaab	4a		lsr a			lsr  a
.aaac	aa		tax			tax
.aaad	68		pla			pla
.aaae	6a		ror a			ror  a
.aaaf					L10108_END:
.aaaf					L10109:
>aaaf	01					.byte L10109_END-L10109-1
.aab0	4a		lsr a			lsr  a
.aab1					L10109_END:
.aab1					L10110:
>aab1	06					.byte L10110_END-L10110-1
.aab2	0a		asl a			asl  a
.aab3	48		pha			pha
.aab4	8a		txa			txa
.aab5	2a		rol a			rol  a
.aab6	aa		tax			tax
.aab7	68		pla			pla
.aab8					L10110_END:
.aab8					L10111:
>aab8	01					.byte L10111_END-L10111-1
.aab9	0a		asl a			asl  a
.aaba					L10111_END:
.aaba					L10112:
>aaba	0b					.byte L10112_END-L10112-1
.aabb	8a		txa			txa
.aabc	49 ff		eor #$ff		eor  #$ff
.aabe	aa		tax			tax
.aabf	68		pla			pla
.aac0	49 ff		eor #$ff		eor  #$ff
.aac2	1a		inc a			inc  a
.aac3	d0 01		bne $aac6		bne  *+3
.aac5	e8		inx			inx
.aac6					L10112_END:
.aac6					L10113:
>aac6	03					.byte L10113_END-L10113-1
.aac7	49 ff		eor #$ff		eor  #$ff
.aac9	1a		inc a			inc  a
.aaca					L10113_END:
.aaca					L10114:
>aaca	01					.byte L10114_END-L10114-1
.aacb	88		dey			dey
.aacc					L10114_END:
.aacc					L10115:
>aacc	06					.byte L10115_END-L10115-1
.aacd	c9 00		cmp #$00		cmp  #0
.aacf	d0 01		bne $aad2		bne  *+3
.aad1	ca		dex			dex
.aad2	3a		dec a			dec  a
.aad3					L10115_END:
.aad3					L10116:
>aad3	01					.byte L10116_END-L10116-1
.aad4	3a		dec a			dec  a
.aad5					L10116_END:
.aad5					L10117:
>aad5	01					.byte L10117_END-L10117-1
.aad6	c8		iny			iny
.aad7					L10117_END:
.aad7					L10118:
>aad7	04					.byte L10118_END-L10118-1
.aad8	1a		inc a			inc  a
.aad9	d0 01		bne $aadc		bne  *+3
.aadb	e8		inx			inx
.aadc					L10118_END:
.aadc					L10119:
>aadc	01					.byte L10119_END-L10119-1
.aadd	1a		inc a			inc  a
.aade					L10119_END:
.aade					ExecutableVectorTable:
>aade	20 a5					.word Action_call                      ; 0
>aae0	59 a6					.word Action_wordvar                   ; 1
>aae2	09 a6					.word Action_until                     ; 2
>aae4	00 a6					.word Action_repeat                    ; 3
>aae6	c8 a6					.word Action_dictionarycrunch          ; 4
>aae8	db a4					.word Action_procedure_def             ; 5
>aaea	30 a6					.word Action_next                      ; 6
>aaec	9b a5					.word Action_if                        ; 7
>aaee	10 a5					.word Action_endproc                   ; 8
>aaf0	d2 a5					.word Action_endif                     ; 9
>aaf2	b0 a5					.word Action_else                      ; 10
>aaf4	55 a6					.word Action_bytevar                   ; 11
>aaf6	1d a6					.word Action_afor                      ; 12
.aaf8					SystemDictionary:
>aaf8	0c					.byte	12
>aaf9	4d					.byte	'M'
>aafa	7b a8					.word	L10000
>aafc	00					.byte	0
>aafd	06					.byte	6
>aafe	f3 db d9 dd bd d2			.byte	$f3,$db,$d9,$dd,$bd,$d2
>ab04	0c					.byte	12
>ab05	4d					.byte	'M'
>ab06	85 a8					.word	L10001
>ab08	00					.byte	0
>ab09	06					.byte	6
>ab0a	f3 db d9 dd bd c1			.byte	$f3,$db,$d9,$dd,$bd,$c1
>ab10	09					.byte	9
>ab11	4d					.byte	'M'
>ab12	88 a8					.word	L10002
>ab14	00					.byte	0
>ab15	03					.byte	3
>ab16	f3 bd d9				.byte	$f3,$bd,$d9
>ab19	09					.byte	9
>ab1a	4d					.byte	'M'
>ab1b	8b a8					.word	L10003
>ab1d	00					.byte	0
>ab1e	03					.byte	3
>ab1f	f3 bd d2				.byte	$f3,$bd,$d2
>ab22	09					.byte	9
>ab23	4d					.byte	'M'
>ab24	8e a8					.word	L10004
>ab26	00					.byte	0
>ab27	03					.byte	3
>ab28	f3 bd c1				.byte	$f3,$bd,$c1
>ab2b	07					.byte	7
>ab2c	4d					.byte	'M'
>ab2d	91 a8					.word	L10005
>ab2f	00					.byte	0
>ab30	01					.byte	1
>ab31	f0					.byte	$f0
>ab32	09					.byte	9
>ab33	4d					.byte	'M'
>ab34	94 a8					.word	L10006
>ab36	00					.byte	0
>ab37	03					.byte	3
>ab38	ec bd d2				.byte	$ec,$bd,$d2
>ab3b	09					.byte	9
>ab3c	4d					.byte	'M'
>ab3d	9b a8					.word	L10007
>ab3f	00					.byte	0
>ab40	03					.byte	3
>ab41	e9 bd d2				.byte	$e9,$bd,$d2
>ab44	09					.byte	9
>ab45	4d					.byte	'M'
>ab46	a0 a8					.word	L10008
>ab48	00					.byte	0
>ab49	03					.byte	3
>ab4a	e3 bd d9				.byte	$e3,$bd,$d9
>ab4d	09					.byte	9
>ab4e	4d					.byte	'M'
>ab4f	a4 a8					.word	L10009
>ab51	00					.byte	0
>ab52	03					.byte	3
>ab53	e3 bd d2				.byte	$e3,$bd,$d2
>ab56	09					.byte	9
>ab57	4d					.byte	'M'
>ab58	a8 a8					.word	L10010
>ab5a	00					.byte	0
>ab5b	03					.byte	3
>ab5c	e3 bd c1				.byte	$e3,$bd,$c1
>ab5f	0b					.byte	11
>ab60	4d					.byte	'M'
>ab61	ac a8					.word	L10011
>ab63	00					.byte	0
>ab64	05					.byte	5
>ab65	de 52 50 48 c1				.byte	$de,$52,$50,$48,$c1
>ab6a	08					.byte	8
>ab6b	4d					.byte	'M'
>ab6c	b4 a8					.word	L10012
>ab6e	00					.byte	0
>ab6f	02					.byte	2
>ab70	de c1					.byte	$de,$c1
>ab72	09					.byte	9
>ab73	4d					.byte	'M'
>ab74	b7 a8					.word	L10013
>ab76	00					.byte	0
>ab77	03					.byte	3
>ab78	d9 be d3				.byte	$d9,$be,$d3
>ab7b	09					.byte	9
>ab7c	4d					.byte	'M'
>ab7d	b9 a8					.word	L10014
>ab7f	00					.byte	0
>ab80	03					.byte	3
>ab81	d9 bd f3				.byte	$d9,$bd,$f3
>ab84	09					.byte	9
>ab85	4d					.byte	'M'
>ab86	bc a8					.word	L10015
>ab88	00					.byte	0
>ab89	03					.byte	3
>ab8a	d9 bd e3				.byte	$d9,$bd,$e3
>ab8d	09					.byte	9
>ab8e	4d					.byte	'M'
>ab8f	c0 a8					.word	L10016
>ab91	00					.byte	0
>ab92	03					.byte	3
>ab93	d9 bd e2				.byte	$d9,$bd,$e2
>ab96	09					.byte	9
>ab97	4d					.byte	'M'
>ab98	c3 a8					.word	L10017
>ab9a	00					.byte	0
>ab9b	03					.byte	3
>ab9c	d9 bd d2				.byte	$d9,$bd,$d2
>ab9f	09					.byte	9
>aba0	4d					.byte	'M'
>aba1	c5 a8					.word	L10018
>aba3	00					.byte	0
>aba4	03					.byte	3
>aba5	d9 bd c1				.byte	$d9,$bd,$c1
>aba8	0a					.byte	10
>aba9	4d					.byte	'M'
>abaa	c7 a8					.word	L10019
>abac	00					.byte	0
>abad	04					.byte	4
>abae	57 4f 52 c4				.byte	$57,$4f,$52,$c4
>abb2	0b					.byte	11
>abb3	4d					.byte	'M'
>abb4	ca a8					.word	L10020
>abb6	00					.byte	0
>abb7	05					.byte	5
>abb8	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
>abbd	09					.byte	9
>abbe	4d					.byte	'M'
>abbf	cd a8					.word	L10021
>abc1	00					.byte	0
>abc2	03					.byte	3
>abc3	d3 be d9				.byte	$d3,$be,$d9
>abc6	0b					.byte	11
>abc7	4d					.byte	'M'
>abc8	cf a8					.word	L10022
>abca	00					.byte	0
>abcb	05					.byte	5
>abcc	d3 be 52 41 d9				.byte	$d3,$be,$52,$41,$d9
>abd1	09					.byte	9
>abd2	4d					.byte	'M'
>abd3	d3 a8					.word	L10023
>abd5	00					.byte	0
>abd6	03					.byte	3
>abd7	d3 be d2				.byte	$d3,$be,$d2
>abda	09					.byte	9
>abdb	4d					.byte	'M'
>abdc	d6 a8					.word	L10024
>abde	00					.byte	0
>abdf	03					.byte	3
>abe0	d3 be c1				.byte	$d3,$be,$c1
>abe3	09					.byte	9
>abe4	4d					.byte	'M'
>abe5	d8 a8					.word	L10025
>abe7	00					.byte	0
>abe8	03					.byte	3
>abe9	52 77 f7				.byte	$52,$77,$f7
>abec	0c					.byte	12
>abed	4d					.byte	'M'
>abee	e1 a8					.word	L10026
>abf0	00					.byte	0
>abf1	06					.byte	6
>abf2	52 73 f3 db d9 dd			.byte	$52,$73,$f3,$db,$d9,$dd
>abf8	09					.byte	9
>abf9	4d					.byte	'M'
>abfa	ec a8					.word	L10027
>abfc	00					.byte	0
>abfd	03					.byte	3
>abfe	52 73 f3				.byte	$52,$73,$f3
>ac01	09					.byte	9
>ac02	4d					.byte	'M'
>ac03	ef a8					.word	L10028
>ac05	00					.byte	0
>ac06	03					.byte	3
>ac07	52 6c ec				.byte	$52,$6c,$ec
>ac0a	09					.byte	9
>ac0b	4d					.byte	'M'
>ac0c	fa a8					.word	L10029
>ac0e	00					.byte	0
>ac0f	03					.byte	3
>ac10	52 69 e9				.byte	$52,$69,$e9
>ac13	09					.byte	9
>ac14	4d					.byte	'M'
>ac15	03 a9					.word	L10030
>ac17	00					.byte	0
>ac18	03					.byte	3
>ac19	52 63 e3				.byte	$52,$63,$e3
>ac1c	09					.byte	9
>ac1d	4d					.byte	'M'
>ac1e	07 a9					.word	L10031
>ac20	00					.byte	0
>ac21	03					.byte	3
>ac22	52 62 e2				.byte	$52,$62,$e2
>ac25	0c					.byte	12
>ac26	4d					.byte	'M'
>ac27	0a a9					.word	L10032
>ac29	00					.byte	0
>ac2a	06					.byte	6
>ac2b	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
>ac31	13					.byte	19
>ac32	4d					.byte	'M'
>ac33	0d a9					.word	L10033
>ac35	00					.byte	0
>ac36	0d					.byte	13
>ac37	52 45 4d 4f 56 45 2e 4c			.byte	$52,$45,$4d,$4f,$56,$45,$2e,$4c,$4f,$43,$41,$4c,$d3
>ac3f	4f 43 41 4c d3
>ac44	0b					.byte	11
>ac45	4d					.byte	'M'
>ac46	10 a9					.word	L10034
>ac48	00					.byte	0
>ac49	05					.byte	5
>ac4a	52 41 d9 be d3				.byte	$52,$41,$d9,$be,$d3
>ac4f	09					.byte	9
>ac50	4d					.byte	'M'
>ac51	14 a9					.word	L10035
>ac53	00					.byte	0
>ac54	03					.byte	3
>ac55	d2 be d3				.byte	$d2,$be,$d3
>ac58	09					.byte	9
>ac59	4d					.byte	'M'
>ac5a	17 a9					.word	L10036
>ac5c	00					.byte	0
>ac5d	03					.byte	3
>ac5e	d2 bd f7				.byte	$d2,$bd,$f7
>ac61	0c					.byte	12
>ac62	4d					.byte	'M'
>ac63	1c a9					.word	L10037
>ac65	00					.byte	0
>ac66	06					.byte	6
>ac67	d2 bd f3 db d9 dd			.byte	$d2,$bd,$f3,$db,$d9,$dd
>ac6d	09					.byte	9
>ac6e	4d					.byte	'M'
>ac6f	24 a9					.word	L10038
>ac71	00					.byte	0
>ac72	03					.byte	3
>ac73	d2 bd f3				.byte	$d2,$bd,$f3
>ac76	09					.byte	9
>ac77	4d					.byte	'M'
>ac78	29 a9					.word	L10039
>ac7a	00					.byte	0
>ac7b	03					.byte	3
>ac7c	d2 bd ec				.byte	$d2,$bd,$ec
>ac7f	09					.byte	9
>ac80	4d					.byte	'M'
>ac81	30 a9					.word	L10040
>ac83	00					.byte	0
>ac84	03					.byte	3
>ac85	d2 bd e9				.byte	$d2,$bd,$e9
>ac88	09					.byte	9
>ac89	4d					.byte	'M'
>ac8a	35 a9					.word	L10041
>ac8c	00					.byte	0
>ac8d	03					.byte	3
>ac8e	d2 bd e3				.byte	$d2,$bd,$e3
>ac91	09					.byte	9
>ac92	4d					.byte	'M'
>ac93	3b a9					.word	L10042
>ac95	00					.byte	0
>ac96	03					.byte	3
>ac97	d2 bd e2				.byte	$d2,$bd,$e2
>ac9a	09					.byte	9
>ac9b	4d					.byte	'M'
>ac9c	40 a9					.word	L10043
>ac9e	00					.byte	0
>ac9f	03					.byte	3
>aca0	d2 bd d9				.byte	$d2,$bd,$d9
>aca3	09					.byte	9
>aca4	4d					.byte	'M'
>aca5	44 a9					.word	L10044
>aca7	00					.byte	0
>aca8	03					.byte	3
>aca9	d2 bd c1				.byte	$d2,$bd,$c1
>acac	09					.byte	9
>acad	4d					.byte	'M'
>acae	47 a9					.word	L10045
>acb0	00					.byte	0
>acb1	03					.byte	3
>acb2	d2 ba f7				.byte	$d2,$ba,$f7
>acb5	0c					.byte	12
>acb6	4d					.byte	'M'
>acb7	50 a9					.word	L10046
>acb9	00					.byte	0
>acba	06					.byte	6
>acbb	d2 ba f3 db d9 dd			.byte	$d2,$ba,$f3,$db,$d9,$dd
>acc1	09					.byte	9
>acc2	4d					.byte	'M'
>acc3	5b a9					.word	L10047
>acc5	00					.byte	0
>acc6	03					.byte	3
>acc7	d2 ba f3				.byte	$d2,$ba,$f3
>acca	09					.byte	9
>accb	4d					.byte	'M'
>accc	5e a9					.word	L10048
>acce	00					.byte	0
>accf	03					.byte	3
>acd0	d2 ba ec				.byte	$d2,$ba,$ec
>acd3	09					.byte	9
>acd4	4d					.byte	'M'
>acd5	69 a9					.word	L10049
>acd7	00					.byte	0
>acd8	03					.byte	3
>acd9	d2 ba e9				.byte	$d2,$ba,$e9
>acdc	09					.byte	9
>acdd	4d					.byte	'M'
>acde	72 a9					.word	L10050
>ace0	00					.byte	0
>ace1	03					.byte	3
>ace2	d2 ba e3				.byte	$d2,$ba,$e3
>ace5	09					.byte	9
>ace6	4d					.byte	'M'
>ace7	76 a9					.word	L10051
>ace9	00					.byte	0
>acea	03					.byte	3
>aceb	d2 ba e2				.byte	$d2,$ba,$e2
>acee	09					.byte	9
>acef	4d					.byte	'M'
>acf0	79 a9					.word	L10052
>acf2	00					.byte	0
>acf3	03					.byte	3
>acf4	d2 ad f7				.byte	$d2,$ad,$f7
>acf7	0c					.byte	12
>acf8	4d					.byte	'M'
>acf9	83 a9					.word	L10053
>acfb	00					.byte	0
>acfc	06					.byte	6
>acfd	d2 ad f3 db d9 dd			.byte	$d2,$ad,$f3,$db,$d9,$dd
>ad03	09					.byte	9
>ad04	4d					.byte	'M'
>ad05	8f a9					.word	L10054
>ad07	00					.byte	0
>ad08	03					.byte	3
>ad09	d2 ad f3				.byte	$d2,$ad,$f3
>ad0c	09					.byte	9
>ad0d	4d					.byte	'M'
>ad0e	96 a9					.word	L10055
>ad10	00					.byte	0
>ad11	03					.byte	3
>ad12	d2 ad ec				.byte	$d2,$ad,$ec
>ad15	09					.byte	9
>ad16	4d					.byte	'M'
>ad17	a2 a9					.word	L10056
>ad19	00					.byte	0
>ad1a	03					.byte	3
>ad1b	d2 ad e9				.byte	$d2,$ad,$e9
>ad1e	09					.byte	9
>ad1f	4d					.byte	'M'
>ad20	ac a9					.word	L10057
>ad22	00					.byte	0
>ad23	03					.byte	3
>ad24	d2 ad e3				.byte	$d2,$ad,$e3
>ad27	09					.byte	9
>ad28	4d					.byte	'M'
>ad29	b4 a9					.word	L10058
>ad2b	00					.byte	0
>ad2c	03					.byte	3
>ad2d	d2 ad e2				.byte	$d2,$ad,$e2
>ad30	09					.byte	9
>ad31	4d					.byte	'M'
>ad32	bb a9					.word	L10059
>ad34	00					.byte	0
>ad35	03					.byte	3
>ad36	d2 ab f7				.byte	$d2,$ab,$f7
>ad39	0c					.byte	12
>ad3a	4d					.byte	'M'
>ad3b	c5 a9					.word	L10060
>ad3d	00					.byte	0
>ad3e	06					.byte	6
>ad3f	d2 ab f3 db d9 dd			.byte	$d2,$ab,$f3,$db,$d9,$dd
>ad45	09					.byte	9
>ad46	4d					.byte	'M'
>ad47	d1 a9					.word	L10061
>ad49	00					.byte	0
>ad4a	03					.byte	3
>ad4b	d2 ab f3				.byte	$d2,$ab,$f3
>ad4e	09					.byte	9
>ad4f	4d					.byte	'M'
>ad50	d8 a9					.word	L10062
>ad52	00					.byte	0
>ad53	03					.byte	3
>ad54	d2 ab ec				.byte	$d2,$ab,$ec
>ad57	09					.byte	9
>ad58	4d					.byte	'M'
>ad59	e4 a9					.word	L10063
>ad5b	00					.byte	0
>ad5c	03					.byte	3
>ad5d	d2 ab e9				.byte	$d2,$ab,$e9
>ad60	09					.byte	9
>ad61	4d					.byte	'M'
>ad62	ee a9					.word	L10064
>ad64	00					.byte	0
>ad65	03					.byte	3
>ad66	d2 ab e3				.byte	$d2,$ab,$e3
>ad69	09					.byte	9
>ad6a	4d					.byte	'M'
>ad6b	f6 a9					.word	L10065
>ad6d	00					.byte	0
>ad6e	03					.byte	3
>ad6f	d2 ab e2				.byte	$d2,$ab,$e2
>ad72	09					.byte	9
>ad73	4d					.byte	'M'
>ad74	fd a9					.word	L10066
>ad76	00					.byte	0
>ad77	03					.byte	3
>ad78	d2 a6 f7				.byte	$d2,$a6,$f7
>ad7b	0c					.byte	12
>ad7c	4d					.byte	'M'
>ad7d	06 aa					.word	L10067
>ad7f	00					.byte	0
>ad80	06					.byte	6
>ad81	d2 a6 f3 db d9 dd			.byte	$d2,$a6,$f3,$db,$d9,$dd
>ad87	09					.byte	9
>ad88	4d					.byte	'M'
>ad89	11 aa					.word	L10068
>ad8b	00					.byte	0
>ad8c	03					.byte	3
>ad8d	d2 a6 f3				.byte	$d2,$a6,$f3
>ad90	09					.byte	9
>ad91	4d					.byte	'M'
>ad92	16 aa					.word	L10069
>ad94	00					.byte	0
>ad95	03					.byte	3
>ad96	d2 a6 ec				.byte	$d2,$a6,$ec
>ad99	09					.byte	9
>ad9a	4d					.byte	'M'
>ad9b	21 aa					.word	L10070
>ad9d	00					.byte	0
>ad9e	03					.byte	3
>ad9f	d2 a6 e9				.byte	$d2,$a6,$e9
>ada2	09					.byte	9
>ada3	4d					.byte	'M'
>ada4	2a aa					.word	L10071
>ada6	00					.byte	0
>ada7	03					.byte	3
>ada8	d2 a6 e3				.byte	$d2,$a6,$e3
>adab	09					.byte	9
>adac	4d					.byte	'M'
>adad	30 aa					.word	L10072
>adaf	00					.byte	0
>adb0	03					.byte	3
>adb1	d2 a6 e2				.byte	$d2,$a6,$e2
>adb4	0a					.byte	10
>adb5	4d					.byte	'M'
>adb6	35 aa					.word	L10073
>adb8	00					.byte	0
>adb9	04					.byte	4
>adba	50 52 4f c3				.byte	$50,$52,$4f,$c3
>adbe	0a					.byte	10
>adbf	4d					.byte	'M'
>adc0	38 aa					.word	L10074
>adc2	00					.byte	0
>adc3	04					.byte	4
>adc4	4e 45 58 d4				.byte	$4e,$45,$58,$d4
>adc8	08					.byte	8
>adc9	4d					.byte	'M'
>adca	3b aa					.word	L10075
>adcc	00					.byte	0
>adcd	02					.byte	2
>adce	49 c6					.byte	$49,$c6
>add0	0d					.byte	13
>add1	4d					.byte	'M'
>add2	3e aa					.word	L10076
>add4	00					.byte	0
>add5	07					.byte	7
>add6	45 4e 44 50 52 4f c3			.byte	$45,$4e,$44,$50,$52,$4f,$c3
>addd	0b					.byte	11
>adde	4d					.byte	'M'
>addf	41 aa					.word	L10077
>ade1	00					.byte	0
>ade2	05					.byte	5
>ade3	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
>ade8	0a					.byte	10
>ade9	4d					.byte	'M'
>adea	44 aa					.word	L10078
>adec	00					.byte	0
>aded	04					.byte	4
>adee	45 4c 53 c5				.byte	$45,$4c,$53,$c5
>adf2	0a					.byte	10
>adf3	4d					.byte	'M'
>adf4	47 aa					.word	L10079
>adf6	00					.byte	0
>adf7	04					.byte	4
>adf8	42 59 54 c5				.byte	$42,$59,$54,$c5
>adfc	0c					.byte	12
>adfd	4d					.byte	'M'
>adfe	4a aa					.word	L10080
>ae00	00					.byte	0
>ae01	06					.byte	6
>ae02	41 73 f3 db d9 dd			.byte	$41,$73,$f3,$db,$d9,$dd
>ae08	09					.byte	9
>ae09	4d					.byte	'M'
>ae0a	4d aa					.word	L10081
>ae0c	00					.byte	0
>ae0d	03					.byte	3
>ae0e	41 73 f3				.byte	$41,$73,$f3
>ae11	09					.byte	9
>ae12	4d					.byte	'M'
>ae13	50 aa					.word	L10082
>ae15	00					.byte	0
>ae16	03					.byte	3
>ae17	41 63 e3				.byte	$41,$63,$e3
>ae1a	09					.byte	9
>ae1b	4d					.byte	'M'
>ae1c	54 aa					.word	L10083
>ae1e	00					.byte	0
>ae1f	03					.byte	3
>ae20	41 62 e2				.byte	$41,$62,$e2
>ae23	09					.byte	9
>ae24	4d					.byte	'M'
>ae25	57 aa					.word	L10084
>ae27	00					.byte	0
>ae28	03					.byte	3
>ae29	c1 be d3				.byte	$c1,$be,$d3
>ae2c	0c					.byte	12
>ae2d	4d					.byte	'M'
>ae2e	59 aa					.word	L10085
>ae30	00					.byte	0
>ae31	06					.byte	6
>ae32	c1 bd f3 db d9 dd			.byte	$c1,$bd,$f3,$db,$d9,$dd
>ae38	09					.byte	9
>ae39	4d					.byte	'M'
>ae3a	5c aa					.word	L10086
>ae3c	00					.byte	0
>ae3d	03					.byte	3
>ae3e	c1 bd f3				.byte	$c1,$bd,$f3
>ae41	09					.byte	9
>ae42	4d					.byte	'M'
>ae43	5f aa					.word	L10087
>ae45	00					.byte	0
>ae46	03					.byte	3
>ae47	c1 bd e3				.byte	$c1,$bd,$e3
>ae4a	09					.byte	9
>ae4b	4d					.byte	'M'
>ae4c	63 aa					.word	L10088
>ae4e	00					.byte	0
>ae4f	03					.byte	3
>ae50	c1 bd e2				.byte	$c1,$bd,$e2
>ae53	09					.byte	9
>ae54	4d					.byte	'M'
>ae55	66 aa					.word	L10089
>ae57	00					.byte	0
>ae58	03					.byte	3
>ae59	c1 bd d9				.byte	$c1,$bd,$d9
>ae5c	09					.byte	9
>ae5d	4d					.byte	'M'
>ae5e	68 aa					.word	L10090
>ae60	00					.byte	0
>ae61	03					.byte	3
>ae62	c1 bd d2				.byte	$c1,$bd,$d2
>ae65	0c					.byte	12
>ae66	4d					.byte	'M'
>ae67	69 aa					.word	L10091
>ae69	00					.byte	0
>ae6a	06					.byte	6
>ae6b	c1 ba f3 db d9 dd			.byte	$c1,$ba,$f3,$db,$d9,$dd
>ae71	09					.byte	9
>ae72	4d					.byte	'M'
>ae73	6c aa					.word	L10092
>ae75	00					.byte	0
>ae76	03					.byte	3
>ae77	c1 ba f3				.byte	$c1,$ba,$f3
>ae7a	09					.byte	9
>ae7b	4d					.byte	'M'
>ae7c	6f aa					.word	L10093
>ae7e	00					.byte	0
>ae7f	03					.byte	3
>ae80	c1 ba e3				.byte	$c1,$ba,$e3
>ae83	09					.byte	9
>ae84	4d					.byte	'M'
>ae85	73 aa					.word	L10094
>ae87	00					.byte	0
>ae88	03					.byte	3
>ae89	c1 ba e2				.byte	$c1,$ba,$e2
>ae8c	0b					.byte	11
>ae8d	4d					.byte	'M'
>ae8e	76 aa					.word	L10095
>ae90	00					.byte	0
>ae91	05					.byte	5
>ae92	41 2e 46 4f d2				.byte	$41,$2e,$46,$4f,$d2
>ae97	0c					.byte	12
>ae98	4d					.byte	'M'
>ae99	79 aa					.word	L10096
>ae9b	00					.byte	0
>ae9c	06					.byte	6
>ae9d	c1 ad f3 db d9 dd			.byte	$c1,$ad,$f3,$db,$d9,$dd
>aea3	09					.byte	9
>aea4	4d					.byte	'M'
>aea5	7d aa					.word	L10097
>aea7	00					.byte	0
>aea8	03					.byte	3
>aea9	c1 ad f3				.byte	$c1,$ad,$f3
>aeac	09					.byte	9
>aead	4d					.byte	'M'
>aeae	81 aa					.word	L10098
>aeb0	00					.byte	0
>aeb1	03					.byte	3
>aeb2	c1 ad e3				.byte	$c1,$ad,$e3
>aeb5	09					.byte	9
>aeb6	4d					.byte	'M'
>aeb7	86 aa					.word	L10099
>aeb9	00					.byte	0
>aeba	03					.byte	3
>aebb	c1 ad e2				.byte	$c1,$ad,$e2
>aebe	0c					.byte	12
>aebf	4d					.byte	'M'
>aec0	8a aa					.word	L10100
>aec2	00					.byte	0
>aec3	06					.byte	6
>aec4	c1 ab f3 db d9 dd			.byte	$c1,$ab,$f3,$db,$d9,$dd
>aeca	09					.byte	9
>aecb	4d					.byte	'M'
>aecc	8e aa					.word	L10101
>aece	00					.byte	0
>aecf	03					.byte	3
>aed0	c1 ab f3				.byte	$c1,$ab,$f3
>aed3	09					.byte	9
>aed4	4d					.byte	'M'
>aed5	92 aa					.word	L10102
>aed7	00					.byte	0
>aed8	03					.byte	3
>aed9	c1 ab e3				.byte	$c1,$ab,$e3
>aedc	09					.byte	9
>aedd	4d					.byte	'M'
>aede	97 aa					.word	L10103
>aee0	00					.byte	0
>aee1	03					.byte	3
>aee2	c1 ab e2				.byte	$c1,$ab,$e2
>aee5	0c					.byte	12
>aee6	4d					.byte	'M'
>aee7	9b aa					.word	L10104
>aee9	00					.byte	0
>aeea	06					.byte	6
>aeeb	c1 a6 f3 db d9 dd			.byte	$c1,$a6,$f3,$db,$d9,$dd
>aef1	09					.byte	9
>aef2	4d					.byte	'M'
>aef3	9e aa					.word	L10105
>aef5	00					.byte	0
>aef6	03					.byte	3
>aef7	c1 a6 f3				.byte	$c1,$a6,$f3
>aefa	09					.byte	9
>aefb	4d					.byte	'M'
>aefc	a1 aa					.word	L10106
>aefe	00					.byte	0
>aeff	03					.byte	3
>af00	c1 a6 e3				.byte	$c1,$a6,$e3
>af03	09					.byte	9
>af04	4d					.byte	'M'
>af05	a5 aa					.word	L10107
>af07	00					.byte	0
>af08	03					.byte	3
>af09	c1 a6 e2				.byte	$c1,$a6,$e2
>af0c	09					.byte	9
>af0d	4d					.byte	'M'
>af0e	a8 aa					.word	L10108
>af10	00					.byte	0
>af11	03					.byte	3
>af12	be be d2				.byte	$be,$be,$d2
>af15	09					.byte	9
>af16	4d					.byte	'M'
>af17	af aa					.word	L10109
>af19	00					.byte	0
>af1a	03					.byte	3
>af1b	be be c1				.byte	$be,$be,$c1
>af1e	09					.byte	9
>af1f	4d					.byte	'M'
>af20	b1 aa					.word	L10110
>af22	00					.byte	0
>af23	03					.byte	3
>af24	bc bc d2				.byte	$bc,$bc,$d2
>af27	09					.byte	9
>af28	4d					.byte	'M'
>af29	b8 aa					.word	L10111
>af2b	00					.byte	0
>af2c	03					.byte	3
>af2d	bc bc c1				.byte	$bc,$bc,$c1
>af30	0b					.byte	11
>af31	4d					.byte	'M'
>af32	ba aa					.word	L10112
>af34	00					.byte	0
>af35	05					.byte	5
>af36	ad 52 50 48 c1				.byte	$ad,$52,$50,$48,$c1
>af3b	08					.byte	8
>af3c	4d					.byte	'M'
>af3d	c6 aa					.word	L10113
>af3f	00					.byte	0
>af40	02					.byte	2
>af41	ad c1					.byte	$ad,$c1
>af43	09					.byte	9
>af44	4d					.byte	'M'
>af45	ca aa					.word	L10114
>af47	00					.byte	0
>af48	03					.byte	3
>af49	ad ad d9				.byte	$ad,$ad,$d9
>af4c	09					.byte	9
>af4d	4d					.byte	'M'
>af4e	cc aa					.word	L10115
>af50	00					.byte	0
>af51	03					.byte	3
>af52	ad ad d2				.byte	$ad,$ad,$d2
>af55	09					.byte	9
>af56	4d					.byte	'M'
>af57	d3 aa					.word	L10116
>af59	00					.byte	0
>af5a	03					.byte	3
>af5b	ad ad c1				.byte	$ad,$ad,$c1
>af5e	09					.byte	9
>af5f	4d					.byte	'M'
>af60	d5 aa					.word	L10117
>af62	00					.byte	0
>af63	03					.byte	3
>af64	ab ab d9				.byte	$ab,$ab,$d9
>af67	09					.byte	9
>af68	4d					.byte	'M'
>af69	d7 aa					.word	L10118
>af6b	00					.byte	0
>af6c	03					.byte	3
>af6d	ab ab d2				.byte	$ab,$ab,$d2
>af70	09					.byte	9
>af71	4d					.byte	'M'
>af72	dc aa					.word	L10119
>af74	00					.byte	0
>af75	03					.byte	3
>af76	ab ab c1				.byte	$ab,$ab,$c1
>af79	00					.byte	$00

;******  Return to file: main.asm


;******  Processing file: utility/loadcode.asm

.af7a					LoadBasicCode:
.af7a	a9 a9		lda #$a9			lda 	#(LBCTest) & $FF
.af7c	85 0a		sta $0a				sta 	zTemp0
.af7e	a9 af		lda #$af			lda 	#(LBCTest) >> 8
.af80	85 0b		sta $0b				sta 	zTemp0+1
.af82	a9 01		lda #$01			lda 	#($801) & $FF
.af84	85 0c		sta $0c				sta 	zTemp1
.af86	a9 08		lda #$08			lda 	#($801) >> 8
.af88	85 0d		sta $0d				sta 	zTemp1+1
.af8a					_LBCCopy:
.af8a	a0 02		ldy #$02			ldy 	#2							; skip over the loading address
.af8c	b1 0a		lda ($0a),y			lda 	(zTemp0),y 					; skips first two bytes :)
.af8e	92 0c		sta ($0c)			sta 	(zTemp1)
.af90	e6 0a		inc $0a				inc 	zTemp0
.af92	d0 02		bne $af96			bne 	_NoCarry
.af94	e6 0b		inc $0b				inc 	zTemp0+1
.af96					_NoCarry:
.af96	e6 0c		inc $0c				inc 	zTemp1
.af98	d0 02		bne $af9c			bne 	_NoCarry
.af9a	e6 0d		inc $0d				inc 	zTemp1+1
.af9c					_NoCarry:
.af9c	a5 0a		lda $0a				lda 	zTemp0
.af9e	c9 5d		cmp #$5d			cmp 	#LBCTestEnd & $FF
.afa0	d0 e8		bne $af8a			bne 	_LBCCopy
.afa2	a5 0b		lda $0b				lda 	zTemp0+1
.afa4	c9 b0		cmp #$b0			cmp 	#LBCTestEnd >> 8
.afa6	d0 e2		bne $af8a			bne 	_LBCCopy
.afa8	60		rts				rts
.afa9					LBCTest:
>afa9	01 08 0c 08 e8 03 99 c7				.binary 	"../generated/test.prg"
>afb1	28 31 34 29 00 17 08 f2 03 9e 34 30 39 36 30 00
>afc1	2b 08 fc 03 8f 2e 20 42 59 54 45 20 5a 42 31 40
>afd1	24 30 34 00 3f 08 06 04 8f 2e 20 57 4f 52 44 20
>afe1	5a 57 31 40 24 31 34 00 55 08 10 04 8f 2e 20 42
>aff1	59 54 45 20 41 42 31 40 24 31 32 33 34 00 6b 08
>b001	1a 04 8f 2e 20 57 4f 52 44 20 41 57 31 40 24 32
>b011	43 44 45 00 7e 08 24 04 8f 2e 20 50 52 4f 43 20
>b021	4d 41 49 4e 28 29 00 8d 08 2e 04 8f 2e 20 2b 2b
>b031	41 20 2d 2d 52 00 9c 08 38 04 8f 2e 20 45 4e 44
>b041	50 52 4f 43 00 b1 08 42 04 8f 2e 20 52 45 4d 4f
>b051	56 45 2e 4c 4f 43 41 4c 53 00 00 00
.b05d					LBCTestEnd:

;******  Return to file: main.asm

.b05d					EndCode:

;******  End of listing

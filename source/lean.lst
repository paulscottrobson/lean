
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -Wall -q -c -o lean.prg -L lean.lst main.asm
; Fri Nov  1 15:57:39 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm

=$0801					ProgramStart = $0801 						; where source code starts.
=$b8e9					UserDictionary = EndCode 					; user dictionary
=$a000					CodeMemory = $A000 							; where object code goes.
=$01					CodePage = $01 								; page for code memory.
=$063f					AssemblerStack = $063F 						; compiler stack space.
=$0640					lineBuffer = $0640	 						; current line, match encoded.
=$0680					valueBuffer = $0680 						; buffer for associated values.
=$0700					VariableMemory = $0700 						; data memory allocaed from here
=$0700					BankCode = $0700 							; bank handling code goes here.
=64					LINEBUFFSIZE = 64
=128					VALBUFFSIZE = 128

;******  Processing file: data.asm

=$9f61					ramBank = $9F61 							; RAM Memory bank register.
>0000					scanPtr:	.word ?							; BASIC scan position.
>0002					aStackPtr:	.word ? 						; compiler stack.
>0004					dictPtr:	.word ? 						; dictionary pointer
>0006					genPtr:		.word ? 						; code generation pointer
>0008					varPtr: 	.word ?							; next free variable pointer.
>000a					zTemp0:		.word ? 						; temps.
>000c					zTemp1:		.word ?
>000e					zTemp2:		.word ?
>0010					zTemp3:		.word ?
>0012					lastCreate:	.word ? 						; last created dictionary word
>0014					codePtr:	.word ? 						; code pointer
>0016					codeBank:	.byte ?							; code bank
>0017					originalSP:			.byte ? 				; 6502 stack on entry.
>0018					lastDefine:			.fill 3 				; last defined word (addr/page)
>001b					lineNumber:			.word ? 				; current line number
>001d					identStart:			.byte ? 				; start offset of current identifier
>001e					dirLowByte:			.byte ?					; values returned from search
>001f					dirHighByte:		.byte ?
>0020					dirBank:			.byte ?
>0021					dirLength:			.byte ?
>0022					valueBufferPos:		.byte ? 				; position in value buffer.
>0023					genPos: 			.byte ? 				; position in line buffer, generation.
>0024					generateVar:		.word ? 				; variables used in set value
>0026					elementData:		.fill 3 				; data from matched constant/identifier
>0029					codeBackup:			.fill 3 				; backup code pointer.
>002c					varSize:			.byte ? 				; size of current variable.
>002d					matchCount:			.byte ? 				; successful line matches (for errors)
=$8f					REM_TOKEN = $8F 							; C64 REM Token
="*"					SCM_TOP = '*'								; top of stack marker.
="P"					SCM_PROC = 'P'								; procedure marker
="R"					SCM_REPEAT = 'R'							; repeat marker
="F"					SCM_FOR = 'F' 								; for marker (8 bit)
="G"					SCM_INTFOR = 'G'							; for marker (16 bit)
="I"					SCM_IF = 'I'								; if/else/endif marker.
=$60					CPU_RETURN = $60 							; RTS opcode.
=$48					CPU_PHA = $48 								; PHA
=$68					CPU_PLA = $68 								; PLA
=$3a					CPU_DECA = $3A 								; DEC A
=$d0					CPU_BNE = $D0								; BNE
=$80					CPU_BRA = $80								; BRA
=$20					CPU_JSR = $20 								; JSR
=$da					CPU_PHX = $DA 								; PHX
=$fa					CPU_PLX = $FA 								; PLX
=$c9					CPU_CMPIM = $C9 							; CMP#
=$e0					CPU_CPXIM = $E0 							; CPX#
=$ca					CPU_DEX = $CA 								; DEX

;******  Return to file: main.asm


;******  Processing file: generated/cgconst.inc

=$53					CGEN_C_ISZERO = $53
=$63					CGEN_C_LOW = $63
=$73					CGEN_C_HIGH = $73
=$83					CGEN_C_LOWPLUS1 = $83
=$93					CGEN_C_SETDATA = $93
=$a3					CGEN_C_EXEC = $a3

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.a000	ba		tsx				tsx 									; save SP
.a001	86 17		stx $17				stx 	originalSP
.a003	20 16 b2	jsr $b216			jsr 	LoadBasicCode
.a006	20 52 a3	jsr $a352			jsr 	BankCopyCode 					; copy banked code to RAM space.
.a009	20 a2 a8	jsr $a8a2			jsr 	StackReset 						; reset convert stack.
.a00c	20 e6 a6	jsr $a6e6			jsr 	VariableReset 					; reset variable memory.
.a00f	20 c7 a3	jsr $a3c7			jsr 	DictionaryReset 				; reset user dictionary
.a012	20 3b a4	jsr $a43b			jsr 	CodeReset 						; reset code output.
.a015	20 3f a0	jsr $a03f			jsr 	ScannerReset 					; reset scanner
.a018					AsmLoop:
.a018	20 42 a0	jsr $a042			jsr 	ScannerFind 					; next thing in code
.a01b	90 08		bcc $a025			bcc 	AsmEnd 							; nothing more
.a01d	20 84 a0	jsr $a084			jsr 	ProcessLineToBuffer 			; convert it.
.a020	20 d0 a1	jsr $a1d0			jsr 	GeneratorSearch 				; check it for generators
.a023	80 f3		bra $a018			bra 	AsmLoop 						; and keep going.
.a025					AsmEnd:
.a025	a9 2a		lda #$2a			lda 	#SCM_TOP 						; check structures are done
.a027	20 db a8	jsr $a8db			jsr 	StackCheckStructureMarker
.a02a					ReturnCaller:
.a02a	a6 17		ldx $17				ldx		originalSP 						; restore XP and exit.
.a02c	9a		txs				txs
.a02d	60		rts				rts
.a02e					CallCodeMemory:
>a02e	ff						.byte 	$FF
.a02f	a5 18		lda $18				lda 	lastDefine
.a031	05 19		ora $19				ora 	lastDefine+1
.a033	05 1a		ora $1a				ora 	lastDefine+2
.a035	f0 07		beq $a03e			beq 	_NoExecute
.a037	a5 14		lda $14				lda 	codePtr							; pass in byte after code.
.a039	a6 15		ldx $15				ldx 	codePtr+1
.a03b	6c 18 00	jmp ($0018)			jmp 	(lastDefine)					; call last definition.
.a03e					_NoExecute:
.a03e	60		rts				rts

;******  Processing file: lean/scanner.asm

.a03f					ScannerReset:
.a03f	64 01		stz $01				stz 	scanPtr+1 					; zero MSB means the start
.a041	60		rts				rts
.a042					ScannerFind:
.a042	48		pha				pha 								; save registers
.a043	da		phx				phx
.a044	5a		phy				phy
.a045	a5 01		lda $01				lda 	scanPtr+1 					; reset the scanner pointer ?
.a047	d0 0a		bne $a053			bne 	_SFScanForward 				; no, scan forward from current.
.a049	a9 01		lda #$01			lda 	#(ProgramStart) & $FF
.a04b	85 00		sta $00				sta 	scanPtr
.a04d	a9 08		lda #$08			lda 	#(ProgramStart) >> 8
.a04f	85 01		sta $01				sta 	scanPtr+1
.a051	80 12		bra $a065			bra 	_SFCheck 					; check if this one is a REM.
.a053					_SFScanForward:
.a053	a0 01		ldy #$01			ldy 	#1 							; check if the offset is zero
.a055	b2 00		lda ($00)			lda 	(scanPtr)
.a057	11 00		ora ($00),y			ora 	(scanPtr),y
.a059	18		clc				clc 								; if so exit with CC.
.a05a	f0 24		beq $a080			beq 	_SFExit
.a05c	b2 00		lda ($00)			lda 	(scanPtr) 					; forward to next.
.a05e	aa		tax				tax
.a05f	b1 00		lda ($00),y			lda 	(scanPtr),y
.a061	86 00		stx $00				stx 	scanPtr
.a063	85 01		sta $01				sta 	scanPtr+1
.a065					_SFCheck:
.a065	a0 02		ldy #$02			ldy 	#2 								; copy line number.
.a067	b1 00		lda ($00),y			lda 	(scanPtr),y
.a069	85 1b		sta $1b				sta 	lineNumber
.a06b	c8		iny				iny
.a06c	b1 00		lda ($00),y			lda 	(scanPtr),y
.a06e	85 1c		sta $1c				sta 	lineNumber+1
.a070	c8		iny				iny
.a071	b1 00		lda ($00),y			lda 	(scanPtr),y 				; is it a "REM." line ?
.a073	c9 8f		cmp #$8f			cmp 	#REM_TOKEN
.a075	d0 dc		bne $a053			bne 	_SFScanForward
.a077	c8		iny				iny
.a078	b1 00		lda ($00),y			lda 	(scanPtr),y 				; is it followed by a '.'
.a07a	c8		iny				iny
.a07b	c9 2e		cmp #$2e			cmp 	#"."
.a07d	d0 d4		bne $a053			bne 	_SFScanForward
.a07f	38		sec				sec 								; found something, exit with CS.
.a080					_SFExit:
.a080	7a		ply				ply 								; load registers and exit.
.a081	fa		plx				plx
.a082	68		pla				pla
.a083	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: lean/process.asm

.a084					ProcessLineToBuffer:
.a084	a0 06		ldy #$06			ldy 	#6 							; position in line
.a086	a2 00		ldx #$00			ldx 	#0 							; position in buffer
.a088	64 22		stz $22				stz 	valueBufferPos 				; reset value buffer pos
.a08a	a9 ff		lda #$ff			lda 	#$FF
.a08c	8d 80 06	sta $0680			sta 	valueBuffer 				; erase value buffer (end marker $FF)
.a08f					_PLTConvert:
.a08f	b1 00		lda ($00),y			lda 	(scanPtr),y 				; next character
.a091	f0 7a		beq $a10d			beq 	_PLTExit
.a093	c8		iny				iny
.a094	c9 20		cmp #$20			cmp 	#' ' 						; skip over spaces.
.a096	f0 f7		beq $a08f			beq 	_PLTConvert
.a098	20 71 a1	jsr $a171			jsr 	PLTCheckCharacter 			; identifier character.
.a09b	b0 08		bcs $a0a5			bcs 	_PLTIsIdentifier 			; it's an identifier.
.a09d	09 80		ora #$80			ora 	#$80 						; set bit 7
.a09f	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write out
.a0a2	e8		inx				inx
.a0a3	80 ea		bra $a08f			bra 	_PLTConvert
.a0a5					_PLTIsIdentifier:
.a0a5	86 1d		stx $1d				stx 	identStart 					; save as start of identifier.
.a0a7					_PLTGetIdentifier:
.a0a7	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out.
.a0aa	e8		inx				inx
.a0ab	b1 00		lda ($00),y			lda 	(scanPtr),y	 				; get next character
.a0ad	c8		iny				iny
.a0ae	20 71 a1	jsr $a171			jsr 	PLTCheckCharacter 			; still identifier
.a0b1	b0 f4		bcs $a0a7			bcs 	_PLTGetIdentifier
.a0b3	88		dey				dey 								; undo last bump.
.a0b4					_PLTGotIdentifier:
.a0b4	bd 3f 06	lda $063f,x			lda 	lineBuffer-1,x 				; set bit 7 of last
.a0b7	09 80		ora #$80			ora 	#$80
.a0b9	9d 3f 06	sta $063f,x			sta 	lineBuffer-1,x
.a0bc	5a		phy				phy
.a0bd	da		phx				phx
.a0be	20 65 a1	jsr $a165			jsr 	PLTGetAddress 				; XY <= address of identifier.
.a0c1	20 d6 a3	jsr $a3d6			jsr 	DictionarySearch 			; is it in the dictionaries ?
.a0c4	90 0c		bcc $a0d2			bcc 	_PLTTryConstant
.a0c6	c9 50		cmp #$50			cmp 	#"P" 						; procedure, short or var ?
.a0c8	f0 4b		beq $a115			beq 	_PLTFoundIdentifier
.a0ca	c9 53		cmp #$53			cmp 	#"S"
.a0cc	f0 47		beq $a115			beq 	_PLTFoundIdentifier
.a0ce	c9 49		cmp #$49			cmp 	#"I"
.a0d0	f0 43		beq $a115			beq 	_PLTFoundIdentifier
.a0d2					_PLTTryConstant:
.a0d2	20 65 a1	jsr $a165			jsr 	PLTGetAddress 				; try as a constant
.a0d5	20 12 a8	jsr $a812			jsr 	StringToInt
.a0d8	b0 04		bcs $a0de			bcs 	_PLTAttachIdentifier
.a0da	fa		plx				plx 								; leave as it is - unknown identifier
.a0db	7a		ply				ply
.a0dc	80 b1		bra $a08f			bra 	_PLTConvert
.a0de					_PLTAttachIdentifier:
.a0de	86 0a		stx $0a				stx 	zTemp0 						; save XY
.a0e0	84 0b		sty $0b				sty 	zTemp0+1
.a0e2	fa		plx				plx 								; restore current position
.a0e3	7a		ply				ply
.a0e4	b1 00		lda ($00),y			lda 	(scanPtr),y 				; next character
.a0e6	c9 2d		cmp #$2d			cmp 	#"-"
.a0e8	d0 04		bne $a0ee			bne 	_PLTNotMinus
.a0ea	20 57 a1	jsr $a157			jsr 	_PLTNegateZTemp0 			; negate zTemp0
.a0ed	c8		iny				iny 								; skip it if '-'
.a0ee					_PLTNotMinus:
.a0ee	5a		phy				phy 								; save current positions
.a0ef	da		phx				phx
.a0f0	a6 0a		ldx $0a				ldx 	zTemp0 						; restore XY number
.a0f2	a4 0b		ldy $0b				ldy 	zTemp0+1
.a0f4	a9 00		lda #$00			lda 	#0
.a0f6	20 95 a1	jsr $a195			jsr 	ProcessRecordData 			; record associated data
.a0f9	a9 62		lda #$62			lda 	#"b"
.a0fb	c0 00		cpy #$00			cpy 	#0
.a0fd	f0 02		beq $a101			beq 	_PLTRecord
.a0ff	a9 77		lda #$77			lda 	#"w"
.a101					_PLTRecord:
.a101	fa		plx				plx 								; restore XY position
.a102	7a		ply				ply
.a103	a6 1d		ldx $1d				ldx 	identStart 					; overwrite the position with ident start
.a105	09 80		ora #$80			ora 	#$80 						; bit 7, it's an element in its own right
.a107	9d 40 06	sta $0640,x			sta 	lineBuffer,x 				; write it out
.a10a	e8		inx				inx 								; bump the position
.a10b	80 82		bra $a08f			bra		_PLTConvert 				; do the next one.
.a10d					_PLTExit:
.a10d	9e 40 06	stz $0640,x			stz 	lineBuffer,x 				; make it ASCIIZ
.a110	e0 40		cpx #$40			cpx		#LINEBUFFSIZE 				; line too long.
.a112	b0 31		bcs $a145			bcs 	_PLTBuffer
.a114	60		rts				rts
.a115					_PLTFoundIdentifier:
.a115	48		pha				pha 								; save type.
.a116	a6 1e		ldx $1e				ldx 	dirLowByte 					; get the dictionary AXY values
.a118	a4 1f		ldy $1f				ldy 	dirHighByte
.a11a	a5 20		lda $20				lda 	dirBank
.a11c	20 95 a1	jsr $a195			jsr 	ProcessRecordData 			; attached to identstart
.a11f	68		pla				pla 								; get type back, which is I or S or P
.a120	09 20		ora #$20			ora 	#$20 						; make it lower case.
.a122	c9 70		cmp #$70			cmp 	#"p"						; P goes untrammelled
.a124	f0 db		beq $a101			beq 	_PLTRecord
.a126	c0 00		cpy #$00			cpy 	#0 							; if Y = 0, e.g. zero page, use that.
.a128	f0 d7		beq $a101			beq 	_PLTRecord
.a12a	49 05		eor #$05			eor 	#"i"^"l" 					; convert it to L
.a12c	c9 6c		cmp #$6c			cmp 	#"l"
.a12e	f0 d1		beq $a101			beq 	_PLTRecord
.a130	a9 63		lda #$63			lda 	#"c" 						; otherwise C
.a132	80 cd		bra $a101			bra 	_PLTRecord
.a134					_PLTError:
.a134	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a137	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX ?",$00
>a13f	54 41 58 20 3f 00
.a145					_PLTBuffer:
.a145	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a148	4c 45 41 4e 3a 4c 49 4e				.text 	"LEAN:","LINE SIZE",$00
>a150	45 20 53 49 5a 45 00
.a157					_PLTNegateZTemp0:
.a157	38		sec				sec 								; negate zTemp0
.a158	a9 00		lda #$00			lda 	#0
.a15a	e5 0a		sbc $0a				sbc 	zTemp0
.a15c	85 0a		sta $0a				sta 	zTemp0
.a15e	a9 00		lda #$00			lda 	#0
.a160	e5 0b		sbc $0b				sbc 	zTemp0+1
.a162	85 0b		sta $0b				sta 	zTemp0+1
.a164	60		rts				rts
.a165					PLTGetAddress:
.a165	18		clc				clc
.a166	a5 1d		lda $1d				lda 	identStart
.a168	69 40		adc #$40			adc 	#lineBuffer & $FF
.a16a	aa		tax				tax
.a16b	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a16d	90 01		bcc $a170			bcc 	_PLGANoCarry
.a16f	c8		iny				iny
.a170					_PLGANoCarry:
.a170	60		rts				rts
.a171					PLTCheckCharacter:
.a171	c9 25		cmp #$25			cmp 	#'%'
.a173	f0 1c		beq $a191			beq 	_PLCCYes
.a175	c9 5f		cmp #$5f			cmp 	#'_'
.a177	f0 18		beq $a191			beq 	_PLCCYes
.a179	c9 24		cmp #$24			cmp 	#'$'
.a17b	f0 14		beq $a191			beq 	_PLCCYes
.a17d	c9 2e		cmp #$2e			cmp 	#'.'
.a17f	f0 10		beq $a191			beq 	_PLCCYes
.a181	c9 30		cmp #$30			cmp 	#'0'
.a183	90 0e		bcc $a193			bcc 	_PLCCNo
.a185	c9 3a		cmp #$3a			cmp 	#'9'+1
.a187	90 08		bcc $a191			bcc 	_PLCCYes
.a189	c9 41		cmp #$41			cmp 	#'A'
.a18b	90 06		bcc $a193			bcc 	_PLCCNo
.a18d	c9 5b		cmp #$5b			cmp 	#'Z'+1
.a18f	b0 02		bcs $a193			bcs 	_PLCCNo
.a191					_PLCCYes:
.a191	38		sec				sec
.a192	60		rts				rts
.a193					_PLCCNo:
.a193	18		clc				clc
.a194	60		rts				rts
.a195					ProcessRecordData:
.a195	48		pha				pha
.a196	da		phx				phx
.a197	5a		phy				phy
.a198	da		phx				phx
.a199	a6 22		ldx $22				ldx 	valueBufferPos 				; get current position
.a19b	9d 83 06	sta $0683,x			sta 	valueBuffer+3,x 			; copy data to it
.a19e	98		tya				tya
.a19f	9d 82 06	sta $0682,x			sta 	valueBuffer+2,x
.a1a2	68		pla				pla
.a1a3	9d 81 06	sta $0681,x			sta 	valueBuffer+1,x
.a1a6	a5 1d		lda $1d				lda 	identStart
.a1a8	9d 80 06	sta $0680,x			sta 	valueBuffer+0,x
.a1ab	e8		inx				inx 								; next position
.a1ac	e8		inx				inx
.a1ad	e8		inx				inx
.a1ae	e8		inx				inx
.a1af	86 22		stx $22				stx 	valueBufferPos 				; save
.a1b1	a9 ff		lda #$ff			lda 	#$FF 						; write end marker.
.a1b3	9d 80 06	sta $0680,x			sta 	valueBuffer,x
.a1b6	e0 80		cpx #$80			cpx 	#VALBUFFSIZE
.a1b8	b0 04		bcs $a1be			bcs 	_PRDError
.a1ba	7a		ply				ply
.a1bb	fa		plx				plx
.a1bc	68		pla				pla
.a1bd	60		rts				rts
.a1be					_PRDError:
.a1be	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a1c1	4c 45 41 4e 3a 43 4f 4d				.text 	"LEAN:","COMPLEX ?",$00
>a1c9	50 4c 45 58 20 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/generate.asm

.a1d0					GeneratorSearch:
.a1d0	64 23		stz $23				stz 	genPos 						; reset the generator pointer
.a1d2	64 2d		stz $2d				stz 	matchCount 					; reset the match count.
.a1d4					_GSNextItem:
.a1d4	a6 23		ldx $23				ldx 	genPos 						; check end ?
.a1d6	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a1d9	f0 07		beq $a1e2			beq 	_GSExit
.a1db	20 e3 a1	jsr $a1e3			jsr 	GenerateOne 				; do one match
.a1de	e6 2d		inc $2d				inc 	matchCount 					; bump the count.
.a1e0	80 f2		bra $a1d4			bra 	_GSNextItem
.a1e2					_GSExit:
.a1e2	60		rts				rts
.a1e3					GenerateOne:
.a1e3	a5 23		lda $23				lda 	genPos 						; point XY to the next thing
.a1e5	18		clc				clc 								; the actual address in the line buffer.
.a1e6	69 40		adc #$40			adc 	#lineBuffer & $FF
.a1e8	aa		tax				tax
.a1e9	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a1eb	90 01		bcc $a1ee			bcc 	_GSNoCarry
.a1ed	c8		iny				iny
.a1ee					_GSNoCarry:
.a1ee	20 d3 a3	jsr $a3d3			jsr 	DictionarySearchSystemOnly 	; dictionary search
.a1f1	b0 10		bcs $a203			bcs 	_GSFound
.a1f3					_GSError:
.a1f3	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a1f6	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX?",$00
>a1fe	54 41 58 3f 00
.a203					_GSFound:
.a203	c9 4d		cmp #$4d			cmp 	#"M"						; check it's a match.
.a205	d0 ec		bne $a1f3			bne 	_GSError
.a207	a4 21		ldy $21				ldy 	dirLength 					; advance to next
.a209	a6 23		ldx $23				ldx 	genPos 						; checking for a-z.
.a20b					_GSCheckData:
.a20b	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a20e	29 7f		and #$7f			and 	#$7F
.a210	c9 61		cmp #$61			cmp 	#'a'
.a212	90 08		bcc $a21c			bcc 	_GSNotLC
.a214	c9 7b		cmp #$7b			cmp 	#'z'+1
.a216	b0 04		bcs $a21c			bcs 	_GSNotLC
.a218	8a		txa				txa
.a219	20 9f a2	jsr $a29f			jsr 	GenCopyData
.a21c					_GSNotLC:
.a21c	e8		inx				inx
.a21d	88		dey				dey
.a21e	d0 eb		bne $a20b			bne 	_GSCheckData
.a220	86 23		stx $23				stx 	genPos
.a222	a5 1e		lda $1e				lda 	dirLowByte					; copy address to genPtr
.a224	85 06		sta $06				sta 	genPtr
.a226	a5 1f		lda $1f				lda 	dirHighByte
.a228	85 07		sta $07				sta 	genPtr+1
.a22a	b2 06		lda ($06)			lda 	(genPtr)					; count in A
.a22c	f0 25		beq $a253			beq 	_GSNext 					; nothing !
.a22e	aa		tax				tax 								; X is count
.a22f	a0 01		ldy #$01			ldy 	#1
.a231					_GSGenerate:
.a231	b1 06		lda ($06),y			lda 	(genPtr),y 					; execute something
.a233	c9 a3		cmp #$a3			cmp 	#CGEN_C_EXEC
.a235	f0 1d		beq $a254			beq 	_GSExecute
.a237	c9 93		cmp #$93			cmp 	#CGEN_C_SETDATA 			; set data ?
.a239	d0 0e		bne $a249			bne 	_GSCopy
.a23b	c8		iny				iny									; copy next two bytes out.
.a23c	b1 06		lda ($06),y			lda 	(genPtr),y
.a23e	85 24		sta $24				sta 	generateVar
.a240	c8		iny				iny
.a241	b1 06		lda ($06),y			lda 	(genPtr),y
.a243	85 25		sta $25				sta 	generateVar+1
.a245	ca		dex				dex
.a246	ca		dex				dex
.a247	80 06		bra $a24f			bra 	_GSContinue
.a249					_GSCopy:
.a249	20 70 a2	jsr $a270			jsr 	GenConvertByte 				; replace bytes
.a24c	20 00 07	jsr $0700			jsr 	CodeWriteByte				; write out.
.a24f					_GSContinue:
.a24f	c8		iny				iny
.a250	ca		dex				dex
.a251	d0 de		bne $a231			bne 	_GSGenerate
.a253					_GSNext:
.a253	60		rts				rts
.a254					_GSExecute:
.a254	c8		iny				iny 								; grab one.
.a255	ca		dex				dex
.a256	da		phx				phx 								; save XY
.a257	5a		phy				phy
.a258	b1 06		lda ($06),y			lda 	(genPtr),y 					; read the execution ID
.a25a	0a		asl a				asl 	a 							; index into table.
.a25b	aa		tax				tax
.a25c	bd 38 ac	lda $ac38,x			lda 	ExecutableVectorTable,x 	; read jump vector
.a25f	85 0a		sta $0a				sta 	zTemp0
.a261	bd 39 ac	lda $ac39,x			lda 	ExecutableVectorTable+1,x
.a264	85 0b		sta $0b				sta 	zTemp0+1
.a266	20 6d a2	jsr $a26d			jsr 	_GSCallzTemp0 				; call routine
.a269	7a		ply				ply 								; restore XY
.a26a	fa		plx				plx
.a26b	80 e2		bra $a24f			bra 	_GSContinue
.a26d					_GSCallzTemp0:
.a26d	6c 0a 00	jmp ($000a)			jmp 	(zTemp0)
.a270					GenConvertByte:
.a270	c9 63		cmp #$63			cmp 	#CGEN_C_LOW
.a272	f0 09		beq $a27d			beq 	_GCBLowByte
.a274	c9 83		cmp #$83			cmp 	#CGEN_C_LOWPLUS1
.a276	f0 08		beq $a280			beq 	_GCBLowBytePlus1
.a278	c9 73		cmp #$73			cmp 	#CGEN_C_HIGH
.a27a	f0 0a		beq $a286			beq 	_GCBHighByte
.a27c	60		rts				rts
.a27d					_GCBLowByte:
.a27d	a5 26		lda $26				lda 	elementData
.a27f	60		rts				rts
.a280					_GCBLowBytePlus1:
.a280	a5 26		lda $26				lda 	elementData
.a282	1a		inc a				inc 	a
.a283	f0 04		beq $a289			beq 	_GCBSystem
.a285	60		rts				rts
.a286					_GCBHighByte:
.a286	a5 27		lda $27				lda 	elementData+1
.a288	60		rts				rts
.a289					_GCBSystem:
.a289	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a28c	4c 45 41 4e 3a 57 4f 52				.text 	"LEAN:","WORD OFF PAGE",$00
>a294	44 20 4f 46 46 20 50 41 47 45 00
.a29f					GenCopyData:
.a29f	48		pha				pha
.a2a0	da		phx				phx
.a2a1	5a		phy				phy
.a2a2	85 0a		sta $0a				sta 	zTemp0
.a2a4	a2 fc		ldx #$fc			ldx 	#256-4
.a2a6					_GCDLoop:
.a2a6	e8		inx				inx 								; next slot
.a2a7	e8		inx				inx
.a2a8	e8		inx				inx
.a2a9	e8		inx				inx
.a2aa	bd 80 06	lda $0680,x			lda 	valueBuffer,x 				; next in value buffer
.a2ad	c9 ff		cmp #$ff			cmp 	#$FF
.a2af	f0 16		beq $a2c7			beq 	_GCDError 					; system ?
.a2b1	c5 0a		cmp $0a				cmp 	zTemp0 						; match.
.a2b3	d0 f1		bne $a2a6			bne 	_GCDLoop
.a2b5	a0 00		ldy #$00			ldy 	#0 							; copy assoc data back
.a2b7					_GCDCopy:
.a2b7	bd 81 06	lda $0681,x			lda 	valueBuffer+1,x
.a2ba	99 26 00	sta $0026,y			sta 	elementData,y
.a2bd	e8		inx				inx
.a2be	c8		iny				iny
.a2bf	c0 03		cpy #$03			cpy 	#3
.a2c1	d0 f4		bne $a2b7			bne 	_GCDCopy
.a2c3	7a		ply				ply
.a2c4	fa		plx				plx
.a2c5	68		pla				pla
.a2c6	60		rts				rts
.a2c7					_GCDError:
.a2c7	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a2ca	4c 45 41 4e 3a 53 59 53				.text 	"LEAN:","SYS0?",$00
>a2d2	30 3f 00

;******  Return to file: main.asm


;******  Processing file: lean/extract.asm

.a2d5					EGetUnknownIdentifier:
.a2d5	a6 23		ldx $23				ldx 	genPos 						; get next character
.a2d7	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2da	29 7f		and #$7f			and 	#$7F
.a2dc	20 71 a1	jsr $a171			jsr 	PLTCheckCharacter 			; is it an identifier ?
.a2df	90 15		bcc $a2f6			bcc 	_EUIError 					; no
.a2e1	da		phx				phx 								; save start position on stack.
.a2e2					_EGetFindEnd:
.a2e2	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a2e5	e8		inx				inx
.a2e6	0a		asl a				asl 	a
.a2e7	90 f9		bcc $a2e2			bcc 	_EGetFindEnd
.a2e9	86 23		stx $23				stx 	genPos 						; points to the next thing.
.a2eb	68		pla				pla 								; offset
.a2ec	a0 06		ldy #$06			ldy 	#lineBuffer >> 8 			; make address in YX
.a2ee	18		clc				clc
.a2ef	69 40		adc #$40			adc 	#lineBuffer & $FF
.a2f1	aa		tax				tax
.a2f2	90 01		bcc $a2f5			bcc 	_EGetNoCarry
.a2f4	c8		iny				iny
.a2f5					_EGetNoCarry:
.a2f5	60		rts				rts
.a2f6					_EUIError:
.a2f6	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a2f9	4c 45 41 4e 3a 49 44 45				.text 	"LEAN:","IDENTIFIER ?",$00
>a301	4e 54 49 46 49 45 52 20 3f 00
.a30b					EGetSyntaxCheck:
.a30b	48		pha				pha
.a30c	da		phx				phx
.a30d	a6 23		ldx $23				ldx 	genPos 						; position of next
.a30f	5d 40 06	eor $0640,x			eor 	lineBuffer,x 				; bits 0-6 will be zero if match
.a312	29 7f		and #$7f			and 	#$7F
.a314	d0 05		bne $a31b			bne 	_EGSFail 					; different
.a316	e6 23		inc $23				inc 	genPos 						; skip it and exit
.a318	fa		plx				plx
.a319	68		pla				pla
.a31a	60		rts				rts
.a31b					_EGSFail:
.a31b	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a31e	4c 45 41 4e 3a 4d 49 53				.text 	"LEAN:","MISSING ?",$00
>a326	53 49 4e 47 20 3f 00
.a32d					EGLookNext:
.a32d	da		phx				phx
.a32e	a6 23		ldx $23				ldx 	genPos 						; position of next
.a330	bd 40 06	lda $0640,x			lda 	lineBuffer,x
.a333	fa		plx				plx
.a334	60		rts				rts
.a335					EGSkipNext:
.a335	e6 23		inc $23				inc 	genPos
.a337	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: bank/banking.asm

.a338					BANKEDStart:
=$0700					CodeWriteByte = BankCode
.a338	80 00		bra $a33a			bra 	BankedCodeWriteByte
.a33a					BankedCodeWriteByte:
.a33a	da		phx				phx 								; save XY
.a33b	5a		phy				phy
.a33c	ae 61 9f	ldx $9f61			ldx 	ramBank  					; save old RAM Bank# in X
.a33f	a4 16		ldy $16				ldy 	codeBank 					; get code RAM bank and save code there.
.a341	8c 61 9f	sty $9f61			sty 	ramBank
.a344	92 14		sta ($14)			sta 	(codePtr) 					; save byte out
.a346	e6 14		inc $14				inc 	codePtr 					; bump pointer
.a348	d0 02		bne $a34c			bne 	_CWBNoCarry
.a34a	e6 15		inc $15				inc 	codePtr+1
.a34c					_CWBNoCarry:
.a34c	8e 61 9f	stx $9f61			stx 	ramBank 					; restore page
.a34f	7a		ply				ply 								; and exit.
.a350	fa		plx				plx
.a351	60		rts				rts
.a352					BANKEDEnd:
.a352					BankCopyCode:
.a352	48		pha				pha
.a353	da		phx				phx
.a354	a2 1a		ldx #$1a			ldx 	#BANKEDEnd-BANKEDStart
.a356					_BCCCopy:
.a356	bd 38 a3	lda $a338,x			lda 	BANKEDStart,x
.a359	9d 00 07	sta $0700,x			sta 	BankCode,x
.a35c	ca		dex				dex
.a35d	e0 ff		cpx #$ff			cpx 	#$FF
.a35f	d0 f5		bne $a356			bne 	_BCCCopy
.a361	fa		plx				plx
.a362	68		pla				pla
.a363	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/create.asm

.a364					DictionaryCreate:
.a364	86 0a		stx $0a				stx 	zTemp0 						; save identifier position
.a366	84 0b		sty $0b				sty 	zTemp0+1
.a368	a0 01		ldy #$01			ldy 	#1 							; write the type byte out.
.a36a	91 04		sta ($04),y			sta 	(dictPtr),y
.a36c	a0 00		ldy #$00			ldy 	#0 							; work out length.
.a36e					_DCGetLength:
.a36e	b1 0a		lda ($0a),y			lda 	(zTemp0),y
.a370	c8		iny				iny
.a371	0a		asl a				asl 	a
.a372	90 fa		bcc $a36e			bcc 	_DCGetLength
.a374	5a		phy				phy 								; save Y on stack.
.a375	98		tya				tya 								; save length +6 as offset
.a376	18		clc				clc
.a377	69 06		adc #$06			adc 	#6
.a379	92 04		sta ($04)			sta 	(dictPtr)
.a37b	a0 02		ldy #$02			ldy 	#2 							; fill 2 to 4 with $FF
.a37d	a9 ff		lda #$ff	_DCFill:lda 	#$FF
.a37f	91 04		sta ($04),y			sta 	(dictPtr),y
.a381	c8		iny				iny
.a382	c0 05		cpy #$05			cpy 	#5
.a384	d0 f7		bne $a37d			bne 	_DCFill
.a386	68		pla				pla 								; get length, store in X
.a387	aa		tax				tax
.a388	91 04		sta ($04),y			sta 	(dictPtr),y 				; write length out.
.a38a	a0 00		ldy #$00			ldy 	#0
.a38c					_DCCopy:
.a38c	b1 0a		lda ($0a),y			lda 	(zTemp0),y 					; next identifier character
.a38e	c8		iny				iny 								; save +1 on stack
.a38f	5a		phy				phy
.a390	c8		iny				iny 								; advance by 6 total
.a391	c8		iny				iny
.a392	c8		iny				iny
.a393	c8		iny				iny
.a394	c8		iny				iny
.a395	91 04		sta ($04),y			sta 	(dictPtr),y 				; write out
.a397	7a		ply				ply 								; restore +1
.a398	ca		dex				dex
.a399	d0 f1		bne $a38c			bne 	_DCCopy 					; do that the required# times.
.a39b	a5 04		lda $04				lda 	dictPtr 					; copy last created
.a39d	85 12		sta $12				sta 	lastCreate
.a39f	a5 05		lda $05				lda 	dictPtr+1
.a3a1	85 13		sta $13				sta 	lastCreate+1
.a3a3	18		clc				clc 								; advance dictionary pointer
.a3a4	b2 04		lda ($04)			lda 	(dictPtr)
.a3a6	65 04		adc $04				adc 	dictPtr
.a3a8	85 04		sta $04				sta 	dictPtr
.a3aa	90 02		bcc $a3ae			bcc 	_DCNoCarry
.a3ac	e6 05		inc $05				inc 	dictPtr+1
.a3ae					_DCNoCarry:
.a3ae	a9 00		lda #$00			lda 	#$00 						; write end of dictionary marker
.a3b0	92 04		sta ($04)			sta 	(dictPtr)
.a3b2	60		rts				rts
.a3b3					DictionarySet:
.a3b3	48		pha				pha
.a3b4	da		phx				phx
.a3b5	5a		phy				phy
.a3b6	5a		phy				phy 								; copy data out to
.a3b7	a0 04		ldy #$04			ldy 	#4 							; offset 2,3,4 => A X Y
.a3b9	91 12		sta ($12),y			sta 	(lastCreate),y
.a3bb	88		dey				dey
.a3bc	68		pla				pla
.a3bd	91 12		sta ($12),y			sta 	(lastCreate),y
.a3bf	88		dey				dey
.a3c0	8a		txa				txa
.a3c1	91 12		sta ($12),y			sta 	(lastCreate),y
.a3c3	7a		ply				ply
.a3c4	fa		plx				plx
.a3c5	68		pla				pla
.a3c6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: dictionary/search.asm

.a3c7					DictionaryReset:
.a3c7	a9 e9		lda #$e9			lda 	#(UserDictionary) & $FF
.a3c9	85 04		sta $04				sta 	dictPtr
.a3cb	a9 b8		lda #$b8			lda 	#(UserDictionary) >> 8
.a3cd	85 05		sta $05				sta 	dictPtr+1
.a3cf	9c e9 b8	stz $b8e9			stz 	UserDictionary
.a3d2	60		rts				rts
.a3d3					DictionarySearchSystemOnly:
.a3d3	38		sec				sec
.a3d4	80 01		bra $a3d7			bra 	DictionarySearchContinue
.a3d6					DictionarySearch:
.a3d6	18		clc				clc
.a3d7					DictionarySearchContinue:
.a3d7	da		phx				phx
.a3d8	5a		phy				phy
.a3d9	08		php				php 								; CS if user only
.a3da	8a		txa				txa 								; subtract 6 so can use offset Y
.a3db	38		sec				sec
.a3dc	e9 06		sbc #$06			sbc 	#6
.a3de	85 0a		sta $0a				sta 	zTemp0
.a3e0	98		tya				tya
.a3e1	e9 00		sbc #$00			sbc 	#0
.a3e3	85 0b		sta $0b				sta 	zTemp0+1 					; in zTemp0
.a3e5	28		plp				plp
.a3e6	b0 09		bcs $a3f1			bcs 	_DSCOnly
.a3e8	a2 e9		ldx #$e9			ldx 	#UserDictionary & $FF
.a3ea	a0 b8		ldy #$b8			ldy 	#UserDictionary >> 8
.a3ec	20 fb a3	jsr $a3fb			jsr 	DSSearch
.a3ef	b0 07		bcs $a3f8			bcs 	_DSCExit
.a3f1					_DSCOnly:
.a3f1	a2 54		ldx #$54			ldx 	#SystemDictionary & $FF
.a3f3	a0 ac		ldy #$ac			ldy 	#SystemDictionary >> 8
.a3f5	20 fb a3	jsr $a3fb			jsr 	DSSearch
.a3f8					_DSCExit:
.a3f8	7a		ply				ply 								; restore YX
.a3f9	fa		plx				plx
.a3fa	60		rts				rts
.a3fb					DSSearch:
.a3fb	86 0c		stx $0c				stx 	zTemp1 						; save dictionary in zTemp1
.a3fd	84 0d		sty $0d				sty 	zTemp1+1
.a3ff					_DSLoop:
.a3ff	b2 0c		lda ($0c)			lda 	(zTemp1) 					; offset 0 ?
.a401	f0 36		beq $a439			beq 	_DSExit
.a403	a0 05		ldy #$05			ldy 	#5 							; get length in X
.a405	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a407	aa		tax				tax
.a408					_DSCompare:
.a408	c8		iny				iny 								; match next ?
.a409	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a40b	d1 0a		cmp ($0a),y			cmp 	(zTemp0),y
.a40d	d0 1d		bne $a42c			bne 	_DSNext
.a40f	ca		dex				dex 								; done all
.a410	d0 f6		bne $a408			bne 	_DSCompare
.a412	a0 05		ldy #$05			ldy 	#5 							; copy bank/address
.a414	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a416	85 21		sta $21				sta 	dirLength
.a418	88		dey				dey
.a419	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a41b	85 20		sta $20				sta 	dirBank
.a41d	88		dey				dey
.a41e	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a420	85 1f		sta $1f				sta 	dirHighByte
.a422	88		dey				dey
.a423	b1 0c		lda ($0c),y			lda 	(zTemp1),y
.a425	85 1e		sta $1e				sta 	dirLowByte
.a427	88		dey				dey
.a428	b1 0c		lda ($0c),y			lda 	(zTemp1),y 					; return type
.a42a	38		sec				sec
.a42b	60		rts				rts
.a42c					_DSNext:
.a42c	18		clc				clc 								; advance to next.
.a42d	b2 0c		lda ($0c)			lda 	(zTemp1)
.a42f	65 0c		adc $0c				adc 	zTemp1
.a431	85 0c		sta $0c				sta 	zTemp1
.a433	90 ca		bcc $a3ff			bcc 	_DSLoop
.a435	e6 0d		inc $0d				inc 	zTemp1+1
.a437	80 c6		bra $a3ff			bra 	_DSLoop
.a439					_DSExit:
.a439	18		clc				clc
.a43a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/code.asm

.a43b					CodeReset:
.a43b	a2 00		ldx #$00			ldx 	#CodeMemory & 255
.a43d	a0 a0		ldy #$a0			ldy 	#CodeMemory >> 8
.a43f	a9 01		lda #$01			lda 	#CodePage
.a441	80 00		bra $a443			bra 	CodeSetPointer
.a443					CodeSetPointer:
.a443	48		pha				pha 								; copy old to backup
.a444	a5 14		lda $14				lda 	codePtr
.a446	85 29		sta $29				sta 	codeBackup
.a448	a5 15		lda $15				lda 	codePtr+1
.a44a	85 2a		sta $2a				sta 	codeBackup+1
.a44c	a5 16		lda $16				lda 	codeBank
.a44e	85 2b		sta $2b				sta 	codeBackup+2
.a450	68		pla				pla
.a451	85 16		sta $16				sta 	codeBank 					; update
.a453	86 14		stx $14				stx 	codePtr
.a455	84 15		sty $15				sty 	codePtr+1
.a457	60		rts				rts
.a458					CodeRestorePointer:
.a458	a5 29		lda $29				lda 	codeBackup
.a45a	85 14		sta $14				sta 	codePtr
.a45c	a5 2a		lda $2a				lda 	codeBackup+1
.a45e	85 15		sta $15				sta 	codePtr+1
.a460	a5 2b		lda $2b				lda 	codeBackup+2
.a462	85 16		sta $16				sta 	codeBank
.a464	60		rts				rts
.a465					CodeWriteBranch:
.a465	18		clc				clc 								; borrow 1 as branch is from one on
.a466	8a		txa				txa
.a467	e5 14		sbc $14				sbc 	codePtr
.a469	20 00 07	jsr $0700			jsr 	CodeWriteByte 				; compile anyway.
.a46c	aa		tax				tax 								; actual result in X.
.a46d	98		tya				tya
.a46e	e5 15		sbc $15				sbc 	codePtr+1
.a470	f0 14		beq $a486			beq 	_CWBCheckPositive 			; 00xx
.a472	c9 ff		cmp #$ff			cmp 	#$FF
.a474	f0 14		beq $a48a			beq 	_CWBCheckNegative 			; FFxx
.a476					_CWBError:
.a476	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a479	4c 45 41 4e 3a 42 52 41				.text 	"LEAN:","BRANCH?",$00
>a481	4e 43 48 3f 00
.a486					_CWBCheckPositive:
.a486	8a		txa				txa
.a487	30 ed		bmi $a476			bmi 	_CWBError
.a489	60		rts				rts
.a48a					_CWBCheckNegative:
.a48a	8a		txa				txa
.a48b	10 e9		bpl $a476			bpl 	_CWBError
.a48d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: support/error.asm

.a48e					SyntaxError:
.a48e	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a491	4c 45 41 4e 3a 53 59 4e				.text 	"LEAN:","SYNTAX",$00
>a499	54 41 58 00
.a49d					ErrorHandler:
.a49d	fa		plx				plx 								; pull address off.
.a49e	7a		ply				ply
.a49f	e8		inx				inx 								; point to message
.a4a0	d0 01		bne $a4a3			bne 	_EHNoCarry
.a4a2	c8		iny				iny
.a4a3					_EHNoCarry:
.a4a3	20 fe a4	jsr $a4fe			jsr 	PrintStringXY 				; print string at XY
.a4a6	a2 de		ldx #$de			ldx 	#_EHMessage & $FF 			; print " AT "
.a4a8	a0 a4		ldy #$a4			ldy 	#_EHMessage >> 8
.a4aa	20 fe a4	jsr $a4fe			jsr 	PrintStringXY
.a4ad	a6 1b		ldx $1b				ldx 	lineNumber 					; convert line number
.a4af	a4 1c		ldy $1c				ldy 	lineNumber+1
.a4b1	20 c7 a7	jsr $a7c7			jsr 	IntToString
.a4b4	a2 40		ldx #$40			ldx 	#lineBuffer & $FF 			; print number
.a4b6	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a4b8	20 fe a4	jsr $a4fe			jsr 	PrintStringXY
.a4bb	a9 3a		lda #$3a			lda 	#":"						; print match count
.a4bd	20 0f a5	jsr $a50f			jsr 	PrintCharacter
.a4c0	a6 2d		ldx $2d				ldx 	matchCount
.a4c2	a0 00		ldy #$00			ldy 	#0
.a4c4	20 c7 a7	jsr $a7c7			jsr 	IntToString
.a4c7	a2 40		ldx #$40			ldx 	#lineBuffer & $FF 			; print number
.a4c9	a0 06		ldy #$06			ldy 	#lineBuffer >> 8
.a4cb	20 fe a4	jsr $a4fe			jsr 	PrintStringXY
.a4ce	64 18		stz $18				stz 	lastDefine 					; disable running by zeroing last defined
.a4d0	64 19		stz $19				stz 	lastDefine+1
.a4d2	64 1a		stz $1a				stz 	lastDefine+2
.a4d4	a2 e3		ldx #$e3			ldx 	#_EHMessage2 & $FF 			; print LEAN info
.a4d6	a0 a4		ldy #$a4			ldy 	#_EHMessage2 >> 8
.a4d8	20 fe a4	jsr $a4fe			jsr 	PrintStringXY
.a4db	4c 2a a0	jmp $a02a			jmp 	ReturnCaller 				; exit the compiler.
.a4de					_EHMessage:
>a4de	20 41 54 20 00					.text	" AT ",0
.a4e3					_EHMessage2:
>a4e3	0d 20 20 20 20 4c 45 41				.text 	13,"    LEAN V0.2 (01-NOV-19)",0
>a4eb	4e 20 56 30 2e 32 20 28 30 31 2d 4e 4f 56 2d 31
>a4fb	39 29 00
.a4fe					PrintStringXY:
.a4fe	86 0a		stx $0a				stx 	zTemp0
.a500	84 0b		sty $0b				sty 	zTemp0+1
.a502	a0 00		ldy #$00			ldy 	#0
.a504	b1 0a		lda ($0a),y	_PSLoop:lda 	(zTemp0),y
.a506	f0 06		beq $a50e			beq 	_PSExit
.a508	20 0f a5	jsr $a50f			jsr 	PrintCharacter
.a50b	c8		iny				iny
.a50c	80 f6		bra $a504			bra 	_PSLoop
.a50e	60		rts		_PSExit:rts
.a50f					PrintCharacter:
.a50f	48		pha				pha
.a510	da		phx				phx
.a511	5a		phy				phy
.a512	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a515	7a		ply				ply
.a516	fa		plx				plx
.a517	68		pla				pla
.a518	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/procedure.asm

.a519					Action_Procedure_Def:
.a519	20 d5 a2	jsr $a2d5			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a51c	a9 50		lda #$50			lda 	#"P"
.a51e	20 64 a3	jsr $a364			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a521	a5 16		lda $16				lda 	codeBank 					; and assign it the current PC value.
.a523	a6 14		ldx $14				ldx 	codePtr
.a525	a4 15		ldy $15				ldy 	codePtr+1
.a527	86 18		stx $18				stx 	lastDefine 					; update last defined
.a529	84 19		sty $19				sty 	lastDefine+1
.a52b	85 1a		sta $1a				sta 	lastDefine+2
.a52d	20 b3 a3	jsr $a3b3			jsr 	DictionarySet 				; set the dictionary values.
.a530	a9 28		lda #$28			lda 	#"("
.a532	20 0b a3	jsr $a30b			jsr 	EGetSyntaxCheck
.a535	a9 29		lda #$29			lda 	#")"
.a537	20 0b a3	jsr $a30b			jsr 	EGetSyntaxCheck
.a53a	a9 50		lda #$50			lda 	#SCM_PROC 					; put a procedure marker on the stack.
.a53c	20 bf a8	jsr $a8bf			jsr 	StackPush
.a53f	60		rts				rts
.a540					_APError:
.a540	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a543	4c 45 41 4e 3a 50 52 4f				.text 	"LEAN:","PROCDEF",$00
>a54b	43 44 45 46 00
.a550					Action_EndProc:
.a550	a9 50		lda #$50			lda 	#SCM_PROC 					; check corresponding PROC
.a552	20 db a8	jsr $a8db			jsr 	StackCheckStructureMarker
.a555	a9 60		lda #$60			lda 	#CPU_RETURN					; write out RTS
.a557	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a55a	a9 01		lda #$01			lda 	#1 							; remove from stack.
.a55c	20 08 a9	jsr $a908			jsr 	StackPopStack
.a55f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/call.asm

.a560					Action_Call:
.a560	a5 23		lda $23				lda 	genPos 						; get position
.a562	3a		dec a				dec 	a 							; point to the <proc>
.a563	48		pha				pha 								; save it
.a564	a9 28		lda #$28			lda 	#'('						; check (
.a566	20 0b a3	jsr $a30b			jsr 	EGetSyntaxCheck
.a569	20 2d a3	jsr $a32d			jsr 	EGLookNext 					; ) next ?
.a56c	c9 a9		cmp #$a9			cmp 	#')'+$80
.a56e	f0 1a		beq $a58a			beq 	_ACNoParameters
.a570	a9 52		lda #$52			lda 	#"R" 	 					; do R=<something>
.a572	20 a3 a5	jsr $a5a3			jsr 	ACDoParameter 				; do the parameter.
.a575	20 35 a3	jsr $a335			jsr 	EGSkipNext 					; skip the parameter
.a578	20 2d a3	jsr $a32d			jsr 	EGLookNext 					; what follows
.a57b	c9 ac		cmp #$ac			cmp 	#","+$80 					; if not comma
.a57d	d0 0b		bne $a58a			bne 	_ACNoParameters 			; should be end of parameters
.a57f	20 35 a3	jsr $a335			jsr 	EGSkipNext 					; skip ,
.a582	a9 59		lda #$59			lda 	#"Y"						; do Y=<something>
.a584	20 a3 a5	jsr $a5a3			jsr 	ACDoParameter 				; do the parameter.
.a587	20 35 a3	jsr $a335			jsr 	EGSkipNext 					; skip parameter.
.a58a					_ACNoParameters:
.a58a	a9 29		lda #$29			lda 	#')' 						; check closing bracket.
.a58c	20 0b a3	jsr $a30b			jsr 	EGetSyntaxCheck
.a58f	68		pla				pla 								; restore procedure posiion.
.a590	20 9f a2	jsr $a29f			jsr 	GenCopyData					; get the data
.a593	a9 20		lda #$20			lda 	#CPU_JSR					; output a call to it.
.a595	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a598	a5 26		lda $26				lda 	elementData
.a59a	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a59d	a5 27		lda $27				lda 	elementData+1
.a59f	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a5a2	60		rts				rts
.a5a3					ACDoParameter:
.a5a3	a6 23		ldx $23				ldx 	genPos 						; save position
.a5a5	da		phx				phx
.a5a6	48		pha				pha 								; save the target register
.a5a7	bd 40 06	lda $0640,x			lda 	lineBuffer,x 				; what is there ?
.a5aa	c9 e1		cmp #$e1			cmp 	#"a"+$80 					; check a-z
.a5ac	90 1a		bcc $a5c8			bcc 	_ADPError
.a5ae	c9 fb		cmp #$fb			cmp 	#"z"+$81
.a5b0	b0 16		bcs $a5c8			bcs 	_ADPError
.a5b2	ca		dex				dex 								; write = before it
.a5b3	a9 bd		lda #$bd			lda 	#"="+$80
.a5b5	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a5b8	ca		dex				dex
.a5b9	68		pla				pla 								; write Y/R before that
.a5ba	09 80		ora #$80			ora 	#$80
.a5bc	9d 40 06	sta $0640,x			sta 	lineBuffer,x
.a5bf	86 23		stx $23				stx 	genPos 						; make genPos point to that.
.a5c1	20 e3 a1	jsr $a1e3			jsr 	GenerateOne 				; generate that.
.a5c4	68		pla				pla 								; restore position
.a5c5	85 23		sta $23				sta 	genPos
.a5c7	60		rts				rts
.a5c8					_ADPError:
.a5c8	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a5cb	4c 45 41 4e 3a 50 41 52				.text 	"LEAN:","PARAMETER?",$00
>a5d3	41 4d 45 54 45 52 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/if.asm

.a5db					Action_If:
.a5db	a5 24		lda $24				lda 	generateVar 				; branch to use.
.a5dd	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a5df	20 00 07	jsr $0700			jsr 	CodeWriteByte 				; output it
.a5e2	20 af a8	jsr $a8af			jsr 	StackPushPC 				; push branch position on stack
.a5e5	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a5e7	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a5ea	a9 49		lda #$49			lda 	#SCM_IF 					; put if marker on the stack.
.a5ec	20 bf a8	jsr $a8bf			jsr 	StackPush
.a5ef	60		rts				rts
.a5f0					Action_Else:
.a5f0	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a5f2	20 db a8	jsr $a8db			jsr 	StackCheckStructureMarker
.a5f5	a9 80		lda #$80			lda 	#CPU_BRA 					; compile branch
.a5f7	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a5fa	a5 14		lda $14				lda 	codePtr 					; push current position on the stack
.a5fc	48		pha				pha
.a5fd	a5 15		lda $15				lda 	codePtr+1
.a5ff	48		pha				pha
.a600	a9 ff		lda #$ff			lda 	#$FF 						; dummy branch
.a602	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a605	20 20 a6	jsr $a620			jsr 	BackPatchIf 				; do the backpatch.
.a608	68		pla				pla 								; overwrite backpatch address
.a609	a0 01		ldy #$01			ldy 	#1 							; with stacked position.
.a60b	91 02		sta ($02),y			sta 	(aStackPtr),y
.a60d	68		pla				pla
.a60e	c8		iny				iny
.a60f	91 02		sta ($02),y			sta 	(aStackPtr),y
.a611	60		rts				rts
.a612					Action_Endif:
.a612	a9 49		lda #$49			lda 	#SCM_IF 					; check in IF
.a614	20 db a8	jsr $a8db			jsr 	StackCheckStructureMarker
.a617	20 20 a6	jsr $a620			jsr 	BackPatchIf 				; do the backpatch.
.a61a	a9 04		lda #$04			lda 	#3+1 						; throw the stack.
.a61c	20 08 a9	jsr $a908			jsr 	StackPopStack
.a61f	60		rts				rts
.a620					BackPatchIf:
.a620	a5 14		lda $14					lda 	codePtr 					; save code pointer
.a622	48		pha				pha
.a623	a5 15		lda $15				lda 	codePtr+1
.a625	48		pha				pha
.a626	a0 03		ldy #$03			ldy 	#3 							; AYX = address.
.a628	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a62a	48		pha				pha
.a62b	88		dey				dey
.a62c	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a62e	aa		tax				tax
.a62f	88		dey				dey
.a630	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a632	a8		tay				tay
.a633	68		pla				pla
.a634	20 43 a4	jsr $a443			jsr 	CodeSetPointer 				; set write position to that
.a637	7a		ply				ply 								; target address in YX
.a638	fa		plx				plx
.a639	20 65 a4	jsr $a465			jsr 	CodeWriteBranch 			; write the actual branch there
.a63c	20 58 a4	jsr $a458			jsr 	CodeRestorePointer 			; undo the set pointer.
.a63f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/repeat.asm

.a640					Action_Repeat:
.a640	20 af a8	jsr $a8af			jsr 	StackPushPC 					; push loop position on stack
.a643	a9 52		lda #$52			lda 	#SCM_REPEAT 					; put a repeat marker on the stack.
.a645	20 bf a8	jsr $a8bf			jsr 	StackPush
.a648	60		rts				rts
.a649					Action_Until:
.a649	a9 52		lda #$52			lda 	#SCM_REPEAT 				; check corresponding repeat
.a64b	20 db a8	jsr $a8db			jsr 	StackCheckStructureMarker
.a64e	a5 24		lda $24				lda 	generateVar 				; branch to use.
.a650	49 20		eor #$20			eor 	#$20 						; this makes it negative, e.g. branch if false
.a652	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a654	20 f3 a8	jsr $a8f3			jsr 	StackCompileBranch 			; compile a branch.
.a657	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a659	20 08 a9	jsr $a908			jsr 	StackPopStack
.a65c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/for.asm

.a65d					Action_AFor:
.a65d	20 af a8	jsr $a8af			jsr 	StackPushPC 					; push loop position on stack
.a660	a9 3a		lda #$3a			lda 	#CPU_DECA 						; counts backwards from n-1 to 0.
.a662	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a665	a9 48		lda #$48			lda 	#CPU_PHA 						; push index on stack
.a667	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a66a	a9 46		lda #$46			lda 	#SCM_FOR 						; put a for marker on the stack.
.a66c	20 bf a8	jsr $a8bf			jsr 	StackPush
.a66f	60		rts				rts
.a670					Action_RFor:
.a670	20 af a8	jsr $a8af			jsr 	StackPushPC 					; push loop position on stack
.a673	a9 c9		lda #$c9			lda 	#CPU_CMPIM 						; dec XA code cmp #0
.a675	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a678	a9 00		lda #$00			lda 	#0
.a67a	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a67d	a9 d0		lda #$d0			lda 	#CPU_BNE 						; bne +1
.a67f	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a682	a9 01		lda #$01			lda 	#1
.a684	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a687	a9 ca		lda #$ca			lda 	#CPU_DEX 						; dex
.a689	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a68c	a9 3a		lda #$3a			lda 	#CPU_DECA 						; dec a
.a68e	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a691	a9 48		lda #$48			lda 	#CPU_PHA 						; push index on stack
.a693	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a696	a9 da		lda #$da			lda 	#CPU_PHX
.a698	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a69b	a9 47		lda #$47			lda 	#SCM_INTFOR 					; put a for marker on the stack.
.a69d	20 bf a8	jsr $a8bf			jsr 	StackPush
.a6a0	60		rts				rts
.a6a1					Action_Next:
.a6a1	b2 02		lda ($02)			lda 	(aStackPtr) 				; check for R-Next
.a6a3	c9 47		cmp #$47			cmp 	#SCM_INTFOR
.a6a5	f0 17		beq $a6be			beq 	_AN16Bit
.a6a7	a9 46		lda #$46			lda 	#SCM_FOR 					; check corresponding for
.a6a9	20 db a8	jsr $a8db			jsr 	StackCheckStructureMarker
.a6ac	a9 68		lda #$68			lda 	#CPU_PLA 					; pop index off stack.
.a6ae	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6b1	a9 d0		lda #$d0			lda 	#CPU_BNE 					; branch back if #0
.a6b3	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a6b5	20 f3 a8	jsr $a8f3			jsr 	StackCompileBranch 			; compile a branch.
.a6b8	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a6ba	20 08 a9	jsr $a908			jsr 	StackPopStack
.a6bd	60		rts				rts
.a6be					_AN16Bit:
.a6be	a9 fa		lda #$fa			lda 	#CPU_PLX 					; pop index on stack
.a6c0	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6c3	a9 68		lda #$68			lda 	#CPU_PLA
.a6c5	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6c8	a9 d0		lda #$d0			lda 	#CPU_BNE
.a6ca	a0 01		ldy #$01			ldy 	#1 							; stack at 1 (High) 2 (Low)
.a6cc	20 f3 a8	jsr $a8f3			jsr 	StackCompileBranch 			; compile a branch (check LSB)
.a6cf	a9 e0		lda #$e0			lda 	#CPU_CPXIM  				; check MSB of index
.a6d1	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6d4	a9 00		lda #$00			lda 	#0
.a6d6	20 00 07	jsr $0700			jsr 	CodeWriteByte
.a6d9	a9 d0		lda #$d0			lda 	#CPU_BNE
.a6db	a0 01		ldy #$01			ldy 	#1
.a6dd	20 f3 a8	jsr $a8f3			jsr 	StackCompileBranch
.a6e0	a9 04		lda #$04			lda 	#1+3 						; remove from stack.
.a6e2	20 08 a9	jsr $a908			jsr 	StackPopStack
.a6e5	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: actions/variables.asm

.a6e6					VariableReset:
.a6e6	a9 00		lda #$00			lda 	#(VariableMemory) & $FF
.a6e8	85 08		sta $08				sta 	varPtr
.a6ea	a9 07		lda #$07			lda 	#(VariableMemory) >> 8
.a6ec	85 09		sta $09				sta 	varPtr+1
.a6ee	60		rts				rts
.a6ef					Action_ByteVar:
.a6ef	a9 01		lda #$01			lda 	#1
.a6f1	80 02		bra $a6f5			bra 	VariableDeclare
.a6f3					Action_WordVar:
.a6f3	a9 02		lda #$02			lda 	#2
.a6f5					VariableDeclare:
.a6f5	85 2c		sta $2c				sta 	varSize 					; save variable size.
.a6f7					_VDLoop:
.a6f7	a9 53		lda #$53			lda 	#"S"						; get I or S
.a6f9	a6 2c		ldx $2c				ldx 	varSize
.a6fb	ca		dex				dex
.a6fc	f0 02		beq $a700			beq 	_VDNotWord
.a6fe	a9 49		lda #$49			lda 	#"I"
.a700					_VDNotWord:
.a700	48		pha				pha
.a701	20 d5 a2	jsr $a2d5			jsr 	EGetUnknownIdentifier 		; get an unknown identifier.
.a704	68		pla				pla
.a705	20 64 a3	jsr $a364			jsr 	DictionaryCreate 			; create procedure dictionary entries
.a708	20 2d a3	jsr $a32d			jsr 	EGLookNext 					; what's next ?
.a70b	c9 c0		cmp #$c0			cmp 	#'@'|$80 					; if not @, use default
.a70d	d0 21		bne $a730			bne 	_VDDefault
.a70f	20 35 a3	jsr $a335			jsr 	EGSkipNext 					; skip @
.a712	20 2d a3	jsr $a32d			jsr 	EGLookNext 					; get next
.a715	c9 e2		cmp #$e2			cmp 	#'b'|$80 					; must be b/w constant
.a717	f0 04		beq $a71d			beq 	_VDLegit
.a719	c9 f7		cmp #$f7			cmp 	#'w'|$80
.a71b	d0 34		bne $a751			bne 	_VDError
.a71d					_VDLegit:
.a71d	a5 23		lda $23				lda 	genPos 						; position
.a71f	20 9f a2	jsr $a29f			jsr 	GenCopyData					; access data
.a722	a9 00		lda #$00			lda 	#0 		 					; set the address
.a724	a6 26		ldx $26				ldx 	elementData
.a726	a4 27		ldy $27				ldy 	elementData+1
.a728	20 b3 a3	jsr $a3b3			jsr 	DictionarySet
.a72b	20 35 a3	jsr $a335			jsr 	EGSkipNext 					; consume the constant
.a72e	80 14		bra $a744			bra 	_VDTryNext
.a730					_VDDefault:
.a730	a6 08		ldx $08				ldx 	varPtr 						; place at default position
.a732	a4 09		ldy $09				ldy 	varPtr+1
.a734	a9 00		lda #$00			lda 	#0
.a736	20 b3 a3	jsr $a3b3			jsr 	DictionarySet
.a739	a5 2c		lda $2c				lda 	varSize 					; get count of bytes back
.a73b	18		clc				clc
.a73c	65 08		adc $08				adc 	varPtr
.a73e	85 08		sta $08				sta 	varPtr
.a740	90 02		bcc $a744			bcc 	_VDNoCarry
.a742	e6 09		inc $09				inc 	varPtr+1
.a744					_VDNoCarry:
.a744					_VDTryNext:
.a744	20 2d a3	jsr $a32d			jsr 	EGLookNext 					; what's next ?
.a747	c9 ac		cmp #$ac			cmp 	#","|$80 					; is it a comma
.a749	d0 05		bne $a750			bne 	_VDExit 					; no, exit.
.a74b	20 35 a3	jsr $a335			jsr 	EGSkipNext
.a74e	80 a7		bra $a6f7			bra 	_VDLoop
.a750					_VDExit:
.a750	60		rts				rts
.a751					_VDError:
.a751	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a754	4c 45 41 4e 3a 41 44 44				.text 	"LEAN:","ADDRESS?",$00
>a75c	52 45 53 53 3f 00

;******  Return to file: main.asm


;******  Processing file: actions/crunch.asm

.a762					Action_DictionaryCrunch:
.a762	a9 e9		lda #$e9			lda 	#(UserDictionary) & $FF
.a764	85 0a		sta $0a				sta 	zTemp0
.a766	a9 b8		lda #$b8			lda 	#(UserDictionary) >> 8
.a768	85 0b		sta $0b				sta 	zTemp0+1
.a76a					_ADCLoop:
.a76a	b2 0a		lda ($0a)			lda 	(zTemp0) 					; reached end of dictionary
.a76c	f0 58		beq $a7c6			beq 	_ADCExit
.a76e	a0 06		ldy #$06			ldy 	#6							; read first character
.a770	b1 0a		lda ($0a),y			lda 	(zTemp0),y
.a772	29 7f		and #$7f			and 	#$7F 						; is it a '.' ?
.a774	c9 2e		cmp #$2e			cmp 	#'.'
.a776	d0 41		bne $a7b9			bne 	_ADCNext 					; if not, it's a global, skip to next.
.a778	a5 0a		lda $0a				lda 	zTemp0 						; work out copy from, into zTemp1
.a77a	48		pha				pha
.a77b	18		clc				clc
.a77c	72 0a		adc ($0a)			adc 	(zTemp0)
.a77e	85 0c		sta $0c				sta 	zTemp1
.a780	a5 0b		lda $0b				lda 	zTemp0+1
.a782	48		pha				pha
.a783	69 00		adc #$00			adc 	#0
.a785	85 0d		sta $0d				sta 	zTemp1+1
.a787					_ADCopyOverwrite:
.a787	b2 0c		lda ($0c)			lda 	(zTemp1) 					; byte copy
.a789	92 0a		sta ($0a)			sta 	(zTemp0)
.a78b	a5 0c		lda $0c				lda 	zTemp1 						; until the upper address = dictionary top
.a78d	c5 04		cmp $04				cmp 	dictPtr
.a78f	d0 06		bne $a797			bne 	_ADCNextCopy
.a791	a5 0d		lda $0d				lda 	zTemp1+1
.a793	c5 05		cmp $05				cmp 	dictPtr+1
.a795	f0 0e		beq $a7a5			beq 	_ADCRemoved
.a797					_ADCNextCopy:
.a797	e6 0a		inc $0a				inc 	zTemp0
.a799	d0 02		bne $a79d			bne 	_NoCarry
.a79b	e6 0b		inc $0b				inc 	zTemp0+1
.a79d					_NoCarry:
.a79d	e6 0c		inc $0c				inc 	zTemp1
.a79f	d0 02		bne $a7a3			bne 	_NoCarry
.a7a1	e6 0d		inc $0d				inc 	zTemp1+1
.a7a3					_NoCarry:
.a7a3	80 e2		bra $a787			bra 	_ADCopyOverwrite
.a7a5					_ADCRemoved:
.a7a5	a5 0a		lda $0a				lda 	zTemp0 						; copy from position is new top.
.a7a7	85 04		sta $04				sta 	dictPtr
.a7a9	a5 0b		lda $0b				lda 	zTemp0+1
.a7ab	85 05		sta $05				sta 	dictPtr+1
.a7ad	a9 00		lda #$00			lda 	#0							; mark end as not copied in loop
.a7af	92 04		sta ($04)			sta 	(dictPtr)
.a7b1	68		pla				pla 								; restore original position.
.a7b2	85 0b		sta $0b				sta 	zTemp0+1
.a7b4	68		pla				pla
.a7b5	85 0a		sta $0a				sta 	zTemp0
.a7b7	80 b1		bra $a76a			bra 	_ADCLoop 					; and continue from same position.
.a7b9					_ADCNext:
.a7b9	18		clc				clc 								; advance to next.
.a7ba	a5 0a		lda $0a				lda 	zTemp0
.a7bc	72 0a		adc ($0a)			adc 	(zTemp0)
.a7be	85 0a		sta $0a				sta 	zTemp0
.a7c0	90 a8		bcc $a76a			bcc 	_ADCLoop
.a7c2	e6 0b		inc $0b				inc 	zTemp0+1
.a7c4	80 a4		bra $a76a			bra 	_ADCLoop
.a7c6					_ADCExit:
.a7c6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/tostring.asm

.a7c7					IntToString:
.a7c7	86 0a		stx $0a				stx 	zTemp0 						; count is in zTemp0
.a7c9	84 0b		sty $0b				sty 	zTemp0+1
.a7cb	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a7cd	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a7cf					_ITSLoop:
.a7cf	64 0c		stz $0c				stz 	zTemp1 						; this is the count of subtracts.
.a7d1					_ITSSubtractLoop:
.a7d1	38		sec				sec
.a7d2	a5 0a		lda $0a				lda 	zTemp0 						; try to calculate
.a7d4	fd 0a a8	sbc $a80a,x			sbc 	_ITSWords,x
.a7d7	48		pha				pha
.a7d8	a5 0b		lda $0b				lda 	zTemp0+1
.a7da	fd 0b a8	sbc $a80b,x			sbc 	_ITSWords+1,x
.a7dd	90 09		bcc $a7e8			bcc 	_ITSEndSub 					; can't subtract any more.
.a7df	85 0b		sta $0b				sta 	zTemp0+1 					; update zTemp
.a7e1	68		pla				pla
.a7e2	85 0a		sta $0a				sta 	zTemp0
.a7e4	e6 0c		inc $0c				inc 	zTemp1 						; bump subtract count.
.a7e6	80 e9		bra $a7d1			bra 	_ITSSubtractLoop
.a7e8					_ITSEndSub:
.a7e8	68		pla				pla 								; throw away the interim result
.a7e9	a5 0c		lda $0c				lda 	zTemp1 						; if the subtract count is non zero
.a7eb	d0 04		bne $a7f1			bne 	_ITSWriteOut 				; always write it out
.a7ed	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a7ef	f0 06		beq $a7f7			beq 	_ITSNext 					; suppressing leading zeros.
.a7f1					_ITSWriteOut:
.a7f1	09 30		ora #$30			ora 	#48 						; output digit.
.a7f3	99 40 06	sta $0640,y			sta 	lineBuffer,y
.a7f6	c8		iny				iny
.a7f7					_ITSNext:
.a7f7	e8		inx				inx
.a7f8	e8		inx				inx
.a7f9	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a7fb	d0 d2		bne $a7cf			bne 	_ITSLoop 					; do the new digits
.a7fd	a5 0a		lda $0a				lda 	zTemp0 						; output the last digit
.a7ff	09 30		ora #$30			ora 	#48
.a801	99 40 06	sta $0640,y			sta 	lineBuffer,y 				; make it ASCIIZ.
.a804	a9 00		lda #$00			lda 	#0
.a806	99 41 06	sta $0641,y			sta 	lineBuffer+1,y
.a809	60		rts				rts
.a80a					_ITSWords:
>a80a	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a812					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: utility/tointeger.asm

.a812					StringToInt:
.a812	86 10		stx $10				stx 	zTemp3 						; save string
.a814	84 11		sty $11				sty 	zTemp3+1
.a816	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a818	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a81a	b2 10		lda ($10)			lda 	(zTemp3) 					; first character
.a81c	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a81e	f0 1b		beq $a83b			beq 	_STIConvert 				; convert from character 1, base 16.
.a820	88		dey				dey 								; from character 0
.a821	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a823	c9 2d		cmp #$2d			cmp 	#"-"						; first char is unary minus ?
.a825	d0 14		bne $a83b			bne 	_STIConvert 				; no, convert as +ve decimal
.a827	c8		iny				iny 								; skip the minus
.a828	20 3b a8	jsr $a83b			jsr 	_STIConvert 				; convert the unsigned part.
.a82b	90 0d		bcc $a83a			bcc 	_STIExit 					; failed
.a82d	8a		txa				txa 								; 1's complement YX
.a82e	49 ff		eor #$ff			eor 	#$FF
.a830	aa		tax				tax
.a831	98		tya				tya
.a832	49 ff		eor #$ff			eor 	#$FF
.a834	a8		tay				tay
.a835	e8		inx				inx 								; +1 to make it negative
.a836	38		sec				sec
.a837	d0 01		bne $a83a			bne 	_STIExit
.a839	c8		iny				iny
.a83a					_STIExit:
.a83a	60		rts				rts
.a83b					_STIConvert:
.a83b	86 0c		stx $0c				stx 	zTemp1 						; save base in zTemp1
.a83d	b1 10		lda ($10),y			lda 	(zTemp3),y 					; get first character
.a83f	f0 5f		beq $a8a0			beq 	_STIFail 					; if zero, then it has failed anyway.
.a841	64 0a		stz $0a				stz 	zTemp0 						; clear the result.
.a843	64 0b		stz $0b				stz 	zTemp0+1
.a845					_STILoop:
.a845	a5 0a		lda $0a				lda 	zTemp0 						; copy current to zTemp2
.a847	85 0e		sta $0e				sta 	zTemp2
.a849	a5 0b		lda $0b				lda 	zTemp0+1
.a84b	85 0f		sta $0f				sta 	zTemp2+1
.a84d	64 0a		stz $0a				stz 	zTemp0 						; clear result
.a84f	64 0b		stz $0b				stz 	zTemp0+1
.a851	a6 0c		ldx $0c				ldx 	zTemp1 						; X contains the base.
.a853					_STIMultiply:
.a853	8a		txa				txa 								; shift Y right into carry.
.a854	4a		lsr a				lsr 	a
.a855	aa		tax				tax
.a856	90 0d		bcc $a865			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a858	18		clc				clc
.a859	a5 0e		lda $0e				lda 	zTemp2 						; add zTemp2 into zTemp0
.a85b	65 0a		adc $0a				adc 	zTemp0
.a85d	85 0a		sta $0a				sta 	zTemp0
.a85f	a5 0f		lda $0f				lda 	zTemp2+1
.a861	65 0b		adc $0b				adc 	zTemp0+1
.a863	85 0b		sta $0b				sta 	zTemp0+1
.a865					_STINoAdd:
.a865	06 0e		asl $0e				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a867	26 0f		rol $0f				rol 	zTemp2+1
.a869	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a86b	d0 e6		bne $a853			bne 	_STIMultiply
.a86d	b1 10		lda ($10),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a86f	29 7f		and #$7f			and 	#$7F 						; remove End of Token bit if set
.a871	c9 30		cmp #$30			cmp 	#"0"
.a873	90 2b		bcc $a8a0			bcc 	_STIFail
.a875	c9 3a		cmp #$3a			cmp 	#"9"+1
.a877	90 0b		bcc $a884			bcc 	_STIOkay
.a879	c9 41		cmp #$41			cmp 	#"A"
.a87b	90 23		bcc $a8a0			bcc 	_STIFail
.a87d	c9 47		cmp #$47			cmp 	#"F"+1
.a87f	b0 1f		bcs $a8a0			bcs 	_STIFail
.a881	38		sec				sec 								; hex adjust
.a882	e9 07		sbc #$07			sbc 	#7
.a884					_STIOkay:
.a884	38		sec				sec
.a885	e9 30		sbc #$30			sbc 	#48
.a887	c5 0c		cmp $0c				cmp 	zTemp1  					; if >= base then fail.
.a889	b0 15		bcs $a8a0			bcs 	_STIFail
.a88b	d8		cld				cld
.a88c	65 0a		adc $0a				adc 	zTemp0 						; add into the current value
.a88e	85 0a		sta $0a				sta 	zTemp0
.a890	90 02		bcc $a894			bcc 	_STINoCarry
.a892	e6 0b		inc $0b				inc 	zTemp0+1
.a894					_STINoCarry:
.a894	b1 10		lda ($10),y			lda 	(zTemp3),y					; get character just done.
.a896	c8		iny				iny 								; point to next
.a897	0a		asl a				asl 	a 							; shift bit 7 into carry
.a898	90 ab		bcc $a845			bcc 	_STILoop 					; not reached the end.
.a89a	a6 0a		ldx $0a				ldx 	zTemp0 						; return result
.a89c	a4 0b		ldy $0b				ldy 	zTemp0+1
.a89e	38		sec				sec
.a89f	60		rts				rts
.a8a0					_STIFail:
.a8a0	18		clc				clc
.a8a1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: utility/astack.asm

.a8a2					StackReset:
.a8a2	a9 3f		lda #$3f			lda 	#(assemblerStack) & $FF
.a8a4	85 02		sta $02				sta 	aStackPtr
.a8a6	a9 06		lda #$06			lda 	#(assemblerStack) >> 8
.a8a8	85 03		sta $03				sta 	aStackPtr+1
.a8aa	a9 2a		lda #$2a			lda 	#SCM_TOP
.a8ac	92 02		sta ($02)			sta 	(aStackPtr)
.a8ae	60		rts				rts
.a8af					StackPushPC:
.a8af	a5 16		lda $16				lda 	codeBank
.a8b1	20 bf a8	jsr $a8bf			jsr 	StackPush
.a8b4	a5 14		lda $14				lda 	codePtr
.a8b6	20 bf a8	jsr $a8bf			jsr 	StackPush
.a8b9	a5 15		lda $15				lda 	codePtr+1
.a8bb	20 bf a8	jsr $a8bf			jsr 	StackPush
.a8be	60		rts				rts
.a8bf					StackPush:
.a8bf	c6 02		dec $02				dec 	aStackPtr 					; decrement TOS pointer.
.a8c1	f0 03		beq $a8c6			beq 	_SPStack
.a8c3	92 02		sta ($02)			sta 	(aStackPtr)					; write to new TOS
.a8c5	60		rts				rts
.a8c6					_SPStack:
.a8c6	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a8c9	4c 45 41 4e 3a 52 45 54				.text 	"LEAN:","RETURN STACK",$00
>a8d1	55 52 4e 20 53 54 41 43 4b 00
.a8db					StackCheckStructureMarker:
.a8db	d2 02		cmp ($02)			cmp 	(aStackPtr)					; check if tos matches
.a8dd	d0 01		bne $a8e0			bne 	_SCSError
.a8df	60		rts				rts
.a8e0					_SCSError:
.a8e0	20 9d a4	jsr $a49d			jsr 	ErrorHandler
>a8e3	4c 45 41 4e 3a 53 54 52				.text 	"LEAN:","STRUCTURES",$00
>a8eb	55 43 54 55 52 45 53 00
.a8f3					StackCompileBranch:
.a8f3	48		pha				pha
.a8f4	da		phx				phx
.a8f5	5a		phy				phy
.a8f6	20 00 07	jsr $0700			jsr 	CodeWriteByte 				; write the opcode.
.a8f9	c8		iny				iny
.a8fa	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a8fc	aa		tax				tax
.a8fd	88		dey				dey
.a8fe	b1 02		lda ($02),y			lda 	(aStackPtr),y
.a900	a8		tay				tay
.a901	20 65 a4	jsr $a465			jsr 	CodeWriteBranch 			; write a branch there.
.a904	7a		ply				ply
.a905	fa		plx				plx
.a906	68		pla				pla
.a907	60		rts				rts
.a908					StackPopStack:
.a908	18		clc				clc 								; return stack all in same page
.a909	65 02		adc $02				adc 	aStackPtr 					; so we don't carry out.
.a90b	85 02		sta $02				sta 	aStackPtr
.a90d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/system.inc

.a90e					L10000:
>a90e	04					.byte L10000_END-L10000-1
.a90f	a9 63		lda #$63		lda  #$63
.a911	a2 73		ldx #$73		ldx  #$73
.a913					L10000_END:
.a913					L10001:
>a913	09					.byte L10001_END-L10001-1
.a914	91 63		sta ($63),y		sta  ($63),y
.a916	c8		iny			iny
.a917	8a		txa			txa
.a918	91 63		sta ($63),y		sta  ($63),y
.a91a	88		dey			dey
.a91b	b1 63		lda ($63),y		lda  ($63),y
.a91d					L10001_END:
.a91d					L10002:
>a91d	02					.byte L10002_END-L10002-1
.a91e	91 63		sta ($63),y		sta  ($63),y
.a920					L10002_END:
.a920					L10003:
>a920	02					.byte L10003_END-L10003-1
.a921	84 63		sty $63			sty  $63
.a923					L10003_END:
.a923					L10004:
>a923	02					.byte L10004_END-L10004-1
.a924	85 63		sta $63			sta  $63
.a926					L10004_END:
.a926					L10005:
>a926	02					.byte L10005_END-L10005-1
.a927	85 63		sta $63			sta  $63
.a929					L10005_END:
.a929					L10006:
>a929	04					.byte L10006_END-L10006-1
.a92a	a5 63		lda $63			lda  $63
.a92c	a2 00		ldx #$00		ldx  #0
.a92e					L10006_END:
.a92e					L10007:
>a92e	02					.byte L10007_END-L10007-1
>a92f	a3 00					.byte $a3,$00
.a931					L10007_END:
.a931					L10008:
>a931	06					.byte L10008_END-L10008-1
.a932	8d 63 73	sta $7363		sta  $7363
.a935	8e 83 73	stx $7383		stx  $7383
.a938					L10008_END:
.a938					L10009:
>a938	06					.byte L10009_END-L10009-1
.a939	ad 63 73	lda $7363		lda  $7363
.a93c	ae 83 73	ldx $7383		ldx  $7383
.a93f					L10009_END:
.a93f					L10010:
>a93f	04					.byte L10010_END-L10010-1
.a940	85 63		sta $63			sta  $63
.a942	86 83		stx $83			stx  $83
.a944					L10010_END:
.a944					L10011:
>a944	04					.byte L10011_END-L10011-1
.a945	a5 63		lda $63			lda  $63
.a947	a6 83		ldx $83			ldx  $83
.a949					L10011_END:
.a949					L10012:
>a949	03					.byte L10012_END-L10012-1
.a94a	8c 63 73	sty $7363		sty  $7363
.a94d					L10012_END:
.a94d					L10013:
>a94d	03					.byte L10013_END-L10013-1
.a94e	8d 63 73	sta $7363		sta  $7363
.a951					L10013_END:
.a951					L10014:
>a951	03					.byte L10014_END-L10014-1
.a952	8d 63 73	sta $7363		sta  $7363
.a955					L10014_END:
.a955					L10015:
>a955	05					.byte L10015_END-L10015-1
.a956	ad 63 73	lda $7363		lda  $7363
.a959	a2 00		ldx #$00		ldx  #0
.a95b					L10015_END:
.a95b					L10016:
>a95b	04					.byte L10016_END-L10016-1
.a95c	a9 63		lda #$63		lda  #$63
.a95e	a2 73		ldx #$73		ldx  #$73
.a960					L10016_END:
.a960					L10017:
>a960	07					.byte L10017_END-L10017-1
.a961	8a		txa			txa
.a962	49 ff		eor #$ff		eor  #$ff
.a964	aa		tax			tax
.a965	68		pla			pla
.a966	49 ff		eor #$ff		eor  #$ff
.a968					L10017_END:
.a968					L10018:
>a968	02					.byte L10018_END-L10018-1
.a969	49 ff		eor #$ff		eor  #$ff
.a96b					L10018_END:
.a96b					L10019:
>a96b	02					.byte L10019_END-L10019-1
.a96c	a4 63		ldy $63			ldy  $63
.a96e					L10019_END:
.a96e					L10020:
>a96e	03					.byte L10020_END-L10020-1
.a96f	ac 63 73	ldy $7363		ldy  $7363
.a972					L10020_END:
.a972					L10021:
>a972	02					.byte L10021_END-L10021-1
.a973	a0 63		ldy #$63		ldy  #$63
.a975					L10021_END:
.a975					L10022:
>a975	01					.byte L10022_END-L10022-1
.a976	a8		tay			tay
.a977					L10022_END:
.a977					L10023:
>a977	01					.byte L10023_END-L10023-1
.a978	a8		tay			tay
.a979					L10023_END:
.a979					L10024:
>a979	01					.byte L10024_END-L10024-1
.a97a	5a		phy			phy
.a97b					L10024_END:
.a97b					L10025:
>a97b	02					.byte L10025_END-L10025-1
>a97c	a3 01					.byte $a3,$01
.a97e					L10025_END:
.a97e					L10026:
>a97e	02					.byte L10026_END-L10026-1
>a97f	a3 02					.byte $a3,$02
.a981					L10026_END:
.a981					L10027:
>a981	01					.byte L10027_END-L10027-1
.a982	7a		ply			ply
.a983					L10027_END:
.a983					L10028:
>a983	03					.byte L10028_END-L10028-1
.a984	7a		ply			ply
.a985	fa		plx			plx
.a986	68		pla			pla
.a987					L10028_END:
.a987					L10029:
>a987	02					.byte L10029_END-L10029-1
.a988	fa		plx			plx
.a989	68		pla			pla
.a98a					L10029_END:
.a98a					L10030:
>a98a	01					.byte L10030_END-L10030-1
.a98b	68		pla			pla
.a98c					L10030_END:
.a98c					L10031:
>a98c	08					.byte L10031_END-L10031-1
.a98d	49 63		eor #$63		eor  #$63
.a98f	48		pha			pha
.a990	8a		txa			txa
.a991	49 73		eor #$73		eor  #$73
.a993	aa		tax			tax
.a994	68		pla			pla
.a995					L10031_END:
.a995					L10032:
>a995	0a					.byte L10032_END-L10032-1
.a996	51 63		eor ($63),y		eor  ($63),y
.a998	48		pha			pha
.a999	8a		txa			txa
.a99a	c8		iny			iny
.a99b	51 63		eor ($63),y		eor  ($63),y
.a99d	88		dey			dey
.a99e	aa		tax			tax
.a99f	68		pla			pla
.a9a0					L10032_END:
.a9a0					L10033:
>a9a0	02					.byte L10033_END-L10033-1
.a9a1	45 63		eor $63			eor  $63
.a9a3					L10033_END:
.a9a3					L10034:
>a9a3	0a					.byte L10034_END-L10034-1
.a9a4	4d 63 73	eor $7363		eor  $7363
.a9a7	48		pha			pha
.a9a8	8a		txa			txa
.a9a9	4d 83 73	eor $7383		eor  $7383
.a9ac	aa		tax			tax
.a9ad	68		pla			pla
.a9ae					L10034_END:
.a9ae					L10035:
>a9ae	08					.byte L10035_END-L10035-1
.a9af	45 63		eor $63			eor  $63
.a9b1	48		pha			pha
.a9b2	8a		txa			txa
.a9b3	45 83		eor $83			eor  $83
.a9b5	aa		tax			tax
.a9b6	68		pla			pla
.a9b7					L10035_END:
.a9b7					L10036:
>a9b7	03					.byte L10036_END-L10036-1
.a9b8	4d 63 73	eor $7363		eor  $7363
.a9bb					L10036_END:
.a9bb					L10037:
>a9bb	02					.byte L10037_END-L10037-1
.a9bc	49 63		eor #$63		eor  #$63
.a9be					L10037_END:
.a9be					L10038:
>a9be	02					.byte L10038_END-L10038-1
>a9bf	a3 03					.byte $a3,$03
.a9c1					L10038_END:
.a9c1					L10039:
>a9c1	02					.byte L10039_END-L10039-1
>a9c2	a3 04					.byte $a3,$04
.a9c4					L10039_END:
.a9c4					L10040:
>a9c4	03					.byte L10040_END-L10040-1
.a9c5	48		pha			pha
.a9c6	da		phx			phx
.a9c7	5a		phy			phy
.a9c8					L10040_END:
.a9c8					L10041:
>a9c8	04					.byte L10041_END-L10041-1
.a9c9	a9 63		lda #$63		lda  #$63
.a9cb	a2 73		ldx #$73		ldx  #$73
.a9cd					L10041_END:
.a9cd					L10042:
>a9cd	07					.byte L10042_END-L10042-1
.a9ce	c8		iny			iny
.a9cf	b1 63		lda ($63),y		lda  ($63),y
.a9d1	aa		tax			tax
.a9d2	88		dey			dey
.a9d3	b1 63		lda ($63),y		lda  ($63),y
.a9d5					L10042_END:
.a9d5					L10043:
>a9d5	04					.byte L10043_END-L10043-1
.a9d6	a5 63		lda $63			lda  $63
.a9d8	a2 00		ldx #$00		ldx  #0
.a9da					L10043_END:
.a9da					L10044:
>a9da	06					.byte L10044_END-L10044-1
.a9db	ad 63 73	lda $7363		lda  $7363
.a9de	ae 83 73	ldx $7383		ldx  $7383
.a9e1					L10044_END:
.a9e1					L10045:
>a9e1	04					.byte L10045_END-L10045-1
.a9e2	a5 63		lda $63			lda  $63
.a9e4	a6 83		ldx $83			ldx  $83
.a9e6					L10045_END:
.a9e6					L10046:
>a9e6	05					.byte L10046_END-L10046-1
.a9e7	ad 63 73	lda $7363		lda  $7363
.a9ea	a2 00		ldx #$00		ldx  #0
.a9ec					L10046_END:
.a9ec					L10047:
>a9ec	04					.byte L10047_END-L10047-1
.a9ed	a9 63		lda #$63		lda  #$63
.a9ef	a2 73		ldx #$73		ldx  #$73
.a9f1					L10047_END:
.a9f1					L10048:
>a9f1	03					.byte L10048_END-L10048-1
.a9f2	98		tya			tya
.a9f3	a2 00		ldx #$00		ldx  #0
.a9f5					L10048_END:
.a9f5					L10049:
>a9f5	02					.byte L10049_END-L10049-1
.a9f6	a2 00		ldx #$00		ldx  #0
.a9f8					L10049_END:
.a9f8					L10050:
>a9f8	09					.byte L10050_END-L10050-1
.a9f9	c9 00		cmp #$00		cmp #0
.a9fb	d0 02		bne $a9ff		bne *+4
.a9fd	e0 00		cpx #$00		cpx #0
>a9ff	93					.byte $93
.aa00	f0 fe		beq $aa00		beq *
.aa02					L10050_END:
.aa02					L10051:
>aa02	09					.byte L10051_END-L10051-1
.aa03	c9 00		cmp #$00		cmp #0
.aa05	d0 02		bne $aa09		bne *+4
.aa07	e0 00		cpx #$00		cpx #0
>aa09	93					.byte $93
.aa0a	d0 fe		bne $aa0a		bne *
.aa0c					L10051_END:
.aa0c					L10052:
>aa0c	08					.byte L10052_END-L10052-1
.aa0d	09 63		ora #$63		ora  #$63
.aa0f	48		pha			pha
.aa10	8a		txa			txa
.aa11	09 73		ora #$73		ora  #$73
.aa13	aa		tax			tax
.aa14	68		pla			pla
.aa15					L10052_END:
.aa15					L10053:
>aa15	0a					.byte L10053_END-L10053-1
.aa16	11 63		ora ($63),y		ora  ($63),y
.aa18	48		pha			pha
.aa19	8a		txa			txa
.aa1a	c8		iny			iny
.aa1b	11 63		ora ($63),y		ora  ($63),y
.aa1d	88		dey			dey
.aa1e	aa		tax			tax
.aa1f	68		pla			pla
.aa20					L10053_END:
.aa20					L10054:
>aa20	02					.byte L10054_END-L10054-1
.aa21	05 63		ora $63			ora  $63
.aa23					L10054_END:
.aa23					L10055:
>aa23	0a					.byte L10055_END-L10055-1
.aa24	0d 63 73	ora $7363		ora  $7363
.aa27	48		pha			pha
.aa28	8a		txa			txa
.aa29	0d 83 73	ora $7383		ora  $7383
.aa2c	aa		tax			tax
.aa2d	68		pla			pla
.aa2e					L10055_END:
.aa2e					L10056:
>aa2e	08					.byte L10056_END-L10056-1
.aa2f	05 63		ora $63			ora  $63
.aa31	48		pha			pha
.aa32	8a		txa			txa
.aa33	05 83		ora $83			ora  $83
.aa35	aa		tax			tax
.aa36	68		pla			pla
.aa37					L10056_END:
.aa37					L10057:
>aa37	03					.byte L10057_END-L10057-1
.aa38	0d 63 73	ora $7363		ora  $7363
.aa3b					L10057_END:
.aa3b					L10058:
>aa3b	02					.byte L10058_END-L10058-1
.aa3c	09 63		ora #$63		ora  #$63
.aa3e					L10058_END:
.aa3e					L10059:
>aa3e	03					.byte L10059_END-L10059-1
.aa3f	48		pha			pha
.aa40	8a		txa			txa
.aa41	fa		plx			plx
.aa42					L10059_END:
.aa42					L10060:
>aa42	02					.byte L10060_END-L10060-1
>aa43	a3 05					.byte $a3,$05
.aa45					L10060_END:
.aa45					L10061:
>aa45	09					.byte L10061_END-L10061-1
.aa46	38		sec			sec
.aa47	e9 63		sbc #$63		sbc  #$63
.aa49	48		pha			pha
.aa4a	8a		txa			txa
.aa4b	e9 73		sbc #$73		sbc  #$73
.aa4d	aa		tax			tax
.aa4e	68		pla			pla
.aa4f					L10061_END:
.aa4f					L10062:
>aa4f	0b					.byte L10062_END-L10062-1
.aa50	38		sec			sec
.aa51	f1 63		sbc ($63),y		sbc  ($63),y
.aa53	48		pha			pha
.aa54	8a		txa			txa
.aa55	c8		iny			iny
.aa56	f1 63		sbc ($63),y		sbc  ($63),y
.aa58	88		dey			dey
.aa59	aa		tax			tax
.aa5a	68		pla			pla
.aa5b					L10062_END:
.aa5b					L10063:
>aa5b	06					.byte L10063_END-L10063-1
.aa5c	38		sec			sec
.aa5d	e5 63		sbc $63			sbc  $63
.aa5f	b0 01		bcs $aa62		bcs  *+3
.aa61	ca		dex			dex
.aa62					L10063_END:
.aa62					L10064:
>aa62	0b					.byte L10064_END-L10064-1
.aa63	38		sec			sec
.aa64	ed 63 73	sbc $7363		sbc  $7363
.aa67	48		pha			pha
.aa68	8a		txa			txa
.aa69	ed 83 73	sbc $7383		sbc  $7383
.aa6c	aa		tax			tax
.aa6d	68		pla			pla
.aa6e					L10064_END:
.aa6e					L10065:
>aa6e	09					.byte L10065_END-L10065-1
.aa6f	38		sec			sec
.aa70	e5 63		sbc $63			sbc  $63
.aa72	48		pha			pha
.aa73	8a		txa			txa
.aa74	e5 83		sbc $83			sbc  $83
.aa76	aa		tax			tax
.aa77	68		pla			pla
.aa78					L10065_END:
.aa78					L10066:
>aa78	07					.byte L10066_END-L10066-1
.aa79	38		sec			sec
.aa7a	ed 63 73	sbc $7363		sbc  $7363
.aa7d	b0 01		bcs $aa80		bcs  *+3
.aa7f	ca		dex			dex
.aa80					L10066_END:
.aa80					L10067:
>aa80	06					.byte L10067_END-L10067-1
.aa81	38		sec			sec
.aa82	e9 63		sbc #$63		sbc  #$63
.aa84	b0 01		bcs $aa87		bcs  *+3
.aa86	ca		dex			dex
.aa87					L10067_END:
.aa87					L10068:
>aa87	05					.byte L10068_END-L10068-1
.aa88	e0 00		cpx #$00		cpx #0
>aa8a	93					.byte $93
.aa8b	30 fe		bmi $aa8b		bmi *
.aa8d					L10068_END:
.aa8d					L10069:
>aa8d	02					.byte L10069_END-L10069-1
.aa8e	48		pha			pha
.aa8f	da		phx			phx
.aa90					L10069_END:
.aa90					L10070:
>aa90	09					.byte L10070_END-L10070-1
.aa91	18		clc			clc
.aa92	69 63		adc #$63		adc  #$63
.aa94	48		pha			pha
.aa95	8a		txa			txa
.aa96	69 73		adc #$73		adc  #$73
.aa98	aa		tax			tax
.aa99	68		pla			pla
.aa9a					L10070_END:
.aa9a					L10071:
>aa9a	0b					.byte L10071_END-L10071-1
.aa9b	18		clc			clc
.aa9c	71 63		adc ($63),y		adc  ($63),y
.aa9e	48		pha			pha
.aa9f	8a		txa			txa
.aaa0	c8		iny			iny
.aaa1	71 63		adc ($63),y		adc  ($63),y
.aaa3	88		dey			dey
.aaa4	aa		tax			tax
.aaa5	68		pla			pla
.aaa6					L10071_END:
.aaa6					L10072:
>aaa6	06					.byte L10072_END-L10072-1
.aaa7	18		clc			clc
.aaa8	65 63		adc $63			adc  $63
.aaaa	90 01		bcc $aaad		bcc  *+3
.aaac	e8		inx			inx
.aaad					L10072_END:
.aaad					L10073:
>aaad	0b					.byte L10073_END-L10073-1
.aaae	18		clc			clc
.aaaf	6d 63 73	adc $7363		adc  $7363
.aab2	48		pha			pha
.aab3	8a		txa			txa
.aab4	6d 83 73	adc $7383		adc  $7383
.aab7	aa		tax			tax
.aab8	68		pla			pla
.aab9					L10073_END:
.aab9					L10074:
>aab9	09					.byte L10074_END-L10074-1
.aaba	18		clc			clc
.aabb	65 63		adc $63			adc  $63
.aabd	48		pha			pha
.aabe	8a		txa			txa
.aabf	65 83		adc $83			adc  $83
.aac1	aa		tax			tax
.aac2	68		pla			pla
.aac3					L10074_END:
.aac3					L10075:
>aac3	07					.byte L10075_END-L10075-1
.aac4	18		clc			clc
.aac5	6d 63 73	adc $7363		adc  $7363
.aac8	90 01		bcc $aacb		bcc  *+3
.aaca	e8		inx			inx
.aacb					L10075_END:
.aacb					L10076:
>aacb	06					.byte L10076_END-L10076-1
.aacc	18		clc			clc
.aacd	69 63		adc #$63		adc  #$63
.aacf	90 01		bcc $aad2		bcc  *+3
.aad1	e8		inx			inx
.aad2					L10076_END:
.aad2					L10077:
>aad2	05					.byte L10077_END-L10077-1
.aad3	e0 00		cpx #$00		cpx #0
>aad5	93					.byte $93
.aad6	10 fe		bpl $aad6		bpl *
.aad8					L10077_END:
.aad8					L10078:
>aad8	08					.byte L10078_END-L10078-1
.aad9	29 63		and #$63		and  #$63
.aadb	48		pha			pha
.aadc	8a		txa			txa
.aadd	29 73		and #$73		and  #$73
.aadf	aa		tax			tax
.aae0	68		pla			pla
.aae1					L10078_END:
.aae1					L10079:
>aae1	0a					.byte L10079_END-L10079-1
.aae2	31 63		and ($63),y		and  ($63),y
.aae4	48		pha			pha
.aae5	8a		txa			txa
.aae6	c8		iny			iny
.aae7	31 63		and ($63),y		and  ($63),y
.aae9	88		dey			dey
.aaea	aa		tax			tax
.aaeb	68		pla			pla
.aaec					L10079_END:
.aaec					L10080:
>aaec	04					.byte L10080_END-L10080-1
.aaed	25 63		and $63			and  $63
.aaef	a2 00		ldx #$00		ldx  #0
.aaf1					L10080_END:
.aaf1					L10081:
>aaf1	0a					.byte L10081_END-L10081-1
.aaf2	2d 63 73	and $7363		and  $7363
.aaf5	48		pha			pha
.aaf6	8a		txa			txa
.aaf7	2d 83 73	and $7383		and  $7383
.aafa	aa		tax			tax
.aafb	68		pla			pla
.aafc					L10081_END:
.aafc					L10082:
>aafc	08					.byte L10082_END-L10082-1
.aafd	25 63		and $63			and  $63
.aaff	48		pha			pha
.ab00	8a		txa			txa
.ab01	25 83		and $83			and  $83
.ab03	aa		tax			tax
.ab04	68		pla			pla
.ab05					L10082_END:
.ab05					L10083:
>ab05	05					.byte L10083_END-L10083-1
.ab06	2d 63 73	and $7363		and  $7363
.ab09	a2 00		ldx #$00		ldx  #0
.ab0b					L10083_END:
.ab0b					L10084:
>ab0b	04					.byte L10084_END-L10084-1
.ab0c	29 63		and #$63		and  #$63
.ab0e	a2 00		ldx #$00		ldx  #0
.ab10					L10084_END:
.ab10					L10085:
>ab10	02					.byte L10085_END-L10085-1
>ab11	a3 06					.byte $a3,$06
.ab13					L10085_END:
.ab13					L10086:
>ab13	02					.byte L10086_END-L10086-1
>ab14	a3 07					.byte $a3,$07
.ab16					L10086_END:
.ab16					L10087:
>ab16	02					.byte L10087_END-L10087-1
>ab17	a3 08					.byte $a3,$08
.ab19					L10087_END:
.ab19					L10088:
>ab19	02					.byte L10088_END-L10088-1
>ab1a	a3 09					.byte $a3,$09
.ab1c					L10088_END:
.ab1c					L10089:
>ab1c	02					.byte L10089_END-L10089-1
>ab1d	a3 0a					.byte $a3,$0a
.ab1f					L10089_END:
.ab1f					L10090:
>ab1f	02					.byte L10090_END-L10090-1
>ab20	a3 0b					.byte $a3,$0b
.ab22					L10090_END:
.ab22					L10091:
>ab22	03					.byte L10091_END-L10091-1
>ab23	93					.byte $93
.ab24	b0 fe		bcs $ab24		bcs  *
.ab26					L10091_END:
.ab26					L10092:
>ab26	03					.byte L10092_END-L10092-1
>ab27	93					.byte $93
.ab28	90 fe		bcc $ab28		bcc  *
.ab2a					L10092_END:
.ab2a					L10093:
>ab2a	02					.byte L10093_END-L10093-1
>ab2b	a3 0c					.byte $a3,$0c
.ab2d					L10093_END:
.ab2d					L10094:
>ab2d	01					.byte L10094_END-L10094-1
>ab2e	ff					.byte  $ff
.ab2f					L10094_END:
.ab2f					L10095:
>ab2f	02					.byte L10095_END-L10095-1
.ab30	51 63		eor ($63),y		eor  ($63),y
.ab32					L10095_END:
.ab32					L10096:
>ab32	02					.byte L10096_END-L10096-1
.ab33	45 63		eor $63			eor  $63
.ab35					L10096_END:
.ab35					L10097:
>ab35	03					.byte L10097_END-L10097-1
.ab36	4d 63 73	eor $7363		eor  $7363
.ab39					L10097_END:
.ab39					L10098:
>ab39	02					.byte L10098_END-L10098-1
.ab3a	49 63		eor #$63		eor  #$63
.ab3c					L10098_END:
.ab3c					L10099:
>ab3c	02					.byte L10099_END-L10099-1
.ab3d	b1 63		lda ($63),y		lda  ($63),y
.ab3f					L10099_END:
.ab3f					L10100:
>ab3f	02					.byte L10100_END-L10100-1
.ab40	a5 63		lda $63			lda  $63
.ab42					L10100_END:
.ab42					L10101:
>ab42	03					.byte L10101_END-L10101-1
.ab43	ad 63 73	lda $7363		lda  $7363
.ab46					L10101_END:
.ab46					L10102:
>ab46	02					.byte L10102_END-L10102-1
.ab47	a9 63		lda #$63		lda  #$63
.ab49					L10102_END:
.ab49					L10103:
>ab49	01					.byte L10103_END-L10103-1
.ab4a	98		tya			tya
.ab4b					L10103_END:
.ab4b					L10104:
>ab4b	00					.byte L10104_END-L10104-1
.ab4c					L10104_END:
.ab4c					L10105:
>ab4c	05					.byte L10105_END-L10105-1
.ab4d	c9 00		cmp #$00		cmp #0
>ab4f	93					.byte $93
.ab50	f0 fe		beq $ab50		beq *
.ab52					L10105_END:
.ab52					L10106:
>ab52	05					.byte L10106_END-L10106-1
.ab53	c9 00		cmp #$00		cmp #0
>ab55	93					.byte $93
.ab56	d0 fe		bne $ab56		bne *
.ab58					L10106_END:
.ab58					L10107:
>ab58	02					.byte L10107_END-L10107-1
.ab59	11 63		ora ($63),y		ora  ($63),y
.ab5b					L10107_END:
.ab5b					L10108:
>ab5b	02					.byte L10108_END-L10108-1
.ab5c	05 63		ora $63			ora  $63
.ab5e					L10108_END:
.ab5e					L10109:
>ab5e	03					.byte L10109_END-L10109-1
.ab5f	0d 63 73	ora $7363		ora  $7363
.ab62					L10109_END:
.ab62					L10110:
>ab62	02					.byte L10110_END-L10110-1
.ab63	09 63		ora #$63		ora  #$63
.ab65					L10110_END:
.ab65					L10111:
>ab65	02					.byte L10111_END-L10111-1
>ab66	a3 0d					.byte $a3,$0d
.ab68					L10111_END:
.ab68					L10112:
>ab68	03					.byte L10112_END-L10112-1
.ab69	38		sec			sec
.ab6a	f1 63		sbc ($63),y		sbc  ($63),y
.ab6c					L10112_END:
.ab6c					L10113:
>ab6c	03					.byte L10113_END-L10113-1
.ab6d	38		sec			sec
.ab6e	e5 63		sbc $63			sbc  $63
.ab70					L10113_END:
.ab70					L10114:
>ab70	04					.byte L10114_END-L10114-1
.ab71	38		sec			sec
.ab72	ed 63 73	sbc $7363		sbc  $7363
.ab75					L10114_END:
.ab75					L10115:
>ab75	03					.byte L10115_END-L10115-1
.ab76	38		sec			sec
.ab77	e9 63		sbc #$63		sbc  #$63
.ab79					L10115_END:
.ab79					L10116:
>ab79	05					.byte L10116_END-L10116-1
.ab7a	c9 00		cmp #$00		cmp #0
>ab7c	93					.byte $93
.ab7d	30 fe		bmi $ab7d		bmi *
.ab7f					L10116_END:
.ab7f					L10117:
>ab7f	01					.byte L10117_END-L10117-1
.ab80	48		pha			pha
.ab81					L10117_END:
.ab81					L10118:
>ab81	03					.byte L10118_END-L10118-1
.ab82	18		clc			clc
.ab83	71 63		adc ($63),y		adc  ($63),y
.ab85					L10118_END:
.ab85					L10119:
>ab85	03					.byte L10119_END-L10119-1
.ab86	18		clc			clc
.ab87	65 63		adc $63			adc  $63
.ab89					L10119_END:
.ab89					L10120:
>ab89	04					.byte L10120_END-L10120-1
.ab8a	18		clc			clc
.ab8b	6d 63 73	adc $7363		adc  $7363
.ab8e					L10120_END:
.ab8e					L10121:
>ab8e	03					.byte L10121_END-L10121-1
.ab8f	18		clc			clc
.ab90	69 63		adc #$63		adc  #$63
.ab92					L10121_END:
.ab92					L10122:
>ab92	05					.byte L10122_END-L10122-1
.ab93	c9 00		cmp #$00		cmp #0
>ab95	93					.byte $93
.ab96	10 fe		bpl $ab96		bpl *
.ab98					L10122_END:
.ab98					L10123:
>ab98	02					.byte L10123_END-L10123-1
.ab99	31 63		and ($63),y		and  ($63),y
.ab9b					L10123_END:
.ab9b					L10124:
>ab9b	02					.byte L10124_END-L10124-1
.ab9c	25 63		and $63			and  $63
.ab9e					L10124_END:
.ab9e					L10125:
>ab9e	03					.byte L10125_END-L10125-1
.ab9f	2d 63 73	and $7363		and  $7363
.aba2					L10125_END:
.aba2					L10126:
>aba2	02					.byte L10126_END-L10126-1
.aba3	29 63		and #$63		and  #$63
.aba5					L10126_END:
.aba5					L10127:
>aba5	02					.byte L10127_END-L10127-1
.aba6	46 63		lsr $63			lsr  $63
.aba8					L10127_END:
.aba8					L10128:
>aba8	06					.byte L10128_END-L10128-1
.aba9	4e 83 73	lsr $7383		lsr  $7383
.abac	6e 63 73	ror $7363		ror  $7363
.abaf					L10128_END:
.abaf					L10129:
>abaf	04					.byte L10129_END-L10129-1
.abb0	46 83		lsr $83			lsr  $83
.abb2	66 63		ror $63			ror  $63
.abb4					L10129_END:
.abb4					L10130:
>abb4	03					.byte L10130_END-L10130-1
.abb5	4e 63 73	lsr $7363		lsr  $7363
.abb8					L10130_END:
.abb8					L10131:
>abb8	06					.byte L10131_END-L10131-1
.abb9	48		pha			pha
.abba	8a		txa			txa
.abbb	4a		lsr a			lsr  a
.abbc	aa		tax			tax
.abbd	68		pla			pla
.abbe	6a		ror a			ror  a
.abbf					L10131_END:
.abbf					L10132:
>abbf	01					.byte L10132_END-L10132-1
.abc0	4a		lsr a			lsr  a
.abc1					L10132_END:
.abc1					L10133:
>abc1	02					.byte L10133_END-L10133-1
.abc2	06 63		asl $63			asl  $63
.abc4					L10133_END:
.abc4					L10134:
>abc4	06					.byte L10134_END-L10134-1
.abc5	0e 63 73	asl $7363		asl  $7363
.abc8	2e 83 73	rol $7383		rol  $7383
.abcb					L10134_END:
.abcb					L10135:
>abcb	04					.byte L10135_END-L10135-1
.abcc	06 63		asl $63			asl  $63
.abce	26 83		rol $83			rol  $83
.abd0					L10135_END:
.abd0					L10136:
>abd0	03					.byte L10136_END-L10136-1
.abd1	0e 63 73	asl $7363		asl  $7363
.abd4					L10136_END:
.abd4					L10137:
>abd4	06					.byte L10137_END-L10137-1
.abd5	0a		asl a			asl  a
.abd6	48		pha			pha
.abd7	8a		txa			txa
.abd8	2a		rol a			rol  a
.abd9	aa		tax			tax
.abda	68		pla			pla
.abdb					L10137_END:
.abdb					L10138:
>abdb	01					.byte L10138_END-L10138-1
.abdc	0a		asl a			asl  a
.abdd					L10138_END:
.abdd					L10139:
>abdd	0b					.byte L10139_END-L10139-1
.abde	8a		txa			txa
.abdf	49 ff		eor #$ff		eor  #$ff
.abe1	aa		tax			tax
.abe2	68		pla			pla
.abe3	49 ff		eor #$ff		eor  #$ff
.abe5	1a		inc a			inc  a
.abe6	d0 01		bne $abe9		bne  *+3
.abe8	e8		inx			inx
.abe9					L10139_END:
.abe9					L10140:
>abe9	03					.byte L10140_END-L10140-1
.abea	49 ff		eor #$ff		eor  #$ff
.abec	1a		inc a			inc  a
.abed					L10140_END:
.abed					L10141:
>abed	02					.byte L10141_END-L10141-1
.abee	c6 63		dec $63			dec  $63
.abf0					L10141_END:
.abf0					L10142:
>abf0	0d					.byte L10142_END-L10142-1
.abf1	48		pha			pha
.abf2	ad 63 73	lda $7363		lda  $7363
.abf5	d0 03		bne $abfa		bne  _noborrow
.abf7	ce 83 73	dec $7383		dec  $7383
.abfa					_noborrow:
.abfa	ce 63 73	dec $7363		dec  $7363
.abfd	68		pla			pla
.abfe					L10142_END:
.abfe					L10143:
>abfe	0a					.byte L10143_END-L10143-1
.abff	48		pha			pha
.ac00	a5 63		lda $63			lda  $63
.ac02	d0 02		bne $ac06		bne  _noborrow
.ac04	c6 83		dec $83			dec  $83
.ac06					_noborrow:
.ac06	c6 63		dec $63			dec  $63
.ac08	68		pla			pla
.ac09					L10143_END:
.ac09					L10144:
>ac09	03					.byte L10144_END-L10144-1
.ac0a	ce 63 73	dec $7363		dec  $7363
.ac0d					L10144_END:
.ac0d					L10145:
>ac0d	01					.byte L10145_END-L10145-1
.ac0e	88		dey			dey
.ac0f					L10145_END:
.ac0f					L10146:
>ac0f	06					.byte L10146_END-L10146-1
.ac10	c9 00		cmp #$00		cmp  #0
.ac12	d0 01		bne $ac15		bne  *+3
.ac14	ca		dex			dex
.ac15	3a		dec a			dec  a
.ac16					L10146_END:
.ac16					L10147:
>ac16	01					.byte L10147_END-L10147-1
.ac17	3a		dec a			dec  a
.ac18					L10147_END:
.ac18					L10148:
>ac18	02					.byte L10148_END-L10148-1
.ac19	e6 63		inc $63			inc  $63
.ac1b					L10148_END:
.ac1b					L10149:
>ac1b	08					.byte L10149_END-L10149-1
.ac1c	ee 63 73	inc $7363		inc  $7363
.ac1f	d0 03		bne $ac24		bne  _nocarry
.ac21	ee 83 73	inc $7383		inc  $7383
.ac24					_nocarry:
.ac24					L10149_END:
.ac24					L10150:
>ac24	06					.byte L10150_END-L10150-1
.ac25	e6 63		inc $63			inc  $63
.ac27	d0 02		bne $ac2b		bne  _nocarry
.ac29	e6 83		inc $83			inc  $83
.ac2b					_nocarry:
.ac2b					L10150_END:
.ac2b					L10151:
>ac2b	03					.byte L10151_END-L10151-1
.ac2c	ee 63 73	inc $7363		inc  $7363
.ac2f					L10151_END:
.ac2f					L10152:
>ac2f	01					.byte L10152_END-L10152-1
.ac30	c8		iny			iny
.ac31					L10152_END:
.ac31					L10153:
>ac31	04					.byte L10153_END-L10153-1
.ac32	1a		inc a			inc  a
.ac33	d0 01		bne $ac36		bne  *+3
.ac35	e8		inx			inx
.ac36					L10153_END:
.ac36					L10154:
>ac36	01					.byte L10154_END-L10154-1
.ac37	1a		inc a			inc  a
.ac38					L10154_END:
.ac38					ExecutableVectorTable:
>ac38	60 a5					.word Action_call                      ; 0
>ac3a	f3 a6					.word Action_wordvar                   ; 1
>ac3c	49 a6					.word Action_until                     ; 2
>ac3e	40 a6					.word Action_repeat                    ; 3
>ac40	62 a7					.word Action_dictionarycrunch          ; 4
>ac42	70 a6					.word Action_rfor                      ; 5
>ac44	19 a5					.word Action_procedure_def             ; 6
>ac46	a1 a6					.word Action_next                      ; 7
>ac48	db a5					.word Action_if                        ; 8
>ac4a	50 a5					.word Action_endproc                   ; 9
>ac4c	12 a6					.word Action_endif                     ; 10
>ac4e	f0 a5					.word Action_else                      ; 11
>ac50	ef a6					.word Action_bytevar                   ; 12
>ac52	5d a6					.word Action_afor                      ; 13
.ac54					SystemDictionary:
>ac54	07					.byte	7
>ac55	4d					.byte	'M'
>ac56	0e a9					.word	L10000
>ac58	00					.byte	0
>ac59	01					.byte	1
>ac5a	f7					.byte	$f7
>ac5b	0c					.byte	12
>ac5c	4d					.byte	'M'
>ac5d	13 a9					.word	L10001
>ac5f	00					.byte	0
>ac60	06					.byte	6
>ac61	f3 db d9 dd bd d2			.byte	$f3,$db,$d9,$dd,$bd,$d2
>ac67	0c					.byte	12
>ac68	4d					.byte	'M'
>ac69	1d a9					.word	L10002
>ac6b	00					.byte	0
>ac6c	06					.byte	6
>ac6d	f3 db d9 dd bd c1			.byte	$f3,$db,$d9,$dd,$bd,$c1
>ac73	09					.byte	9
>ac74	4d					.byte	'M'
>ac75	20 a9					.word	L10003
>ac77	00					.byte	0
>ac78	03					.byte	3
>ac79	f3 bd d9				.byte	$f3,$bd,$d9
>ac7c	09					.byte	9
>ac7d	4d					.byte	'M'
>ac7e	23 a9					.word	L10004
>ac80	00					.byte	0
>ac81	03					.byte	3
>ac82	f3 bd d2				.byte	$f3,$bd,$d2
>ac85	09					.byte	9
>ac86	4d					.byte	'M'
>ac87	26 a9					.word	L10005
>ac89	00					.byte	0
>ac8a	03					.byte	3
>ac8b	f3 bd c1				.byte	$f3,$bd,$c1
>ac8e	07					.byte	7
>ac8f	4d					.byte	'M'
>ac90	29 a9					.word	L10006
>ac92	00					.byte	0
>ac93	01					.byte	1
>ac94	f3					.byte	$f3
>ac95	07					.byte	7
>ac96	4d					.byte	'M'
>ac97	2e a9					.word	L10007
>ac99	00					.byte	0
>ac9a	01					.byte	1
>ac9b	f0					.byte	$f0
>ac9c	09					.byte	9
>ac9d	4d					.byte	'M'
>ac9e	31 a9					.word	L10008
>aca0	00					.byte	0
>aca1	03					.byte	3
>aca2	ec bd d2				.byte	$ec,$bd,$d2
>aca5	07					.byte	7
>aca6	4d					.byte	'M'
>aca7	38 a9					.word	L10009
>aca9	00					.byte	0
>acaa	01					.byte	1
>acab	ec					.byte	$ec
>acac	09					.byte	9
>acad	4d					.byte	'M'
>acae	3f a9					.word	L10010
>acb0	00					.byte	0
>acb1	03					.byte	3
>acb2	e9 bd d2				.byte	$e9,$bd,$d2
>acb5	07					.byte	7
>acb6	4d					.byte	'M'
>acb7	44 a9					.word	L10011
>acb9	00					.byte	0
>acba	01					.byte	1
>acbb	e9					.byte	$e9
>acbc	09					.byte	9
>acbd	4d					.byte	'M'
>acbe	49 a9					.word	L10012
>acc0	00					.byte	0
>acc1	03					.byte	3
>acc2	e3 bd d9				.byte	$e3,$bd,$d9
>acc5	09					.byte	9
>acc6	4d					.byte	'M'
>acc7	4d a9					.word	L10013
>acc9	00					.byte	0
>acca	03					.byte	3
>accb	e3 bd d2				.byte	$e3,$bd,$d2
>acce	09					.byte	9
>accf	4d					.byte	'M'
>acd0	51 a9					.word	L10014
>acd2	00					.byte	0
>acd3	03					.byte	3
>acd4	e3 bd c1				.byte	$e3,$bd,$c1
>acd7	07					.byte	7
>acd8	4d					.byte	'M'
>acd9	55 a9					.word	L10015
>acdb	00					.byte	0
>acdc	01					.byte	1
>acdd	e3					.byte	$e3
>acde	07					.byte	7
>acdf	4d					.byte	'M'
>ace0	5b a9					.word	L10016
>ace2	00					.byte	0
>ace3	01					.byte	1
>ace4	e2					.byte	$e2
>ace5	0b					.byte	11
>ace6	4d					.byte	'M'
>ace7	60 a9					.word	L10017
>ace9	00					.byte	0
>acea	05					.byte	5
>aceb	de 52 50 48 c1				.byte	$de,$52,$50,$48,$c1
>acf0	08					.byte	8
>acf1	4d					.byte	'M'
>acf2	68 a9					.word	L10018
>acf4	00					.byte	0
>acf5	02					.byte	2
>acf6	de c1					.byte	$de,$c1
>acf8	09					.byte	9
>acf9	4d					.byte	'M'
>acfa	6b a9					.word	L10019
>acfc	00					.byte	0
>acfd	03					.byte	3
>acfe	d9 bd f3				.byte	$d9,$bd,$f3
>ad01	09					.byte	9
>ad02	4d					.byte	'M'
>ad03	6e a9					.word	L10020
>ad05	00					.byte	0
>ad06	03					.byte	3
>ad07	d9 bd e3				.byte	$d9,$bd,$e3
>ad0a	09					.byte	9
>ad0b	4d					.byte	'M'
>ad0c	72 a9					.word	L10021
>ad0e	00					.byte	0
>ad0f	03					.byte	3
>ad10	d9 bd e2				.byte	$d9,$bd,$e2
>ad13	09					.byte	9
>ad14	4d					.byte	'M'
>ad15	75 a9					.word	L10022
>ad17	00					.byte	0
>ad18	03					.byte	3
>ad19	d9 bd d2				.byte	$d9,$bd,$d2
>ad1c	09					.byte	9
>ad1d	4d					.byte	'M'
>ad1e	77 a9					.word	L10023
>ad20	00					.byte	0
>ad21	03					.byte	3
>ad22	d9 bd c1				.byte	$d9,$bd,$c1
>ad25	0a					.byte	10
>ad26	4d					.byte	'M'
>ad27	79 a9					.word	L10024
>ad29	00					.byte	0
>ad2a	04					.byte	4
>ad2b	d9 ad be d3				.byte	$d9,$ad,$be,$d3
>ad2f	0a					.byte	10
>ad30	4d					.byte	'M'
>ad31	7b a9					.word	L10025
>ad33	00					.byte	0
>ad34	04					.byte	4
>ad35	57 4f 52 c4				.byte	$57,$4f,$52,$c4
>ad39	0b					.byte	11
>ad3a	4d					.byte	'M'
>ad3b	7e a9					.word	L10026
>ad3d	00					.byte	0
>ad3e	05					.byte	5
>ad3f	55 4e 54 49 cc				.byte	$55,$4e,$54,$49,$cc
>ad44	0a					.byte	10
>ad45	4d					.byte	'M'
>ad46	81 a9					.word	L10027
>ad48	00					.byte	0
>ad49	04					.byte	4
>ad4a	d3 ad be d9				.byte	$d3,$ad,$be,$d9
>ad4e	0c					.byte	12
>ad4f	4d					.byte	'M'
>ad50	83 a9					.word	L10028
>ad52	00					.byte	0
>ad53	06					.byte	6
>ad54	d3 ad be 52 41 d9			.byte	$d3,$ad,$be,$52,$41,$d9
>ad5a	0a					.byte	10
>ad5b	4d					.byte	'M'
>ad5c	87 a9					.word	L10029
>ad5e	00					.byte	0
>ad5f	04					.byte	4
>ad60	d3 ad be d2				.byte	$d3,$ad,$be,$d2
>ad64	0a					.byte	10
>ad65	4d					.byte	'M'
>ad66	8a a9					.word	L10030
>ad68	00					.byte	0
>ad69	04					.byte	4
>ad6a	d3 ad be c1				.byte	$d3,$ad,$be,$c1
>ad6e	09					.byte	9
>ad6f	4d					.byte	'M'
>ad70	8c a9					.word	L10031
>ad72	00					.byte	0
>ad73	03					.byte	3
>ad74	d2 f7 f7				.byte	$d2,$f7,$f7
>ad77	0c					.byte	12
>ad78	4d					.byte	'M'
>ad79	95 a9					.word	L10032
>ad7b	00					.byte	0
>ad7c	06					.byte	6
>ad7d	d2 f3 f3 db d9 dd			.byte	$d2,$f3,$f3,$db,$d9,$dd
>ad83	09					.byte	9
>ad84	4d					.byte	'M'
>ad85	a0 a9					.word	L10033
>ad87	00					.byte	0
>ad88	03					.byte	3
>ad89	d2 f3 f3				.byte	$d2,$f3,$f3
>ad8c	09					.byte	9
>ad8d	4d					.byte	'M'
>ad8e	a3 a9					.word	L10034
>ad90	00					.byte	0
>ad91	03					.byte	3
>ad92	d2 ec ec				.byte	$d2,$ec,$ec
>ad95	09					.byte	9
>ad96	4d					.byte	'M'
>ad97	ae a9					.word	L10035
>ad99	00					.byte	0
>ad9a	03					.byte	3
>ad9b	d2 e9 e9				.byte	$d2,$e9,$e9
>ad9e	09					.byte	9
>ad9f	4d					.byte	'M'
>ada0	b7 a9					.word	L10036
>ada2	00					.byte	0
>ada3	03					.byte	3
>ada4	d2 e3 e3				.byte	$d2,$e3,$e3
>ada7	09					.byte	9
>ada8	4d					.byte	'M'
>ada9	bb a9					.word	L10037
>adab	00					.byte	0
>adac	03					.byte	3
>adad	d2 e2 e2				.byte	$d2,$e2,$e2
>adb0	0c					.byte	12
>adb1	4d					.byte	'M'
>adb2	be a9					.word	L10038
>adb4	00					.byte	0
>adb5	06					.byte	6
>adb6	52 45 50 45 41 d4			.byte	$52,$45,$50,$45,$41,$d4
>adbc	13					.byte	19
>adbd	4d					.byte	'M'
>adbe	c1 a9					.word	L10039
>adc0	00					.byte	0
>adc1	0d					.byte	13
>adc2	52 45 4d 4f 56 45 2e 4c			.byte	$52,$45,$4d,$4f,$56,$45,$2e,$4c,$4f,$43,$41,$4c,$d3
>adca	4f 43 41 4c d3
>adcf	0c					.byte	12
>add0	4d					.byte	'M'
>add1	c4 a9					.word	L10040
>add3	00					.byte	0
>add4	06					.byte	6
>add5	52 41 d9 ad be d3			.byte	$52,$41,$d9,$ad,$be,$d3
>addb	09					.byte	9
>addc	4d					.byte	'M'
>addd	c8 a9					.word	L10041
>addf	00					.byte	0
>ade0	03					.byte	3
>ade1	d2 bd f7				.byte	$d2,$bd,$f7
>ade4	0c					.byte	12
>ade5	4d					.byte	'M'
>ade6	cd a9					.word	L10042
>ade8	00					.byte	0
>ade9	06					.byte	6
>adea	d2 bd f3 db d9 dd			.byte	$d2,$bd,$f3,$db,$d9,$dd
>adf0	09					.byte	9
>adf1	4d					.byte	'M'
>adf2	d5 a9					.word	L10043
>adf4	00					.byte	0
>adf5	03					.byte	3
>adf6	d2 bd f3				.byte	$d2,$bd,$f3
>adf9	09					.byte	9
>adfa	4d					.byte	'M'
>adfb	da a9					.word	L10044
>adfd	00					.byte	0
>adfe	03					.byte	3
>adff	d2 bd ec				.byte	$d2,$bd,$ec
>ae02	09					.byte	9
>ae03	4d					.byte	'M'
>ae04	e1 a9					.word	L10045
>ae06	00					.byte	0
>ae07	03					.byte	3
>ae08	d2 bd e9				.byte	$d2,$bd,$e9
>ae0b	09					.byte	9
>ae0c	4d					.byte	'M'
>ae0d	e6 a9					.word	L10046
>ae0f	00					.byte	0
>ae10	03					.byte	3
>ae11	d2 bd e3				.byte	$d2,$bd,$e3
>ae14	09					.byte	9
>ae15	4d					.byte	'M'
>ae16	ec a9					.word	L10047
>ae18	00					.byte	0
>ae19	03					.byte	3
>ae1a	d2 bd e2				.byte	$d2,$bd,$e2
>ae1d	09					.byte	9
>ae1e	4d					.byte	'M'
>ae1f	f1 a9					.word	L10048
>ae21	00					.byte	0
>ae22	03					.byte	3
>ae23	d2 bd d9				.byte	$d2,$bd,$d9
>ae26	09					.byte	9
>ae27	4d					.byte	'M'
>ae28	f5 a9					.word	L10049
>ae2a	00					.byte	0
>ae2b	03					.byte	3
>ae2c	d2 bd c1				.byte	$d2,$bd,$c1
>ae2f	09					.byte	9
>ae30	4d					.byte	'M'
>ae31	f8 a9					.word	L10050
>ae33	00					.byte	0
>ae34	03					.byte	3
>ae35	d2 bd bf				.byte	$d2,$bd,$bf
>ae38	0a					.byte	10
>ae39	4d					.byte	'M'
>ae3a	02 aa					.word	L10051
>ae3c	00					.byte	0
>ae3d	04					.byte	4
>ae3e	d2 bc be bf				.byte	$d2,$bc,$be,$bf
>ae42	09					.byte	9
>ae43	4d					.byte	'M'
>ae44	0c aa					.word	L10052
>ae46	00					.byte	0
>ae47	03					.byte	3
>ae48	d2 ba f7				.byte	$d2,$ba,$f7
>ae4b	0c					.byte	12
>ae4c	4d					.byte	'M'
>ae4d	15 aa					.word	L10053
>ae4f	00					.byte	0
>ae50	06					.byte	6
>ae51	d2 ba f3 db d9 dd			.byte	$d2,$ba,$f3,$db,$d9,$dd
>ae57	09					.byte	9
>ae58	4d					.byte	'M'
>ae59	20 aa					.word	L10054
>ae5b	00					.byte	0
>ae5c	03					.byte	3
>ae5d	d2 ba f3				.byte	$d2,$ba,$f3
>ae60	09					.byte	9
>ae61	4d					.byte	'M'
>ae62	23 aa					.word	L10055
>ae64	00					.byte	0
>ae65	03					.byte	3
>ae66	d2 ba ec				.byte	$d2,$ba,$ec
>ae69	09					.byte	9
>ae6a	4d					.byte	'M'
>ae6b	2e aa					.word	L10056
>ae6d	00					.byte	0
>ae6e	03					.byte	3
>ae6f	d2 ba e9				.byte	$d2,$ba,$e9
>ae72	09					.byte	9
>ae73	4d					.byte	'M'
>ae74	37 aa					.word	L10057
>ae76	00					.byte	0
>ae77	03					.byte	3
>ae78	d2 ba e3				.byte	$d2,$ba,$e3
>ae7b	09					.byte	9
>ae7c	4d					.byte	'M'
>ae7d	3b aa					.word	L10058
>ae7f	00					.byte	0
>ae80	03					.byte	3
>ae81	d2 ba e2				.byte	$d2,$ba,$e2
>ae84	0c					.byte	12
>ae85	4d					.byte	'M'
>ae86	3e aa					.word	L10059
>ae88	00					.byte	0
>ae89	06					.byte	6
>ae8a	52 2e 53 57 41 d0			.byte	$52,$2e,$53,$57,$41,$d0
>ae90	0b					.byte	11
>ae91	4d					.byte	'M'
>ae92	42 aa					.word	L10060
>ae94	00					.byte	0
>ae95	05					.byte	5
>ae96	52 2e 46 4f d2				.byte	$52,$2e,$46,$4f,$d2
>ae9b	09					.byte	9
>ae9c	4d					.byte	'M'
>ae9d	45 aa					.word	L10061
>ae9f	00					.byte	0
>aea0	03					.byte	3
>aea1	d2 ad f7				.byte	$d2,$ad,$f7
>aea4	0c					.byte	12
>aea5	4d					.byte	'M'
>aea6	4f aa					.word	L10062
>aea8	00					.byte	0
>aea9	06					.byte	6
>aeaa	d2 ad f3 db d9 dd			.byte	$d2,$ad,$f3,$db,$d9,$dd
>aeb0	09					.byte	9
>aeb1	4d					.byte	'M'
>aeb2	5b aa					.word	L10063
>aeb4	00					.byte	0
>aeb5	03					.byte	3
>aeb6	d2 ad f3				.byte	$d2,$ad,$f3
>aeb9	09					.byte	9
>aeba	4d					.byte	'M'
>aebb	62 aa					.word	L10064
>aebd	00					.byte	0
>aebe	03					.byte	3
>aebf	d2 ad ec				.byte	$d2,$ad,$ec
>aec2	09					.byte	9
>aec3	4d					.byte	'M'
>aec4	6e aa					.word	L10065
>aec6	00					.byte	0
>aec7	03					.byte	3
>aec8	d2 ad e9				.byte	$d2,$ad,$e9
>aecb	09					.byte	9
>aecc	4d					.byte	'M'
>aecd	78 aa					.word	L10066
>aecf	00					.byte	0
>aed0	03					.byte	3
>aed1	d2 ad e3				.byte	$d2,$ad,$e3
>aed4	09					.byte	9
>aed5	4d					.byte	'M'
>aed6	80 aa					.word	L10067
>aed8	00					.byte	0
>aed9	03					.byte	3
>aeda	d2 ad e2				.byte	$d2,$ad,$e2
>aedd	09					.byte	9
>aede	4d					.byte	'M'
>aedf	87 aa					.word	L10068
>aee1	00					.byte	0
>aee2	03					.byte	3
>aee3	d2 ad bf				.byte	$d2,$ad,$bf
>aee6	0a					.byte	10
>aee7	4d					.byte	'M'
>aee8	8d aa					.word	L10069
>aeea	00					.byte	0
>aeeb	04					.byte	4
>aeec	d2 ad be d3				.byte	$d2,$ad,$be,$d3
>aef0	09					.byte	9
>aef1	4d					.byte	'M'
>aef2	90 aa					.word	L10070
>aef4	00					.byte	0
>aef5	03					.byte	3
>aef6	d2 ab f7				.byte	$d2,$ab,$f7
>aef9	0c					.byte	12
>aefa	4d					.byte	'M'
>aefb	9a aa					.word	L10071
>aefd	00					.byte	0
>aefe	06					.byte	6
>aeff	d2 ab f3 db d9 dd			.byte	$d2,$ab,$f3,$db,$d9,$dd
>af05	09					.byte	9
>af06	4d					.byte	'M'
>af07	a6 aa					.word	L10072
>af09	00					.byte	0
>af0a	03					.byte	3
>af0b	d2 ab f3				.byte	$d2,$ab,$f3
>af0e	09					.byte	9
>af0f	4d					.byte	'M'
>af10	ad aa					.word	L10073
>af12	00					.byte	0
>af13	03					.byte	3
>af14	d2 ab ec				.byte	$d2,$ab,$ec
>af17	09					.byte	9
>af18	4d					.byte	'M'
>af19	b9 aa					.word	L10074
>af1b	00					.byte	0
>af1c	03					.byte	3
>af1d	d2 ab e9				.byte	$d2,$ab,$e9
>af20	09					.byte	9
>af21	4d					.byte	'M'
>af22	c3 aa					.word	L10075
>af24	00					.byte	0
>af25	03					.byte	3
>af26	d2 ab e3				.byte	$d2,$ab,$e3
>af29	09					.byte	9
>af2a	4d					.byte	'M'
>af2b	cb aa					.word	L10076
>af2d	00					.byte	0
>af2e	03					.byte	3
>af2f	d2 ab e2				.byte	$d2,$ab,$e2
>af32	09					.byte	9
>af33	4d					.byte	'M'
>af34	d2 aa					.word	L10077
>af36	00					.byte	0
>af37	03					.byte	3
>af38	d2 ab bf				.byte	$d2,$ab,$bf
>af3b	09					.byte	9
>af3c	4d					.byte	'M'
>af3d	d8 aa					.word	L10078
>af3f	00					.byte	0
>af40	03					.byte	3
>af41	d2 a6 f7				.byte	$d2,$a6,$f7
>af44	0c					.byte	12
>af45	4d					.byte	'M'
>af46	e1 aa					.word	L10079
>af48	00					.byte	0
>af49	06					.byte	6
>af4a	d2 a6 f3 db d9 dd			.byte	$d2,$a6,$f3,$db,$d9,$dd
>af50	09					.byte	9
>af51	4d					.byte	'M'
>af52	ec aa					.word	L10080
>af54	00					.byte	0
>af55	03					.byte	3
>af56	d2 a6 f3				.byte	$d2,$a6,$f3
>af59	09					.byte	9
>af5a	4d					.byte	'M'
>af5b	f1 aa					.word	L10081
>af5d	00					.byte	0
>af5e	03					.byte	3
>af5f	d2 a6 ec				.byte	$d2,$a6,$ec
>af62	09					.byte	9
>af63	4d					.byte	'M'
>af64	fc aa					.word	L10082
>af66	00					.byte	0
>af67	03					.byte	3
>af68	d2 a6 e9				.byte	$d2,$a6,$e9
>af6b	09					.byte	9
>af6c	4d					.byte	'M'
>af6d	05 ab					.word	L10083
>af6f	00					.byte	0
>af70	03					.byte	3
>af71	d2 a6 e3				.byte	$d2,$a6,$e3
>af74	09					.byte	9
>af75	4d					.byte	'M'
>af76	0b ab					.word	L10084
>af78	00					.byte	0
>af79	03					.byte	3
>af7a	d2 a6 e2				.byte	$d2,$a6,$e2
>af7d	0a					.byte	10
>af7e	4d					.byte	'M'
>af7f	10 ab					.word	L10085
>af81	00					.byte	0
>af82	04					.byte	4
>af83	50 52 4f c3				.byte	$50,$52,$4f,$c3
>af87	0a					.byte	10
>af88	4d					.byte	'M'
>af89	13 ab					.word	L10086
>af8b	00					.byte	0
>af8c	04					.byte	4
>af8d	4e 45 58 d4				.byte	$4e,$45,$58,$d4
>af91	08					.byte	8
>af92	4d					.byte	'M'
>af93	16 ab					.word	L10087
>af95	00					.byte	0
>af96	02					.byte	2
>af97	49 c6					.byte	$49,$c6
>af99	0d					.byte	13
>af9a	4d					.byte	'M'
>af9b	19 ab					.word	L10088
>af9d	00					.byte	0
>af9e	07					.byte	7
>af9f	45 4e 44 50 52 4f c3			.byte	$45,$4e,$44,$50,$52,$4f,$c3
>afa6	0b					.byte	11
>afa7	4d					.byte	'M'
>afa8	1c ab					.word	L10089
>afaa	00					.byte	0
>afab	05					.byte	5
>afac	45 4e 44 49 c6				.byte	$45,$4e,$44,$49,$c6
>afb1	0a					.byte	10
>afb2	4d					.byte	'M'
>afb3	1f ab					.word	L10090
>afb5	00					.byte	0
>afb6	04					.byte	4
>afb7	45 4c 53 c5				.byte	$45,$4c,$53,$c5
>afbb	09					.byte	9
>afbc	4d					.byte	'M'
>afbd	22 ab					.word	L10091
>afbf	00					.byte	0
>afc0	03					.byte	3
>afc1	43 d3 bf				.byte	$43,$d3,$bf
>afc4	09					.byte	9
>afc5	4d					.byte	'M'
>afc6	26 ab					.word	L10092
>afc8	00					.byte	0
>afc9	03					.byte	3
>afca	43 c3 bf				.byte	$43,$c3,$bf
>afcd	0a					.byte	10
>afce	4d					.byte	'M'
>afcf	2a ab					.word	L10093
>afd1	00					.byte	0
>afd2	04					.byte	4
>afd3	42 59 54 c5				.byte	$42,$59,$54,$c5
>afd7	0b					.byte	11
>afd8	4d					.byte	'M'
>afd9	2d ab					.word	L10094
>afdb	00					.byte	0
>afdc	05					.byte	5
>afdd	42 52 45 41 cb				.byte	$42,$52,$45,$41,$cb
>afe2	0c					.byte	12
>afe3	4d					.byte	'M'
>afe4	2f ab					.word	L10095
>afe6	00					.byte	0
>afe7	06					.byte	6
>afe8	c1 f3 f3 db d9 dd			.byte	$c1,$f3,$f3,$db,$d9,$dd
>afee	09					.byte	9
>afef	4d					.byte	'M'
>aff0	32 ab					.word	L10096
>aff2	00					.byte	0
>aff3	03					.byte	3
>aff4	c1 f3 f3				.byte	$c1,$f3,$f3
>aff7	09					.byte	9
>aff8	4d					.byte	'M'
>aff9	35 ab					.word	L10097
>affb	00					.byte	0
>affc	03					.byte	3
>affd	c1 e3 e3				.byte	$c1,$e3,$e3
>b000	09					.byte	9
>b001	4d					.byte	'M'
>b002	39 ab					.word	L10098
>b004	00					.byte	0
>b005	03					.byte	3
>b006	c1 e2 e2				.byte	$c1,$e2,$e2
>b009	0c					.byte	12
>b00a	4d					.byte	'M'
>b00b	3c ab					.word	L10099
>b00d	00					.byte	0
>b00e	06					.byte	6
>b00f	c1 bd f3 db d9 dd			.byte	$c1,$bd,$f3,$db,$d9,$dd
>b015	09					.byte	9
>b016	4d					.byte	'M'
>b017	3f ab					.word	L10100
>b019	00					.byte	0
>b01a	03					.byte	3
>b01b	c1 bd f3				.byte	$c1,$bd,$f3
>b01e	09					.byte	9
>b01f	4d					.byte	'M'
>b020	42 ab					.word	L10101
>b022	00					.byte	0
>b023	03					.byte	3
>b024	c1 bd e3				.byte	$c1,$bd,$e3
>b027	09					.byte	9
>b028	4d					.byte	'M'
>b029	46 ab					.word	L10102
>b02b	00					.byte	0
>b02c	03					.byte	3
>b02d	c1 bd e2				.byte	$c1,$bd,$e2
>b030	09					.byte	9
>b031	4d					.byte	'M'
>b032	49 ab					.word	L10103
>b034	00					.byte	0
>b035	03					.byte	3
>b036	c1 bd d9				.byte	$c1,$bd,$d9
>b039	09					.byte	9
>b03a	4d					.byte	'M'
>b03b	4b ab					.word	L10104
>b03d	00					.byte	0
>b03e	03					.byte	3
>b03f	c1 bd d2				.byte	$c1,$bd,$d2
>b042	09					.byte	9
>b043	4d					.byte	'M'
>b044	4c ab					.word	L10105
>b046	00					.byte	0
>b047	03					.byte	3
>b048	c1 bd bf				.byte	$c1,$bd,$bf
>b04b	0a					.byte	10
>b04c	4d					.byte	'M'
>b04d	52 ab					.word	L10106
>b04f	00					.byte	0
>b050	04					.byte	4
>b051	c1 bc be bf				.byte	$c1,$bc,$be,$bf
>b055	0c					.byte	12
>b056	4d					.byte	'M'
>b057	58 ab					.word	L10107
>b059	00					.byte	0
>b05a	06					.byte	6
>b05b	c1 ba f3 db d9 dd			.byte	$c1,$ba,$f3,$db,$d9,$dd
>b061	09					.byte	9
>b062	4d					.byte	'M'
>b063	5b ab					.word	L10108
>b065	00					.byte	0
>b066	03					.byte	3
>b067	c1 ba f3				.byte	$c1,$ba,$f3
>b06a	09					.byte	9
>b06b	4d					.byte	'M'
>b06c	5e ab					.word	L10109
>b06e	00					.byte	0
>b06f	03					.byte	3
>b070	c1 ba e3				.byte	$c1,$ba,$e3
>b073	09					.byte	9
>b074	4d					.byte	'M'
>b075	62 ab					.word	L10110
>b077	00					.byte	0
>b078	03					.byte	3
>b079	c1 ba e2				.byte	$c1,$ba,$e2
>b07c	0b					.byte	11
>b07d	4d					.byte	'M'
>b07e	65 ab					.word	L10111
>b080	00					.byte	0
>b081	05					.byte	5
>b082	41 2e 46 4f d2				.byte	$41,$2e,$46,$4f,$d2
>b087	0c					.byte	12
>b088	4d					.byte	'M'
>b089	68 ab					.word	L10112
>b08b	00					.byte	0
>b08c	06					.byte	6
>b08d	c1 ad f3 db d9 dd			.byte	$c1,$ad,$f3,$db,$d9,$dd
>b093	09					.byte	9
>b094	4d					.byte	'M'
>b095	6c ab					.word	L10113
>b097	00					.byte	0
>b098	03					.byte	3
>b099	c1 ad f3				.byte	$c1,$ad,$f3
>b09c	09					.byte	9
>b09d	4d					.byte	'M'
>b09e	70 ab					.word	L10114
>b0a0	00					.byte	0
>b0a1	03					.byte	3
>b0a2	c1 ad e3				.byte	$c1,$ad,$e3
>b0a5	09					.byte	9
>b0a6	4d					.byte	'M'
>b0a7	75 ab					.word	L10115
>b0a9	00					.byte	0
>b0aa	03					.byte	3
>b0ab	c1 ad e2				.byte	$c1,$ad,$e2
>b0ae	09					.byte	9
>b0af	4d					.byte	'M'
>b0b0	79 ab					.word	L10116
>b0b2	00					.byte	0
>b0b3	03					.byte	3
>b0b4	c1 ad bf				.byte	$c1,$ad,$bf
>b0b7	0a					.byte	10
>b0b8	4d					.byte	'M'
>b0b9	7f ab					.word	L10117
>b0bb	00					.byte	0
>b0bc	04					.byte	4
>b0bd	c1 ad be d3				.byte	$c1,$ad,$be,$d3
>b0c1	0c					.byte	12
>b0c2	4d					.byte	'M'
>b0c3	81 ab					.word	L10118
>b0c5	00					.byte	0
>b0c6	06					.byte	6
>b0c7	c1 ab f3 db d9 dd			.byte	$c1,$ab,$f3,$db,$d9,$dd
>b0cd	09					.byte	9
>b0ce	4d					.byte	'M'
>b0cf	85 ab					.word	L10119
>b0d1	00					.byte	0
>b0d2	03					.byte	3
>b0d3	c1 ab f3				.byte	$c1,$ab,$f3
>b0d6	09					.byte	9
>b0d7	4d					.byte	'M'
>b0d8	89 ab					.word	L10120
>b0da	00					.byte	0
>b0db	03					.byte	3
>b0dc	c1 ab e3				.byte	$c1,$ab,$e3
>b0df	09					.byte	9
>b0e0	4d					.byte	'M'
>b0e1	8e ab					.word	L10121
>b0e3	00					.byte	0
>b0e4	03					.byte	3
>b0e5	c1 ab e2				.byte	$c1,$ab,$e2
>b0e8	09					.byte	9
>b0e9	4d					.byte	'M'
>b0ea	92 ab					.word	L10122
>b0ec	00					.byte	0
>b0ed	03					.byte	3
>b0ee	c1 ab bf				.byte	$c1,$ab,$bf
>b0f1	0c					.byte	12
>b0f2	4d					.byte	'M'
>b0f3	98 ab					.word	L10123
>b0f5	00					.byte	0
>b0f6	06					.byte	6
>b0f7	c1 a6 f3 db d9 dd			.byte	$c1,$a6,$f3,$db,$d9,$dd
>b0fd	09					.byte	9
>b0fe	4d					.byte	'M'
>b0ff	9b ab					.word	L10124
>b101	00					.byte	0
>b102	03					.byte	3
>b103	c1 a6 f3				.byte	$c1,$a6,$f3
>b106	09					.byte	9
>b107	4d					.byte	'M'
>b108	9e ab					.word	L10125
>b10a	00					.byte	0
>b10b	03					.byte	3
>b10c	c1 a6 e3				.byte	$c1,$a6,$e3
>b10f	09					.byte	9
>b110	4d					.byte	'M'
>b111	a2 ab					.word	L10126
>b113	00					.byte	0
>b114	03					.byte	3
>b115	c1 a6 e2				.byte	$c1,$a6,$e2
>b118	09					.byte	9
>b119	4d					.byte	'M'
>b11a	a5 ab					.word	L10127
>b11c	00					.byte	0
>b11d	03					.byte	3
>b11e	be be f3				.byte	$be,$be,$f3
>b121	09					.byte	9
>b122	4d					.byte	'M'
>b123	a8 ab					.word	L10128
>b125	00					.byte	0
>b126	03					.byte	3
>b127	be be ec				.byte	$be,$be,$ec
>b12a	09					.byte	9
>b12b	4d					.byte	'M'
>b12c	af ab					.word	L10129
>b12e	00					.byte	0
>b12f	03					.byte	3
>b130	be be e9				.byte	$be,$be,$e9
>b133	09					.byte	9
>b134	4d					.byte	'M'
>b135	b4 ab					.word	L10130
>b137	00					.byte	0
>b138	03					.byte	3
>b139	be be e3				.byte	$be,$be,$e3
>b13c	09					.byte	9
>b13d	4d					.byte	'M'
>b13e	b8 ab					.word	L10131
>b140	00					.byte	0
>b141	03					.byte	3
>b142	be be d2				.byte	$be,$be,$d2
>b145	09					.byte	9
>b146	4d					.byte	'M'
>b147	bf ab					.word	L10132
>b149	00					.byte	0
>b14a	03					.byte	3
>b14b	be be c1				.byte	$be,$be,$c1
>b14e	09					.byte	9
>b14f	4d					.byte	'M'
>b150	c1 ab					.word	L10133
>b152	00					.byte	0
>b153	03					.byte	3
>b154	bc bc f3				.byte	$bc,$bc,$f3
>b157	09					.byte	9
>b158	4d					.byte	'M'
>b159	c4 ab					.word	L10134
>b15b	00					.byte	0
>b15c	03					.byte	3
>b15d	bc bc ec				.byte	$bc,$bc,$ec
>b160	09					.byte	9
>b161	4d					.byte	'M'
>b162	cb ab					.word	L10135
>b164	00					.byte	0
>b165	03					.byte	3
>b166	bc bc e9				.byte	$bc,$bc,$e9
>b169	09					.byte	9
>b16a	4d					.byte	'M'
>b16b	d0 ab					.word	L10136
>b16d	00					.byte	0
>b16e	03					.byte	3
>b16f	bc bc e3				.byte	$bc,$bc,$e3
>b172	09					.byte	9
>b173	4d					.byte	'M'
>b174	d4 ab					.word	L10137
>b176	00					.byte	0
>b177	03					.byte	3
>b178	bc bc d2				.byte	$bc,$bc,$d2
>b17b	09					.byte	9
>b17c	4d					.byte	'M'
>b17d	db ab					.word	L10138
>b17f	00					.byte	0
>b180	03					.byte	3
>b181	bc bc c1				.byte	$bc,$bc,$c1
>b184	0b					.byte	11
>b185	4d					.byte	'M'
>b186	dd ab					.word	L10139
>b188	00					.byte	0
>b189	05					.byte	5
>b18a	ad 52 50 48 c1				.byte	$ad,$52,$50,$48,$c1
>b18f	08					.byte	8
>b190	4d					.byte	'M'
>b191	e9 ab					.word	L10140
>b193	00					.byte	0
>b194	02					.byte	2
>b195	ad c1					.byte	$ad,$c1
>b197	09					.byte	9
>b198	4d					.byte	'M'
>b199	ed ab					.word	L10141
>b19b	00					.byte	0
>b19c	03					.byte	3
>b19d	ad ad f3				.byte	$ad,$ad,$f3
>b1a0	09					.byte	9
>b1a1	4d					.byte	'M'
>b1a2	f0 ab					.word	L10142
>b1a4	00					.byte	0
>b1a5	03					.byte	3
>b1a6	ad ad ec				.byte	$ad,$ad,$ec
>b1a9	09					.byte	9
>b1aa	4d					.byte	'M'
>b1ab	fe ab					.word	L10143
>b1ad	00					.byte	0
>b1ae	03					.byte	3
>b1af	ad ad e9				.byte	$ad,$ad,$e9
>b1b2	09					.byte	9
>b1b3	4d					.byte	'M'
>b1b4	09 ac					.word	L10144
>b1b6	00					.byte	0
>b1b7	03					.byte	3
>b1b8	ad ad e3				.byte	$ad,$ad,$e3
>b1bb	09					.byte	9
>b1bc	4d					.byte	'M'
>b1bd	0d ac					.word	L10145
>b1bf	00					.byte	0
>b1c0	03					.byte	3
>b1c1	ad ad d9				.byte	$ad,$ad,$d9
>b1c4	09					.byte	9
>b1c5	4d					.byte	'M'
>b1c6	0f ac					.word	L10146
>b1c8	00					.byte	0
>b1c9	03					.byte	3
>b1ca	ad ad d2				.byte	$ad,$ad,$d2
>b1cd	09					.byte	9
>b1ce	4d					.byte	'M'
>b1cf	16 ac					.word	L10147
>b1d1	00					.byte	0
>b1d2	03					.byte	3
>b1d3	ad ad c1				.byte	$ad,$ad,$c1
>b1d6	09					.byte	9
>b1d7	4d					.byte	'M'
>b1d8	18 ac					.word	L10148
>b1da	00					.byte	0
>b1db	03					.byte	3
>b1dc	ab ab f3				.byte	$ab,$ab,$f3
>b1df	09					.byte	9
>b1e0	4d					.byte	'M'
>b1e1	1b ac					.word	L10149
>b1e3	00					.byte	0
>b1e4	03					.byte	3
>b1e5	ab ab ec				.byte	$ab,$ab,$ec
>b1e8	09					.byte	9
>b1e9	4d					.byte	'M'
>b1ea	24 ac					.word	L10150
>b1ec	00					.byte	0
>b1ed	03					.byte	3
>b1ee	ab ab e9				.byte	$ab,$ab,$e9
>b1f1	09					.byte	9
>b1f2	4d					.byte	'M'
>b1f3	2b ac					.word	L10151
>b1f5	00					.byte	0
>b1f6	03					.byte	3
>b1f7	ab ab e3				.byte	$ab,$ab,$e3
>b1fa	09					.byte	9
>b1fb	4d					.byte	'M'
>b1fc	2f ac					.word	L10152
>b1fe	00					.byte	0
>b1ff	03					.byte	3
>b200	ab ab d9				.byte	$ab,$ab,$d9
>b203	09					.byte	9
>b204	4d					.byte	'M'
>b205	31 ac					.word	L10153
>b207	00					.byte	0
>b208	03					.byte	3
>b209	ab ab d2				.byte	$ab,$ab,$d2
>b20c	09					.byte	9
>b20d	4d					.byte	'M'
>b20e	36 ac					.word	L10154
>b210	00					.byte	0
>b211	03					.byte	3
>b212	ab ab c1				.byte	$ab,$ab,$c1
>b215	00					.byte	$00

;******  Return to file: main.asm


;******  Processing file: utility/loadcode.asm

.b216					LoadBasicCode:
.b216	a9 45		lda #$45			lda 	#(LBCTest) & $FF
.b218	85 0a		sta $0a				sta 	zTemp0
.b21a	a9 b2		lda #$b2			lda 	#(LBCTest) >> 8
.b21c	85 0b		sta $0b				sta 	zTemp0+1
.b21e	a9 01		lda #$01			lda 	#($801) & $FF
.b220	85 0c		sta $0c				sta 	zTemp1
.b222	a9 08		lda #$08			lda 	#($801) >> 8
.b224	85 0d		sta $0d				sta 	zTemp1+1
.b226					_LBCCopy:
.b226	a0 02		ldy #$02			ldy 	#2							; skip over the loading address
.b228	b1 0a		lda ($0a),y			lda 	(zTemp0),y 					; skips first two bytes :)
.b22a	92 0c		sta ($0c)			sta 	(zTemp1)
.b22c	e6 0a		inc $0a				inc 	zTemp0
.b22e	d0 02		bne $b232			bne 	_NoCarry
.b230	e6 0b		inc $0b				inc 	zTemp0+1
.b232					_NoCarry:
.b232	e6 0c		inc $0c				inc 	zTemp1
.b234	d0 02		bne $b238			bne 	_NoCarry
.b236	e6 0d		inc $0d				inc 	zTemp1+1
.b238					_NoCarry:
.b238	a5 0a		lda $0a				lda 	zTemp0
.b23a	c9 e9		cmp #$e9			cmp 	#LBCTestEnd & $FF
.b23c	d0 e8		bne $b226			bne 	_LBCCopy
.b23e	a5 0b		lda $0b				lda 	zTemp0+1
.b240	c9 b8		cmp #$b8			cmp 	#LBCTestEnd >> 8
.b242	d0 e2		bne $b226			bne 	_LBCCopy
.b244	60		rts				rts
.b245					LBCTest:
>b245	01 08 0c 08 e8 03 99 c7				.binary 	"../generated/test.prg"
>b24d	28 31 34 29 00 17 08 f2 03 9e 34 30 39 36 30 00
>b25d	32 08 fc 03 8f 2e 20 57 4f 52 44 20 56 45 52 41
>b26d	2e 4c 4f 57 40 24 39 46 32 30 00 4e 08 06 04 8f
>b27d	2e 20 42 59 54 45 20 56 45 52 41 2e 48 49 47 48
>b28d	40 24 39 46 32 32 00 6a 08 10 04 8f 2e 20 42 59
>b29d	54 45 20 56 45 52 41 2e 44 41 54 41 40 24 39 46
>b2ad	32 33 00 83 08 1a 04 8f 2e 20 57 4f 52 44 20 2e
>b2bd	53 50 52 49 54 45 2e 42 41 53 45 00 9c 08 24 04
>b2cd	8f 2e 20 42 59 54 45 20 2e 53 50 52 49 54 45 2e
>b2dd	4d 4f 44 45 00 b3 08 2e 04 8f 2e 20 50 52 4f 43
>b2ed	20 56 45 52 41 2e 53 45 54 28 29 00 c7 08 38 04
>b2fd	8f 2e 20 56 45 52 41 2e 4c 4f 57 20 3d 20 52 00
>b30d	ea 08 42 04 8f 2e 20 41 3d 59 20 41 26 24 30 46
>b31d	20 41 3a 24 31 30 20 56 45 52 41 2e 48 49 47 48
>b32d	3d 41 00 f9 08 4c 04 8f 2e 20 45 4e 44 50 52 4f
>b33d	43 00 14 09 56 04 8f 2e 20 50 52 4f 43 20 56 45
>b34d	52 41 2e 50 41 4c 45 54 54 45 28 29 00 22 09 60
>b35d	04 8f 2e 20 52 41 59 2d 3e 53 00 4f 09 6a 04 8f
>b36d	2e 20 52 2d 3e 53 20 52 3d 59 20 3c 3c 52 20 52
>b37d	3a 24 31 30 30 30 20 59 3d 24 30 46 20 56 45 52
>b38d	41 2e 53 45 54 28 29 00 7a 09 74 04 8f 2e 20 53
>b39d	2d 3e 52 20 56 45 52 41 2e 44 41 54 41 3d 41 20
>b3ad	52 2e 53 57 41 50 20 56 45 52 41 2e 44 41 54 41
>b3bd	3d 41 00 88 09 7e 04 8f 2e 20 53 2d 3e 52 41 59
>b3cd	00 97 09 88 04 8f 2e 20 45 4e 44 50 52 4f 43 00
>b3dd	b9 09 92 04 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b3ed	2e 53 50 52 49 54 45 53 2e 45 4e 41 42 4c 45 28
>b3fd	29 00 16 0a 9c 04 8f 2e 20 52 41 59 2d 3e 53 20
>b40d	2e 53 50 52 49 54 45 2e 4d 4f 44 45 3d 59 20 52
>b41d	3c 3e 3f 20 49 46 20 31 20 45 4e 44 49 46 20 41
>b42d	2d 3e 53 20 56 45 52 41 2e 53 45 54 28 24 34 30
>b43d	30 30 2c 24 46 29 20 53 2d 3e 41 20 56 45 52 41
>b44d	2e 44 41 54 41 3d 41 20 53 2d 3e 52 41 59 00 25
>b45d	0a a6 04 8f 2e 20 45 4e 44 50 52 4f 43 00 3f 0a
>b46d	b0 04 8f 2e 20 50 52 4f 43 20 56 45 52 41 2e 53
>b47d	45 4c 45 43 54 28 29 00 7d 0a ba 04 8f 2e 20 52
>b48d	41 59 2d 3e 53 20 52 26 24 37 46 20 3c 3c 41 20
>b49d	3c 3c 52 20 3c 3c 52 20 52 3a 24 35 30 30 30 20
>b4ad	2e 53 50 52 49 54 45 2e 42 41 53 45 3d 52 20 53
>b4bd	2d 3e 52 41 59 00 8c 0a c4 04 8f 2e 20 45 4e 44
>b4cd	50 52 4f 43 00 a7 0a ce 04 8f 2e 20 50 52 4f 43
>b4dd	20 2e 56 45 52 41 2e 41 43 43 45 53 53 28 29 00
>b4ed	d8 0a d8 04 8f 2e 20 59 2d 3e 53 20 52 2b 2e 53
>b4fd	50 52 49 54 45 2e 42 41 53 45 20 59 3d 24 30 46
>b50d	20 56 45 52 41 2e 53 45 54 28 29 20 53 2d 3e 59
>b51d	00 e7 0a e2 04 8f 2e 20 45 4e 44 50 52 4f 43 00
>b52d	fc 0a ec 04 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b53d	2e 58 28 29 00 4a 0b f6 04 8f 2e 20 52 41 59 2d
>b54d	3e 53 20 52 2d 3e 53 20 2e 56 45 52 41 2e 41 43
>b55d	43 45 53 53 28 32 29 20 53 2d 3e 52 20 56 45 52
>b56d	41 2e 44 41 54 41 3d 41 20 52 2e 53 57 41 50 20
>b57d	56 45 52 41 2e 44 41 54 41 3d 41 20 53 2d 3e 52
>b58d	41 59 00 59 0b 00 05 8f 2e 20 45 4e 44 50 52 4f
>b59d	43 00 6e 0b 0a 05 8f 2e 20 50 52 4f 43 20 56 45
>b5ad	52 41 2e 59 28 29 00 bc 0b 14 05 8f 2e 20 52 41
>b5bd	59 2d 3e 53 20 52 2d 3e 53 20 2e 56 45 52 41 2e
>b5cd	41 43 43 45 53 53 28 34 29 20 53 2d 3e 52 20 56
>b5dd	45 52 41 2e 44 41 54 41 3d 41 20 52 2e 53 57 41
>b5ed	50 20 56 45 52 41 2e 44 41 54 41 3d 41 20 53 2d
>b5fd	3e 52 41 59 00 cb 0b 1e 05 8f 2e 20 45 4e 44 50
>b60d	52 4f 43 00 e5 0b 28 05 8f 2e 20 50 52 4f 43 20
>b61d	56 45 52 41 2e 43 52 45 41 54 45 28 29 00 f3 0b
>b62d	32 05 8f 2e 20 52 41 59 2d 3e 53 00 0f 0c 3c 05
>b63d	8f 2e 20 3c 3c 41 20 3c 3c 41 20 3c 3c 41 20 3c
>b64d	3c 41 20 41 2d 3e 53 00 4a 0c 46 05 8f 2e 20 2e
>b65d	56 45 52 41 2e 41 43 43 45 53 53 28 36 29 20 41
>b66d	20 3d 20 31 32 20 56 45 52 41 2e 44 41 54 41 3d
>b67d	41 20 53 2d 3e 41 20 56 45 52 41 2e 44 41 54 41
>b68d	3d 41 00 58 0c 50 05 8f 2e 20 53 2d 3e 52 41 59
>b69d	00 67 0c 5a 05 8f 2e 20 45 4e 44 50 52 4f 43 00
>b6ad	82 0c 64 05 8f 2e 20 50 52 4f 43 20 56 45 52 41
>b6bd	2e 47 52 41 50 48 49 43 28 29 00 90 0c 6e 05 8f
>b6cd	2e 20 52 41 59 2d 3e 53 00 b5 0c 78 05 8f 2e 20
>b6dd	3e 3e 52 20 52 2d 3e 53 20 52 2d 3e 53 20 2e 56
>b6ed	45 52 41 2e 41 43 43 45 53 53 28 30 29 00 cd 0c
>b6fd	82 05 8f 2e 20 53 2d 3e 52 20 56 45 52 41 2e 44
>b70d	41 54 41 3d 41 00 01 0d 8c 05 8f 2e 20 53 2d 3e
>b71d	52 20 52 2e 53 57 41 50 20 41 26 24 30 46 20 41
>b72d	2b 2e 53 50 52 49 54 45 2e 4d 4f 44 45 20 56 45
>b73d	52 41 2e 44 41 54 41 3d 41 00 0f 0d 96 05 8f 2e
>b74d	20 53 2d 3e 52 41 59 00 1e 0d a0 05 8f 2e 20 45
>b75d	4e 44 50 52 4f 43 00 31 0d aa 05 8f 2e 20 50 52
>b76d	4f 43 20 4d 41 49 4e 28 29 00 4d 0d b4 05 8f 2e
>b77d	20 56 45 52 41 2e 50 41 4c 45 54 54 45 28 24 46
>b78d	38 30 2c 31 29 00 69 0d be 05 8f 2e 20 56 45 52
>b79d	41 2e 50 41 4c 45 54 54 45 28 24 30 30 30 2c 36
>b7ad	29 00 8b 0d c8 05 8f 2e 20 56 45 52 41 2e 53 50
>b7bd	52 49 54 45 53 2e 45 4e 41 42 4c 45 28 31 2c 24
>b7cd	30 30 29 00 a6 0d d2 05 8f 2e 20 56 45 52 41 2e
>b7dd	53 45 54 28 24 34 30 30 30 2c 24 30 31 29 00 d1
>b7ed	0d dc 05 8f 2e 20 34 30 39 36 20 52 2e 46 4f 52
>b7fd	20 3e 3e 41 20 3e 3e 41 20 56 45 52 41 2e 44 41
>b80d	54 41 3d 41 20 4e 45 58 54 00 e1 0d e6 05 8f 2e
>b81d	20 31 32 20 41 2e 46 4f 52 00 ed 0d f0 05 8f 2e
>b82d	20 52 2d 3e 53 00 02 0e fa 05 8f 2e 20 56 45 52
>b83d	41 2e 53 45 4c 45 43 54 28 29 00 1a 0e 04 06 8f
>b84d	2e 20 56 45 52 41 2e 43 52 45 41 54 45 28 24 30
>b85d	41 29 00 35 0e 0e 06 8f 2e 20 56 45 52 41 2e 47
>b86d	52 41 50 48 49 43 28 24 31 34 30 30 29 00 4d 0e
>b87d	18 06 8f 2e 20 53 2d 3e 52 20 3c 3c 52 20 3c 3c
>b88d	52 20 3c 3c 52 00 61 0e 22 06 8f 2e 20 56 45 52
>b89d	41 2e 58 28 29 20 3c 3c 52 00 71 0e 2c 06 8f 2e
>b8ad	20 56 45 52 41 2e 59 28 29 00 7d 0e 36 06 8f 2e
>b8bd	20 4e 45 58 54 00 8c 0e 40 06 8f 2e 20 45 4e 44
>b8cd	50 52 4f 43 00 a1 0e 4a 06 8f 2e 20 52 45 4d 4f
>b8dd	56 45 2e 4c 4f 43 41 4c 53 00 00 00
.b8e9					LBCTestEnd:

;******  Return to file: main.asm

.b8e9					EndCode:

;******  End of listing
